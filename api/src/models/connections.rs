// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `connections.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MonitorDmxRequest)
pub struct MonitorDmxRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.MonitorDmxRequest.output_id)
    pub output_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MonitorDmxRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitorDmxRequest {
    fn default() -> &'a MonitorDmxRequest {
        <MonitorDmxRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitorDmxRequest {
    pub fn new() -> MonitorDmxRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output_id",
            |m: &MonitorDmxRequest| { &m.output_id },
            |m: &mut MonitorDmxRequest| { &mut m.output_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitorDmxRequest>(
            "MonitorDmxRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitorDmxRequest {
    const NAME: &'static str = "MonitorDmxRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.output_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.output_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.output_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.output_id.is_empty() {
            os.write_string(1, &self.output_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitorDmxRequest {
        MonitorDmxRequest::new()
    }

    fn clear(&mut self) {
        self.output_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitorDmxRequest {
        static instance: MonitorDmxRequest = MonitorDmxRequest {
            output_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitorDmxRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitorDmxRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitorDmxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorDmxRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MonitorDmxResponse)
pub struct MonitorDmxResponse {
    // message fields
    // @@protoc_insertion_point(field:mizer.MonitorDmxResponse.universes)
    pub universes: ::std::vec::Vec<MonitorDmxUniverse>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MonitorDmxResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitorDmxResponse {
    fn default() -> &'a MonitorDmxResponse {
        <MonitorDmxResponse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorDmxResponse {
    pub fn new() -> MonitorDmxResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "universes",
            |m: &MonitorDmxResponse| { &m.universes },
            |m: &mut MonitorDmxResponse| { &mut m.universes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitorDmxResponse>(
            "MonitorDmxResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitorDmxResponse {
    const NAME: &'static str = "MonitorDmxResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.universes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.universes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.universes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitorDmxResponse {
        MonitorDmxResponse::new()
    }

    fn clear(&mut self) {
        self.universes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitorDmxResponse {
        static instance: MonitorDmxResponse = MonitorDmxResponse {
            universes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitorDmxResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitorDmxResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitorDmxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorDmxResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MonitorDmxUniverse)
pub struct MonitorDmxUniverse {
    // message fields
    // @@protoc_insertion_point(field:mizer.MonitorDmxUniverse.universe)
    pub universe: u32,
    // @@protoc_insertion_point(field:mizer.MonitorDmxUniverse.channels)
    pub channels: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MonitorDmxUniverse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitorDmxUniverse {
    fn default() -> &'a MonitorDmxUniverse {
        <MonitorDmxUniverse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorDmxUniverse {
    pub fn new() -> MonitorDmxUniverse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "universe",
            |m: &MonitorDmxUniverse| { &m.universe },
            |m: &mut MonitorDmxUniverse| { &mut m.universe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channels",
            |m: &MonitorDmxUniverse| { &m.channels },
            |m: &mut MonitorDmxUniverse| { &mut m.channels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitorDmxUniverse>(
            "MonitorDmxUniverse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitorDmxUniverse {
    const NAME: &'static str = "MonitorDmxUniverse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.universe = is.read_uint32()?;
                },
                18 => {
                    self.channels = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.universe != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.universe);
        }
        if !self.channels.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.channels);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.universe != 0 {
            os.write_uint32(1, self.universe)?;
        }
        if !self.channels.is_empty() {
            os.write_bytes(2, &self.channels)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitorDmxUniverse {
        MonitorDmxUniverse::new()
    }

    fn clear(&mut self) {
        self.universe = 0;
        self.channels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitorDmxUniverse {
        static instance: MonitorDmxUniverse = MonitorDmxUniverse {
            universe: 0,
            channels: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitorDmxUniverse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitorDmxUniverse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitorDmxUniverse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorDmxUniverse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MonitorMidiRequest)
pub struct MonitorMidiRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.MonitorMidiRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MonitorMidiRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitorMidiRequest {
    fn default() -> &'a MonitorMidiRequest {
        <MonitorMidiRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitorMidiRequest {
    pub fn new() -> MonitorMidiRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MonitorMidiRequest| { &m.name },
            |m: &mut MonitorMidiRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitorMidiRequest>(
            "MonitorMidiRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitorMidiRequest {
    const NAME: &'static str = "MonitorMidiRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitorMidiRequest {
        MonitorMidiRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitorMidiRequest {
        static instance: MonitorMidiRequest = MonitorMidiRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitorMidiRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitorMidiRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitorMidiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorMidiRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MonitorMidiResponse)
pub struct MonitorMidiResponse {
    // message fields
    // @@protoc_insertion_point(field:mizer.MonitorMidiResponse.timestamp)
    pub timestamp: u64,
    // message oneof groups
    pub message: ::std::option::Option<monitor_midi_response::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MonitorMidiResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitorMidiResponse {
    fn default() -> &'a MonitorMidiResponse {
        <MonitorMidiResponse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorMidiResponse {
    pub fn new() -> MonitorMidiResponse {
        ::std::default::Default::default()
    }

    // .mizer.MonitorMidiResponse.NoteMsg cc = 3;

    pub fn cc(&self) -> &monitor_midi_response::NoteMsg {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::Cc(ref v)) => v,
            _ => <monitor_midi_response::NoteMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cc(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_cc(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::Cc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cc(&mut self, v: monitor_midi_response::NoteMsg) {
        self.message = ::std::option::Option::Some(monitor_midi_response::Message::Cc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cc(&mut self) -> &mut monitor_midi_response::NoteMsg {
        if let ::std::option::Option::Some(monitor_midi_response::Message::Cc(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(monitor_midi_response::Message::Cc(monitor_midi_response::NoteMsg::new()));
        }
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::Cc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cc(&mut self) -> monitor_midi_response::NoteMsg {
        if self.has_cc() {
            match self.message.take() {
                ::std::option::Option::Some(monitor_midi_response::Message::Cc(v)) => v,
                _ => panic!(),
            }
        } else {
            monitor_midi_response::NoteMsg::new()
        }
    }

    // .mizer.MonitorMidiResponse.NoteMsg note_off = 4;

    pub fn note_off(&self) -> &monitor_midi_response::NoteMsg {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::NoteOff(ref v)) => v,
            _ => <monitor_midi_response::NoteMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_note_off(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_note_off(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::NoteOff(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_note_off(&mut self, v: monitor_midi_response::NoteMsg) {
        self.message = ::std::option::Option::Some(monitor_midi_response::Message::NoteOff(v))
    }

    // Mutable pointer to the field.
    pub fn mut_note_off(&mut self) -> &mut monitor_midi_response::NoteMsg {
        if let ::std::option::Option::Some(monitor_midi_response::Message::NoteOff(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(monitor_midi_response::Message::NoteOff(monitor_midi_response::NoteMsg::new()));
        }
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::NoteOff(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_note_off(&mut self) -> monitor_midi_response::NoteMsg {
        if self.has_note_off() {
            match self.message.take() {
                ::std::option::Option::Some(monitor_midi_response::Message::NoteOff(v)) => v,
                _ => panic!(),
            }
        } else {
            monitor_midi_response::NoteMsg::new()
        }
    }

    // .mizer.MonitorMidiResponse.NoteMsg note_on = 5;

    pub fn note_on(&self) -> &monitor_midi_response::NoteMsg {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::NoteOn(ref v)) => v,
            _ => <monitor_midi_response::NoteMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_note_on(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_note_on(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::NoteOn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_note_on(&mut self, v: monitor_midi_response::NoteMsg) {
        self.message = ::std::option::Option::Some(monitor_midi_response::Message::NoteOn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_note_on(&mut self) -> &mut monitor_midi_response::NoteMsg {
        if let ::std::option::Option::Some(monitor_midi_response::Message::NoteOn(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(monitor_midi_response::Message::NoteOn(monitor_midi_response::NoteMsg::new()));
        }
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::NoteOn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_note_on(&mut self) -> monitor_midi_response::NoteMsg {
        if self.has_note_on() {
            match self.message.take() {
                ::std::option::Option::Some(monitor_midi_response::Message::NoteOn(v)) => v,
                _ => panic!(),
            }
        } else {
            monitor_midi_response::NoteMsg::new()
        }
    }

    // .mizer.MonitorMidiResponse.SysEx sys_ex = 6;

    pub fn sys_ex(&self) -> &monitor_midi_response::SysEx {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::SysEx(ref v)) => v,
            _ => <monitor_midi_response::SysEx as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sys_ex(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_sys_ex(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::SysEx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sys_ex(&mut self, v: monitor_midi_response::SysEx) {
        self.message = ::std::option::Option::Some(monitor_midi_response::Message::SysEx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sys_ex(&mut self) -> &mut monitor_midi_response::SysEx {
        if let ::std::option::Option::Some(monitor_midi_response::Message::SysEx(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(monitor_midi_response::Message::SysEx(monitor_midi_response::SysEx::new()));
        }
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::SysEx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sys_ex(&mut self) -> monitor_midi_response::SysEx {
        if self.has_sys_ex() {
            match self.message.take() {
                ::std::option::Option::Some(monitor_midi_response::Message::SysEx(v)) => v,
                _ => panic!(),
            }
        } else {
            monitor_midi_response::SysEx::new()
        }
    }

    // bytes unknown = 7;

    pub fn unknown(&self) -> &[u8] {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::Unknown(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_unknown(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_unknown(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::Unknown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unknown(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::std::option::Option::Some(monitor_midi_response::Message::Unknown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unknown(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(monitor_midi_response::Message::Unknown(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(monitor_midi_response::Message::Unknown(::std::vec::Vec::new()));
        }
        match self.message {
            ::std::option::Option::Some(monitor_midi_response::Message::Unknown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unknown(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_unknown() {
            match self.message.take() {
                ::std::option::Option::Some(monitor_midi_response::Message::Unknown(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &MonitorMidiResponse| { &m.timestamp },
            |m: &mut MonitorMidiResponse| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, monitor_midi_response::NoteMsg>(
            "cc",
            MonitorMidiResponse::has_cc,
            MonitorMidiResponse::cc,
            MonitorMidiResponse::mut_cc,
            MonitorMidiResponse::set_cc,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, monitor_midi_response::NoteMsg>(
            "note_off",
            MonitorMidiResponse::has_note_off,
            MonitorMidiResponse::note_off,
            MonitorMidiResponse::mut_note_off,
            MonitorMidiResponse::set_note_off,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, monitor_midi_response::NoteMsg>(
            "note_on",
            MonitorMidiResponse::has_note_on,
            MonitorMidiResponse::note_on,
            MonitorMidiResponse::mut_note_on,
            MonitorMidiResponse::set_note_on,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, monitor_midi_response::SysEx>(
            "sys_ex",
            MonitorMidiResponse::has_sys_ex,
            MonitorMidiResponse::sys_ex,
            MonitorMidiResponse::mut_sys_ex,
            MonitorMidiResponse::set_sys_ex,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "unknown",
            MonitorMidiResponse::has_unknown,
            MonitorMidiResponse::unknown,
            MonitorMidiResponse::set_unknown,
        ));
        oneofs.push(monitor_midi_response::Message::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitorMidiResponse>(
            "MonitorMidiResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitorMidiResponse {
    const NAME: &'static str = "MonitorMidiResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.timestamp = is.read_uint64()?;
                },
                26 => {
                    self.message = ::std::option::Option::Some(monitor_midi_response::Message::Cc(is.read_message()?));
                },
                34 => {
                    self.message = ::std::option::Option::Some(monitor_midi_response::Message::NoteOff(is.read_message()?));
                },
                42 => {
                    self.message = ::std::option::Option::Some(monitor_midi_response::Message::NoteOn(is.read_message()?));
                },
                50 => {
                    self.message = ::std::option::Option::Some(monitor_midi_response::Message::SysEx(is.read_message()?));
                },
                58 => {
                    self.message = ::std::option::Option::Some(monitor_midi_response::Message::Unknown(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.timestamp);
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &monitor_midi_response::Message::Cc(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &monitor_midi_response::Message::NoteOff(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &monitor_midi_response::Message::NoteOn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &monitor_midi_response::Message::SysEx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &monitor_midi_response::Message::Unknown(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &monitor_midi_response::Message::Cc(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &monitor_midi_response::Message::NoteOff(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &monitor_midi_response::Message::NoteOn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &monitor_midi_response::Message::SysEx(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &monitor_midi_response::Message::Unknown(ref v) => {
                    os.write_bytes(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitorMidiResponse {
        MonitorMidiResponse::new()
    }

    fn clear(&mut self) {
        self.timestamp = 0;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitorMidiResponse {
        static instance: MonitorMidiResponse = MonitorMidiResponse {
            timestamp: 0,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitorMidiResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitorMidiResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitorMidiResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorMidiResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MonitorMidiResponse`
pub mod monitor_midi_response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.MonitorMidiResponse.message)
    pub enum Message {
        // @@protoc_insertion_point(oneof_field:mizer.MonitorMidiResponse.cc)
        Cc(NoteMsg),
        // @@protoc_insertion_point(oneof_field:mizer.MonitorMidiResponse.note_off)
        NoteOff(NoteMsg),
        // @@protoc_insertion_point(oneof_field:mizer.MonitorMidiResponse.note_on)
        NoteOn(NoteMsg),
        // @@protoc_insertion_point(oneof_field:mizer.MonitorMidiResponse.sys_ex)
        SysEx(SysEx),
        // @@protoc_insertion_point(oneof_field:mizer.MonitorMidiResponse.unknown)
        Unknown(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Message {
    }

    impl ::protobuf::OneofFull for Message {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::MonitorMidiResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("message").unwrap()).clone()
        }
    }

    impl Message {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Message>("message")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.MonitorMidiResponse.NoteMsg)
    pub struct NoteMsg {
        // message fields
        // @@protoc_insertion_point(field:mizer.MonitorMidiResponse.NoteMsg.channel)
        pub channel: u32,
        // @@protoc_insertion_point(field:mizer.MonitorMidiResponse.NoteMsg.note)
        pub note: u32,
        // @@protoc_insertion_point(field:mizer.MonitorMidiResponse.NoteMsg.value)
        pub value: u32,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.MonitorMidiResponse.NoteMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NoteMsg {
        fn default() -> &'a NoteMsg {
            <NoteMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl NoteMsg {
        pub fn new() -> NoteMsg {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "channel",
                |m: &NoteMsg| { &m.channel },
                |m: &mut NoteMsg| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "note",
                |m: &NoteMsg| { &m.note },
                |m: &mut NoteMsg| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &NoteMsg| { &m.value },
                |m: &mut NoteMsg| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoteMsg>(
                "MonitorMidiResponse.NoteMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NoteMsg {
        const NAME: &'static str = "NoteMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.channel = is.read_uint32()?;
                    },
                    16 => {
                        self.note = is.read_uint32()?;
                    },
                    24 => {
                        self.value = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.channel != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.channel);
            }
            if self.note != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.note);
            }
            if self.value != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.value);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.channel != 0 {
                os.write_uint32(1, self.channel)?;
            }
            if self.note != 0 {
                os.write_uint32(2, self.note)?;
            }
            if self.value != 0 {
                os.write_uint32(3, self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NoteMsg {
            NoteMsg::new()
        }

        fn clear(&mut self) {
            self.channel = 0;
            self.note = 0;
            self.value = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NoteMsg {
            static instance: NoteMsg = NoteMsg {
                channel: 0,
                note: 0,
                value: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NoteMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MonitorMidiResponse.NoteMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NoteMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NoteMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.MonitorMidiResponse.SysEx)
    pub struct SysEx {
        // message fields
        // @@protoc_insertion_point(field:mizer.MonitorMidiResponse.SysEx.manufacturer1)
        pub manufacturer1: u32,
        // @@protoc_insertion_point(field:mizer.MonitorMidiResponse.SysEx.manufacturer2)
        pub manufacturer2: u32,
        // @@protoc_insertion_point(field:mizer.MonitorMidiResponse.SysEx.manufacturer3)
        pub manufacturer3: u32,
        // @@protoc_insertion_point(field:mizer.MonitorMidiResponse.SysEx.model)
        pub model: u32,
        // @@protoc_insertion_point(field:mizer.MonitorMidiResponse.SysEx.data)
        pub data: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.MonitorMidiResponse.SysEx.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SysEx {
        fn default() -> &'a SysEx {
            <SysEx as ::protobuf::Message>::default_instance()
        }
    }

    impl SysEx {
        pub fn new() -> SysEx {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "manufacturer1",
                |m: &SysEx| { &m.manufacturer1 },
                |m: &mut SysEx| { &mut m.manufacturer1 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "manufacturer2",
                |m: &SysEx| { &m.manufacturer2 },
                |m: &mut SysEx| { &mut m.manufacturer2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "manufacturer3",
                |m: &SysEx| { &m.manufacturer3 },
                |m: &mut SysEx| { &mut m.manufacturer3 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "model",
                |m: &SysEx| { &m.model },
                |m: &mut SysEx| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data",
                |m: &SysEx| { &m.data },
                |m: &mut SysEx| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SysEx>(
                "MonitorMidiResponse.SysEx",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SysEx {
        const NAME: &'static str = "SysEx";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.manufacturer1 = is.read_uint32()?;
                    },
                    16 => {
                        self.manufacturer2 = is.read_uint32()?;
                    },
                    24 => {
                        self.manufacturer3 = is.read_uint32()?;
                    },
                    32 => {
                        self.model = is.read_uint32()?;
                    },
                    42 => {
                        self.data = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.manufacturer1 != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.manufacturer1);
            }
            if self.manufacturer2 != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.manufacturer2);
            }
            if self.manufacturer3 != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.manufacturer3);
            }
            if self.model != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.model);
            }
            if !self.data.is_empty() {
                my_size += ::protobuf::rt::bytes_size(5, &self.data);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.manufacturer1 != 0 {
                os.write_uint32(1, self.manufacturer1)?;
            }
            if self.manufacturer2 != 0 {
                os.write_uint32(2, self.manufacturer2)?;
            }
            if self.manufacturer3 != 0 {
                os.write_uint32(3, self.manufacturer3)?;
            }
            if self.model != 0 {
                os.write_uint32(4, self.model)?;
            }
            if !self.data.is_empty() {
                os.write_bytes(5, &self.data)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SysEx {
            SysEx::new()
        }

        fn clear(&mut self) {
            self.manufacturer1 = 0;
            self.manufacturer2 = 0;
            self.manufacturer3 = 0;
            self.model = 0;
            self.data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SysEx {
            static instance: SysEx = SysEx {
                manufacturer1: 0,
                manufacturer2: 0,
                manufacturer3: 0,
                model: 0,
                data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SysEx {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MonitorMidiResponse.SysEx").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SysEx {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SysEx {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MonitorOscRequest)
pub struct MonitorOscRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.MonitorOscRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MonitorOscRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitorOscRequest {
    fn default() -> &'a MonitorOscRequest {
        <MonitorOscRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitorOscRequest {
    pub fn new() -> MonitorOscRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MonitorOscRequest| { &m.name },
            |m: &mut MonitorOscRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitorOscRequest>(
            "MonitorOscRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitorOscRequest {
    const NAME: &'static str = "MonitorOscRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitorOscRequest {
        MonitorOscRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitorOscRequest {
        static instance: MonitorOscRequest = MonitorOscRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitorOscRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitorOscRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitorOscRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorOscRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MonitorOscResponse)
pub struct MonitorOscResponse {
    // message fields
    // @@protoc_insertion_point(field:mizer.MonitorOscResponse.timestamp)
    pub timestamp: u64,
    // @@protoc_insertion_point(field:mizer.MonitorOscResponse.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.MonitorOscResponse.args)
    pub args: ::std::vec::Vec<monitor_osc_response::OscArgument>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MonitorOscResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MonitorOscResponse {
    fn default() -> &'a MonitorOscResponse {
        <MonitorOscResponse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorOscResponse {
    pub fn new() -> MonitorOscResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &MonitorOscResponse| { &m.timestamp },
            |m: &mut MonitorOscResponse| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &MonitorOscResponse| { &m.path },
            |m: &mut MonitorOscResponse| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &MonitorOscResponse| { &m.args },
            |m: &mut MonitorOscResponse| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MonitorOscResponse>(
            "MonitorOscResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MonitorOscResponse {
    const NAME: &'static str = "MonitorOscResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = is.read_uint64()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                26 => {
                    self.args.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.timestamp);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.timestamp != 0 {
            os.write_uint64(1, self.timestamp)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.args {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MonitorOscResponse {
        MonitorOscResponse::new()
    }

    fn clear(&mut self) {
        self.timestamp = 0;
        self.path.clear();
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MonitorOscResponse {
        static instance: MonitorOscResponse = MonitorOscResponse {
            timestamp: 0,
            path: ::std::string::String::new(),
            args: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MonitorOscResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MonitorOscResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MonitorOscResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorOscResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MonitorOscResponse`
pub mod monitor_osc_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.MonitorOscResponse.OscArgument)
    pub struct OscArgument {
        // message oneof groups
        pub argument: ::std::option::Option<osc_argument::Argument>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.MonitorOscResponse.OscArgument.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OscArgument {
        fn default() -> &'a OscArgument {
            <OscArgument as ::protobuf::Message>::default_instance()
        }
    }

    impl OscArgument {
        pub fn new() -> OscArgument {
            ::std::default::Default::default()
        }

        // int32 int = 1;

        pub fn int(&self) -> i32 {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Int(v)) => v,
                _ => 0,
            }
        }

        pub fn clear_int(&mut self) {
            self.argument = ::std::option::Option::None;
        }

        pub fn has_int(&self) -> bool {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Int(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_int(&mut self, v: i32) {
            self.argument = ::std::option::Option::Some(osc_argument::Argument::Int(v))
        }

        // float float = 2;

        pub fn float(&self) -> f32 {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Float(v)) => v,
                _ => 0.,
            }
        }

        pub fn clear_float(&mut self) {
            self.argument = ::std::option::Option::None;
        }

        pub fn has_float(&self) -> bool {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Float(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_float(&mut self, v: f32) {
            self.argument = ::std::option::Option::Some(osc_argument::Argument::Float(v))
        }

        // int64 long = 3;

        pub fn long(&self) -> i64 {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Long(v)) => v,
                _ => 0,
            }
        }

        pub fn clear_long(&mut self) {
            self.argument = ::std::option::Option::None;
        }

        pub fn has_long(&self) -> bool {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Long(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_long(&mut self, v: i64) {
            self.argument = ::std::option::Option::Some(osc_argument::Argument::Long(v))
        }

        // double double = 4;

        pub fn double(&self) -> f64 {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Double(v)) => v,
                _ => 0.,
            }
        }

        pub fn clear_double(&mut self) {
            self.argument = ::std::option::Option::None;
        }

        pub fn has_double(&self) -> bool {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Double(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_double(&mut self, v: f64) {
            self.argument = ::std::option::Option::Some(osc_argument::Argument::Double(v))
        }

        // bool bool = 5;

        pub fn bool(&self) -> bool {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Bool(v)) => v,
                _ => false,
            }
        }

        pub fn clear_bool(&mut self) {
            self.argument = ::std::option::Option::None;
        }

        pub fn has_bool(&self) -> bool {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Bool(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_bool(&mut self, v: bool) {
            self.argument = ::std::option::Option::Some(osc_argument::Argument::Bool(v))
        }

        // .mizer.MonitorOscResponse.OscArgument.OscColor color = 6;

        pub fn color(&self) -> &osc_argument::OscColor {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Color(ref v)) => v,
                _ => <osc_argument::OscColor as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_color(&mut self) {
            self.argument = ::std::option::Option::None;
        }

        pub fn has_color(&self) -> bool {
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Color(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_color(&mut self, v: osc_argument::OscColor) {
            self.argument = ::std::option::Option::Some(osc_argument::Argument::Color(v))
        }

        // Mutable pointer to the field.
        pub fn mut_color(&mut self) -> &mut osc_argument::OscColor {
            if let ::std::option::Option::Some(osc_argument::Argument::Color(_)) = self.argument {
            } else {
                self.argument = ::std::option::Option::Some(osc_argument::Argument::Color(osc_argument::OscColor::new()));
            }
            match self.argument {
                ::std::option::Option::Some(osc_argument::Argument::Color(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_color(&mut self) -> osc_argument::OscColor {
            if self.has_color() {
                match self.argument.take() {
                    ::std::option::Option::Some(osc_argument::Argument::Color(v)) => v,
                    _ => panic!(),
                }
            } else {
                osc_argument::OscColor::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "int",
                OscArgument::has_int,
                OscArgument::int,
                OscArgument::set_int,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "float",
                OscArgument::has_float,
                OscArgument::float,
                OscArgument::set_float,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "long",
                OscArgument::has_long,
                OscArgument::long,
                OscArgument::set_long,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "double",
                OscArgument::has_double,
                OscArgument::double,
                OscArgument::set_double,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "bool",
                OscArgument::has_bool,
                OscArgument::bool,
                OscArgument::set_bool,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, osc_argument::OscColor>(
                "color",
                OscArgument::has_color,
                OscArgument::color,
                OscArgument::mut_color,
                OscArgument::set_color,
            ));
            oneofs.push(osc_argument::Argument::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OscArgument>(
                "MonitorOscResponse.OscArgument",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OscArgument {
        const NAME: &'static str = "OscArgument";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.argument = ::std::option::Option::Some(osc_argument::Argument::Int(is.read_int32()?));
                    },
                    21 => {
                        self.argument = ::std::option::Option::Some(osc_argument::Argument::Float(is.read_float()?));
                    },
                    24 => {
                        self.argument = ::std::option::Option::Some(osc_argument::Argument::Long(is.read_int64()?));
                    },
                    33 => {
                        self.argument = ::std::option::Option::Some(osc_argument::Argument::Double(is.read_double()?));
                    },
                    40 => {
                        self.argument = ::std::option::Option::Some(osc_argument::Argument::Bool(is.read_bool()?));
                    },
                    50 => {
                        self.argument = ::std::option::Option::Some(osc_argument::Argument::Color(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.argument {
                match v {
                    &osc_argument::Argument::Int(v) => {
                        my_size += ::protobuf::rt::int32_size(1, v);
                    },
                    &osc_argument::Argument::Float(v) => {
                        my_size += 1 + 4;
                    },
                    &osc_argument::Argument::Long(v) => {
                        my_size += ::protobuf::rt::int64_size(3, v);
                    },
                    &osc_argument::Argument::Double(v) => {
                        my_size += 1 + 8;
                    },
                    &osc_argument::Argument::Bool(v) => {
                        my_size += 1 + 1;
                    },
                    &osc_argument::Argument::Color(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.argument {
                match v {
                    &osc_argument::Argument::Int(v) => {
                        os.write_int32(1, v)?;
                    },
                    &osc_argument::Argument::Float(v) => {
                        os.write_float(2, v)?;
                    },
                    &osc_argument::Argument::Long(v) => {
                        os.write_int64(3, v)?;
                    },
                    &osc_argument::Argument::Double(v) => {
                        os.write_double(4, v)?;
                    },
                    &osc_argument::Argument::Bool(v) => {
                        os.write_bool(5, v)?;
                    },
                    &osc_argument::Argument::Color(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OscArgument {
            OscArgument::new()
        }

        fn clear(&mut self) {
            self.argument = ::std::option::Option::None;
            self.argument = ::std::option::Option::None;
            self.argument = ::std::option::Option::None;
            self.argument = ::std::option::Option::None;
            self.argument = ::std::option::Option::None;
            self.argument = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OscArgument {
            static instance: OscArgument = OscArgument {
                argument: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for OscArgument {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MonitorOscResponse.OscArgument").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OscArgument {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OscArgument {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `OscArgument`
    pub mod osc_argument {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:mizer.MonitorOscResponse.OscArgument.argument)
        pub enum Argument {
            // @@protoc_insertion_point(oneof_field:mizer.MonitorOscResponse.OscArgument.int)
            Int(i32),
            // @@protoc_insertion_point(oneof_field:mizer.MonitorOscResponse.OscArgument.float)
            Float(f32),
            // @@protoc_insertion_point(oneof_field:mizer.MonitorOscResponse.OscArgument.long)
            Long(i64),
            // @@protoc_insertion_point(oneof_field:mizer.MonitorOscResponse.OscArgument.double)
            Double(f64),
            // @@protoc_insertion_point(oneof_field:mizer.MonitorOscResponse.OscArgument.bool)
            Bool(bool),
            // @@protoc_insertion_point(oneof_field:mizer.MonitorOscResponse.OscArgument.color)
            Color(OscColor),
        }

        impl ::protobuf::Oneof for Argument {
        }

        impl ::protobuf::OneofFull for Argument {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::OscArgument as ::protobuf::MessageFull>::descriptor().oneof_by_name("argument").unwrap()).clone()
            }
        }

        impl Argument {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Argument>("argument")
            }
        }
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:mizer.MonitorOscResponse.OscArgument.OscColor)
        pub struct OscColor {
            // message fields
            // @@protoc_insertion_point(field:mizer.MonitorOscResponse.OscArgument.OscColor.red)
            pub red: u32,
            // @@protoc_insertion_point(field:mizer.MonitorOscResponse.OscArgument.OscColor.green)
            pub green: u32,
            // @@protoc_insertion_point(field:mizer.MonitorOscResponse.OscArgument.OscColor.blue)
            pub blue: u32,
            // @@protoc_insertion_point(field:mizer.MonitorOscResponse.OscArgument.OscColor.alpha)
            pub alpha: u32,
            // special fields
            // @@protoc_insertion_point(special_field:mizer.MonitorOscResponse.OscArgument.OscColor.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a OscColor {
            fn default() -> &'a OscColor {
                <OscColor as ::protobuf::Message>::default_instance()
            }
        }

        impl OscColor {
            pub fn new() -> OscColor {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "red",
                    |m: &OscColor| { &m.red },
                    |m: &mut OscColor| { &mut m.red },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "green",
                    |m: &OscColor| { &m.green },
                    |m: &mut OscColor| { &mut m.green },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "blue",
                    |m: &OscColor| { &m.blue },
                    |m: &mut OscColor| { &mut m.blue },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "alpha",
                    |m: &OscColor| { &m.alpha },
                    |m: &mut OscColor| { &mut m.alpha },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OscColor>(
                    "MonitorOscResponse.OscArgument.OscColor",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for OscColor {
            const NAME: &'static str = "OscColor";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.red = is.read_uint32()?;
                        },
                        16 => {
                            self.green = is.read_uint32()?;
                        },
                        24 => {
                            self.blue = is.read_uint32()?;
                        },
                        32 => {
                            self.alpha = is.read_uint32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.red != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.red);
                }
                if self.green != 0 {
                    my_size += ::protobuf::rt::uint32_size(2, self.green);
                }
                if self.blue != 0 {
                    my_size += ::protobuf::rt::uint32_size(3, self.blue);
                }
                if self.alpha != 0 {
                    my_size += ::protobuf::rt::uint32_size(4, self.alpha);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.red != 0 {
                    os.write_uint32(1, self.red)?;
                }
                if self.green != 0 {
                    os.write_uint32(2, self.green)?;
                }
                if self.blue != 0 {
                    os.write_uint32(3, self.blue)?;
                }
                if self.alpha != 0 {
                    os.write_uint32(4, self.alpha)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> OscColor {
                OscColor::new()
            }

            fn clear(&mut self) {
                self.red = 0;
                self.green = 0;
                self.blue = 0;
                self.alpha = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static OscColor {
                static instance: OscColor = OscColor {
                    red: 0,
                    green: 0,
                    blue: 0,
                    alpha: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for OscColor {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MonitorOscResponse.OscArgument.OscColor").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for OscColor {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for OscColor {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.GetConnectionsRequest)
pub struct GetConnectionsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.GetConnectionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetConnectionsRequest {
    fn default() -> &'a GetConnectionsRequest {
        <GetConnectionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectionsRequest {
    pub fn new() -> GetConnectionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetConnectionsRequest>(
            "GetConnectionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetConnectionsRequest {
    const NAME: &'static str = "GetConnectionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetConnectionsRequest {
        GetConnectionsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetConnectionsRequest {
        static instance: GetConnectionsRequest = GetConnectionsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetConnectionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetConnectionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetConnectionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.GetDeviceProfilesRequest)
pub struct GetDeviceProfilesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.GetDeviceProfilesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetDeviceProfilesRequest {
    fn default() -> &'a GetDeviceProfilesRequest {
        <GetDeviceProfilesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceProfilesRequest {
    pub fn new() -> GetDeviceProfilesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetDeviceProfilesRequest>(
            "GetDeviceProfilesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetDeviceProfilesRequest {
    const NAME: &'static str = "GetDeviceProfilesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetDeviceProfilesRequest {
        GetDeviceProfilesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetDeviceProfilesRequest {
        static instance: GetDeviceProfilesRequest = GetDeviceProfilesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetDeviceProfilesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetDeviceProfilesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetDeviceProfilesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceProfilesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.ArtnetConfig)
pub struct ArtnetConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.ArtnetConfig.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.ArtnetConfig.host)
    pub host: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.ArtnetConfig.port)
    pub port: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.ArtnetConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArtnetConfig {
    fn default() -> &'a ArtnetConfig {
        <ArtnetConfig as ::protobuf::Message>::default_instance()
    }
}

impl ArtnetConfig {
    pub fn new() -> ArtnetConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ArtnetConfig| { &m.name },
            |m: &mut ArtnetConfig| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &ArtnetConfig| { &m.host },
            |m: &mut ArtnetConfig| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &ArtnetConfig| { &m.port },
            |m: &mut ArtnetConfig| { &mut m.port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArtnetConfig>(
            "ArtnetConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArtnetConfig {
    const NAME: &'static str = "ArtnetConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.host = is.read_string()?;
                },
                24 => {
                    self.port = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        if self.port != 0 {
            os.write_uint32(3, self.port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArtnetConfig {
        ArtnetConfig::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.host.clear();
        self.port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArtnetConfig {
        static instance: ArtnetConfig = ArtnetConfig {
            name: ::std::string::String::new(),
            host: ::std::string::String::new(),
            port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArtnetConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArtnetConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArtnetConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArtnetConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.SacnConfig)
pub struct SacnConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.SacnConfig.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.SacnConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SacnConfig {
    fn default() -> &'a SacnConfig {
        <SacnConfig as ::protobuf::Message>::default_instance()
    }
}

impl SacnConfig {
    pub fn new() -> SacnConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &SacnConfig| { &m.name },
            |m: &mut SacnConfig| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SacnConfig>(
            "SacnConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SacnConfig {
    const NAME: &'static str = "SacnConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SacnConfig {
        SacnConfig::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SacnConfig {
        static instance: SacnConfig = SacnConfig {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SacnConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SacnConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SacnConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SacnConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.Connections)
pub struct Connections {
    // message fields
    // @@protoc_insertion_point(field:mizer.Connections.connections)
    pub connections: ::std::vec::Vec<Connection>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.Connections.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Connections {
    fn default() -> &'a Connections {
        <Connections as ::protobuf::Message>::default_instance()
    }
}

impl Connections {
    pub fn new() -> Connections {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connections",
            |m: &Connections| { &m.connections },
            |m: &mut Connections| { &mut m.connections },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Connections>(
            "Connections",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Connections {
    const NAME: &'static str = "Connections";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connections.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.connections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.connections {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Connections {
        Connections::new()
    }

    fn clear(&mut self) {
        self.connections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Connections {
        static instance: Connections = Connections {
            connections: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Connections {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Connections").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Connections {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Connections {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.Connection)
pub struct Connection {
    // message fields
    // @@protoc_insertion_point(field:mizer.Connection.name)
    pub name: ::std::string::String,
    // message oneof groups
    pub connection: ::std::option::Option<connection::Connection>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.Connection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Connection {
    fn default() -> &'a Connection {
        <Connection as ::protobuf::Message>::default_instance()
    }
}

impl Connection {
    pub fn new() -> Connection {
        ::std::default::Default::default()
    }

    // .mizer.DmxConnection dmx = 10;

    pub fn dmx(&self) -> &DmxConnection {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Dmx(ref v)) => v,
            _ => <DmxConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dmx(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_dmx(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Dmx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dmx(&mut self, v: DmxConnection) {
        self.connection = ::std::option::Option::Some(connection::Connection::Dmx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dmx(&mut self) -> &mut DmxConnection {
        if let ::std::option::Option::Some(connection::Connection::Dmx(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(connection::Connection::Dmx(DmxConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Dmx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dmx(&mut self) -> DmxConnection {
        if self.has_dmx() {
            match self.connection.take() {
                ::std::option::Option::Some(connection::Connection::Dmx(v)) => v,
                _ => panic!(),
            }
        } else {
            DmxConnection::new()
        }
    }

    // .mizer.MidiConnection midi = 11;

    pub fn midi(&self) -> &MidiConnection {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Midi(ref v)) => v,
            _ => <MidiConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_midi(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_midi(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Midi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_midi(&mut self, v: MidiConnection) {
        self.connection = ::std::option::Option::Some(connection::Connection::Midi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_midi(&mut self) -> &mut MidiConnection {
        if let ::std::option::Option::Some(connection::Connection::Midi(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(connection::Connection::Midi(MidiConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Midi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_midi(&mut self) -> MidiConnection {
        if self.has_midi() {
            match self.connection.take() {
                ::std::option::Option::Some(connection::Connection::Midi(v)) => v,
                _ => panic!(),
            }
        } else {
            MidiConnection::new()
        }
    }

    // .mizer.OscConnection osc = 12;

    pub fn osc(&self) -> &OscConnection {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Osc(ref v)) => v,
            _ => <OscConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_osc(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_osc(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Osc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_osc(&mut self, v: OscConnection) {
        self.connection = ::std::option::Option::Some(connection::Connection::Osc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_osc(&mut self) -> &mut OscConnection {
        if let ::std::option::Option::Some(connection::Connection::Osc(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(connection::Connection::Osc(OscConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Osc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_osc(&mut self) -> OscConnection {
        if self.has_osc() {
            match self.connection.take() {
                ::std::option::Option::Some(connection::Connection::Osc(v)) => v,
                _ => panic!(),
            }
        } else {
            OscConnection::new()
        }
    }

    // .mizer.ProDjLinkConnection pro_dj_link = 13;

    pub fn pro_dj_link(&self) -> &ProDjLinkConnection {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::ProDjLink(ref v)) => v,
            _ => <ProDjLinkConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pro_dj_link(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_pro_dj_link(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::ProDjLink(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pro_dj_link(&mut self, v: ProDjLinkConnection) {
        self.connection = ::std::option::Option::Some(connection::Connection::ProDjLink(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pro_dj_link(&mut self) -> &mut ProDjLinkConnection {
        if let ::std::option::Option::Some(connection::Connection::ProDjLink(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(connection::Connection::ProDjLink(ProDjLinkConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(connection::Connection::ProDjLink(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pro_dj_link(&mut self) -> ProDjLinkConnection {
        if self.has_pro_dj_link() {
            match self.connection.take() {
                ::std::option::Option::Some(connection::Connection::ProDjLink(v)) => v,
                _ => panic!(),
            }
        } else {
            ProDjLinkConnection::new()
        }
    }

    // .mizer.HeliosConnection helios = 14;

    pub fn helios(&self) -> &HeliosConnection {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Helios(ref v)) => v,
            _ => <HeliosConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_helios(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_helios(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Helios(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_helios(&mut self, v: HeliosConnection) {
        self.connection = ::std::option::Option::Some(connection::Connection::Helios(v))
    }

    // Mutable pointer to the field.
    pub fn mut_helios(&mut self) -> &mut HeliosConnection {
        if let ::std::option::Option::Some(connection::Connection::Helios(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(connection::Connection::Helios(HeliosConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Helios(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_helios(&mut self) -> HeliosConnection {
        if self.has_helios() {
            match self.connection.take() {
                ::std::option::Option::Some(connection::Connection::Helios(v)) => v,
                _ => panic!(),
            }
        } else {
            HeliosConnection::new()
        }
    }

    // .mizer.EtherDreamConnection ether_dream = 15;

    pub fn ether_dream(&self) -> &EtherDreamConnection {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::EtherDream(ref v)) => v,
            _ => <EtherDreamConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ether_dream(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_ether_dream(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::EtherDream(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ether_dream(&mut self, v: EtherDreamConnection) {
        self.connection = ::std::option::Option::Some(connection::Connection::EtherDream(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ether_dream(&mut self) -> &mut EtherDreamConnection {
        if let ::std::option::Option::Some(connection::Connection::EtherDream(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(connection::Connection::EtherDream(EtherDreamConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(connection::Connection::EtherDream(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ether_dream(&mut self) -> EtherDreamConnection {
        if self.has_ether_dream() {
            match self.connection.take() {
                ::std::option::Option::Some(connection::Connection::EtherDream(v)) => v,
                _ => panic!(),
            }
        } else {
            EtherDreamConnection::new()
        }
    }

    // .mizer.GamepadConnection gamepad = 16;

    pub fn gamepad(&self) -> &GamepadConnection {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Gamepad(ref v)) => v,
            _ => <GamepadConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_gamepad(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_gamepad(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Gamepad(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gamepad(&mut self, v: GamepadConnection) {
        self.connection = ::std::option::Option::Some(connection::Connection::Gamepad(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gamepad(&mut self) -> &mut GamepadConnection {
        if let ::std::option::Option::Some(connection::Connection::Gamepad(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(connection::Connection::Gamepad(GamepadConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Gamepad(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gamepad(&mut self) -> GamepadConnection {
        if self.has_gamepad() {
            match self.connection.take() {
                ::std::option::Option::Some(connection::Connection::Gamepad(v)) => v,
                _ => panic!(),
            }
        } else {
            GamepadConnection::new()
        }
    }

    // .mizer.MqttConnection mqtt = 17;

    pub fn mqtt(&self) -> &MqttConnection {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Mqtt(ref v)) => v,
            _ => <MqttConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mqtt(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_mqtt(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Mqtt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mqtt(&mut self, v: MqttConnection) {
        self.connection = ::std::option::Option::Some(connection::Connection::Mqtt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mqtt(&mut self) -> &mut MqttConnection {
        if let ::std::option::Option::Some(connection::Connection::Mqtt(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(connection::Connection::Mqtt(MqttConnection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(connection::Connection::Mqtt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mqtt(&mut self) -> MqttConnection {
        if self.has_mqtt() {
            match self.connection.take() {
                ::std::option::Option::Some(connection::Connection::Mqtt(v)) => v,
                _ => panic!(),
            }
        } else {
            MqttConnection::new()
        }
    }

    // .mizer.G13Connection g13 = 18;

    pub fn g13(&self) -> &G13Connection {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::G13(ref v)) => v,
            _ => <G13Connection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_g13(&mut self) {
        self.connection = ::std::option::Option::None;
    }

    pub fn has_g13(&self) -> bool {
        match self.connection {
            ::std::option::Option::Some(connection::Connection::G13(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_g13(&mut self, v: G13Connection) {
        self.connection = ::std::option::Option::Some(connection::Connection::G13(v))
    }

    // Mutable pointer to the field.
    pub fn mut_g13(&mut self) -> &mut G13Connection {
        if let ::std::option::Option::Some(connection::Connection::G13(_)) = self.connection {
        } else {
            self.connection = ::std::option::Option::Some(connection::Connection::G13(G13Connection::new()));
        }
        match self.connection {
            ::std::option::Option::Some(connection::Connection::G13(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_g13(&mut self) -> G13Connection {
        if self.has_g13() {
            match self.connection.take() {
                ::std::option::Option::Some(connection::Connection::G13(v)) => v,
                _ => panic!(),
            }
        } else {
            G13Connection::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Connection| { &m.name },
            |m: &mut Connection| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DmxConnection>(
            "dmx",
            Connection::has_dmx,
            Connection::dmx,
            Connection::mut_dmx,
            Connection::set_dmx,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MidiConnection>(
            "midi",
            Connection::has_midi,
            Connection::midi,
            Connection::mut_midi,
            Connection::set_midi,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OscConnection>(
            "osc",
            Connection::has_osc,
            Connection::osc,
            Connection::mut_osc,
            Connection::set_osc,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProDjLinkConnection>(
            "pro_dj_link",
            Connection::has_pro_dj_link,
            Connection::pro_dj_link,
            Connection::mut_pro_dj_link,
            Connection::set_pro_dj_link,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HeliosConnection>(
            "helios",
            Connection::has_helios,
            Connection::helios,
            Connection::mut_helios,
            Connection::set_helios,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EtherDreamConnection>(
            "ether_dream",
            Connection::has_ether_dream,
            Connection::ether_dream,
            Connection::mut_ether_dream,
            Connection::set_ether_dream,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GamepadConnection>(
            "gamepad",
            Connection::has_gamepad,
            Connection::gamepad,
            Connection::mut_gamepad,
            Connection::set_gamepad,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MqttConnection>(
            "mqtt",
            Connection::has_mqtt,
            Connection::mqtt,
            Connection::mut_mqtt,
            Connection::set_mqtt,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, G13Connection>(
            "g13",
            Connection::has_g13,
            Connection::g13,
            Connection::mut_g13,
            Connection::set_g13,
        ));
        oneofs.push(connection::Connection::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Connection>(
            "Connection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Connection {
    const NAME: &'static str = "Connection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                82 => {
                    self.connection = ::std::option::Option::Some(connection::Connection::Dmx(is.read_message()?));
                },
                90 => {
                    self.connection = ::std::option::Option::Some(connection::Connection::Midi(is.read_message()?));
                },
                98 => {
                    self.connection = ::std::option::Option::Some(connection::Connection::Osc(is.read_message()?));
                },
                106 => {
                    self.connection = ::std::option::Option::Some(connection::Connection::ProDjLink(is.read_message()?));
                },
                114 => {
                    self.connection = ::std::option::Option::Some(connection::Connection::Helios(is.read_message()?));
                },
                122 => {
                    self.connection = ::std::option::Option::Some(connection::Connection::EtherDream(is.read_message()?));
                },
                130 => {
                    self.connection = ::std::option::Option::Some(connection::Connection::Gamepad(is.read_message()?));
                },
                138 => {
                    self.connection = ::std::option::Option::Some(connection::Connection::Mqtt(is.read_message()?));
                },
                146 => {
                    self.connection = ::std::option::Option::Some(connection::Connection::G13(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.connection {
            match v {
                &connection::Connection::Dmx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &connection::Connection::Midi(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &connection::Connection::Osc(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &connection::Connection::ProDjLink(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &connection::Connection::Helios(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &connection::Connection::EtherDream(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &connection::Connection::Gamepad(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &connection::Connection::Mqtt(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &connection::Connection::G13(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.connection {
            match v {
                &connection::Connection::Dmx(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &connection::Connection::Midi(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &connection::Connection::Osc(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &connection::Connection::ProDjLink(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &connection::Connection::Helios(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &connection::Connection::EtherDream(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &connection::Connection::Gamepad(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &connection::Connection::Mqtt(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &connection::Connection::G13(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Connection {
        Connection::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.connection = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Connection {
        static instance: Connection = Connection {
            name: ::std::string::String::new(),
            connection: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Connection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Connection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Connection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Connection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Connection`
pub mod connection {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.Connection.connection)
    pub enum Connection {
        // @@protoc_insertion_point(oneof_field:mizer.Connection.dmx)
        Dmx(super::DmxConnection),
        // @@protoc_insertion_point(oneof_field:mizer.Connection.midi)
        Midi(super::MidiConnection),
        // @@protoc_insertion_point(oneof_field:mizer.Connection.osc)
        Osc(super::OscConnection),
        // @@protoc_insertion_point(oneof_field:mizer.Connection.pro_dj_link)
        ProDjLink(super::ProDjLinkConnection),
        // @@protoc_insertion_point(oneof_field:mizer.Connection.helios)
        Helios(super::HeliosConnection),
        // @@protoc_insertion_point(oneof_field:mizer.Connection.ether_dream)
        EtherDream(super::EtherDreamConnection),
        // @@protoc_insertion_point(oneof_field:mizer.Connection.gamepad)
        Gamepad(super::GamepadConnection),
        // @@protoc_insertion_point(oneof_field:mizer.Connection.mqtt)
        Mqtt(super::MqttConnection),
        // @@protoc_insertion_point(oneof_field:mizer.Connection.g13)
        G13(super::G13Connection),
    }

    impl ::protobuf::Oneof for Connection {
    }

    impl ::protobuf::OneofFull for Connection {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Connection as ::protobuf::MessageFull>::descriptor().oneof_by_name("connection").unwrap()).clone()
        }
    }

    impl Connection {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Connection>("connection")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.DmxConnection)
pub struct DmxConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.DmxConnection.output_id)
    pub output_id: ::std::string::String,
    // message oneof groups
    pub config: ::std::option::Option<dmx_connection::Config>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.DmxConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DmxConnection {
    fn default() -> &'a DmxConnection {
        <DmxConnection as ::protobuf::Message>::default_instance()
    }
}

impl DmxConnection {
    pub fn new() -> DmxConnection {
        ::std::default::Default::default()
    }

    // .mizer.ArtnetConfig artnet = 3;

    pub fn artnet(&self) -> &ArtnetConfig {
        match self.config {
            ::std::option::Option::Some(dmx_connection::Config::Artnet(ref v)) => v,
            _ => <ArtnetConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_artnet(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_artnet(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(dmx_connection::Config::Artnet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artnet(&mut self, v: ArtnetConfig) {
        self.config = ::std::option::Option::Some(dmx_connection::Config::Artnet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artnet(&mut self) -> &mut ArtnetConfig {
        if let ::std::option::Option::Some(dmx_connection::Config::Artnet(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(dmx_connection::Config::Artnet(ArtnetConfig::new()));
        }
        match self.config {
            ::std::option::Option::Some(dmx_connection::Config::Artnet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artnet(&mut self) -> ArtnetConfig {
        if self.has_artnet() {
            match self.config.take() {
                ::std::option::Option::Some(dmx_connection::Config::Artnet(v)) => v,
                _ => panic!(),
            }
        } else {
            ArtnetConfig::new()
        }
    }

    // .mizer.SacnConfig sacn = 4;

    pub fn sacn(&self) -> &SacnConfig {
        match self.config {
            ::std::option::Option::Some(dmx_connection::Config::Sacn(ref v)) => v,
            _ => <SacnConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sacn(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_sacn(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(dmx_connection::Config::Sacn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sacn(&mut self, v: SacnConfig) {
        self.config = ::std::option::Option::Some(dmx_connection::Config::Sacn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sacn(&mut self) -> &mut SacnConfig {
        if let ::std::option::Option::Some(dmx_connection::Config::Sacn(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(dmx_connection::Config::Sacn(SacnConfig::new()));
        }
        match self.config {
            ::std::option::Option::Some(dmx_connection::Config::Sacn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sacn(&mut self) -> SacnConfig {
        if self.has_sacn() {
            match self.config.take() {
                ::std::option::Option::Some(dmx_connection::Config::Sacn(v)) => v,
                _ => panic!(),
            }
        } else {
            SacnConfig::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output_id",
            |m: &DmxConnection| { &m.output_id },
            |m: &mut DmxConnection| { &mut m.output_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ArtnetConfig>(
            "artnet",
            DmxConnection::has_artnet,
            DmxConnection::artnet,
            DmxConnection::mut_artnet,
            DmxConnection::set_artnet,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SacnConfig>(
            "sacn",
            DmxConnection::has_sacn,
            DmxConnection::sacn,
            DmxConnection::mut_sacn,
            DmxConnection::set_sacn,
        ));
        oneofs.push(dmx_connection::Config::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DmxConnection>(
            "DmxConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DmxConnection {
    const NAME: &'static str = "DmxConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.output_id = is.read_string()?;
                },
                26 => {
                    self.config = ::std::option::Option::Some(dmx_connection::Config::Artnet(is.read_message()?));
                },
                34 => {
                    self.config = ::std::option::Option::Some(dmx_connection::Config::Sacn(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.output_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.output_id);
        }
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &dmx_connection::Config::Artnet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &dmx_connection::Config::Sacn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.output_id.is_empty() {
            os.write_string(1, &self.output_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &dmx_connection::Config::Artnet(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &dmx_connection::Config::Sacn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DmxConnection {
        DmxConnection::new()
    }

    fn clear(&mut self) {
        self.output_id.clear();
        self.config = ::std::option::Option::None;
        self.config = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DmxConnection {
        static instance: DmxConnection = DmxConnection {
            output_id: ::std::string::String::new(),
            config: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DmxConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DmxConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DmxConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DmxConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DmxConnection`
pub mod dmx_connection {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.DmxConnection.config)
    pub enum Config {
        // @@protoc_insertion_point(oneof_field:mizer.DmxConnection.artnet)
        Artnet(super::ArtnetConfig),
        // @@protoc_insertion_point(oneof_field:mizer.DmxConnection.sacn)
        Sacn(super::SacnConfig),
    }

    impl ::protobuf::Oneof for Config {
    }

    impl ::protobuf::OneofFull for Config {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DmxConnection as ::protobuf::MessageFull>::descriptor().oneof_by_name("config").unwrap()).clone()
        }
    }

    impl Config {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Config>("config")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.HeliosConnection)
pub struct HeliosConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.HeliosConnection.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.HeliosConnection.firmware)
    pub firmware: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.HeliosConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HeliosConnection {
    fn default() -> &'a HeliosConnection {
        <HeliosConnection as ::protobuf::Message>::default_instance()
    }
}

impl HeliosConnection {
    pub fn new() -> HeliosConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &HeliosConnection| { &m.name },
            |m: &mut HeliosConnection| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "firmware",
            |m: &HeliosConnection| { &m.firmware },
            |m: &mut HeliosConnection| { &mut m.firmware },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeliosConnection>(
            "HeliosConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HeliosConnection {
    const NAME: &'static str = "HeliosConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.firmware = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.firmware != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.firmware);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.firmware != 0 {
            os.write_uint32(2, self.firmware)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HeliosConnection {
        HeliosConnection::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.firmware = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HeliosConnection {
        static instance: HeliosConnection = HeliosConnection {
            name: ::std::string::String::new(),
            firmware: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HeliosConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HeliosConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HeliosConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeliosConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.EtherDreamConnection)
pub struct EtherDreamConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.EtherDreamConnection.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.EtherDreamConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EtherDreamConnection {
    fn default() -> &'a EtherDreamConnection {
        <EtherDreamConnection as ::protobuf::Message>::default_instance()
    }
}

impl EtherDreamConnection {
    pub fn new() -> EtherDreamConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &EtherDreamConnection| { &m.name },
            |m: &mut EtherDreamConnection| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EtherDreamConnection>(
            "EtherDreamConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EtherDreamConnection {
    const NAME: &'static str = "EtherDreamConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EtherDreamConnection {
        EtherDreamConnection::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EtherDreamConnection {
        static instance: EtherDreamConnection = EtherDreamConnection {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EtherDreamConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EtherDreamConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EtherDreamConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EtherDreamConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.GamepadConnection)
pub struct GamepadConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.GamepadConnection.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.GamepadConnection.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.GamepadConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GamepadConnection {
    fn default() -> &'a GamepadConnection {
        <GamepadConnection as ::protobuf::Message>::default_instance()
    }
}

impl GamepadConnection {
    pub fn new() -> GamepadConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GamepadConnection| { &m.id },
            |m: &mut GamepadConnection| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &GamepadConnection| { &m.name },
            |m: &mut GamepadConnection| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GamepadConnection>(
            "GamepadConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GamepadConnection {
    const NAME: &'static str = "GamepadConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GamepadConnection {
        GamepadConnection::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GamepadConnection {
        static instance: GamepadConnection = GamepadConnection {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GamepadConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GamepadConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GamepadConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GamepadConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.G13Connection)
pub struct G13Connection {
    // message fields
    // @@protoc_insertion_point(field:mizer.G13Connection.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.G13Connection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a G13Connection {
    fn default() -> &'a G13Connection {
        <G13Connection as ::protobuf::Message>::default_instance()
    }
}

impl G13Connection {
    pub fn new() -> G13Connection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &G13Connection| { &m.id },
            |m: &mut G13Connection| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<G13Connection>(
            "G13Connection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for G13Connection {
    const NAME: &'static str = "G13Connection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> G13Connection {
        G13Connection::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static G13Connection {
        static instance: G13Connection = G13Connection {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for G13Connection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("G13Connection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for G13Connection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for G13Connection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MidiConnection)
pub struct MidiConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.MidiConnection.device_profile)
    pub device_profile: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MidiConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MidiConnection {
    fn default() -> &'a MidiConnection {
        <MidiConnection as ::protobuf::Message>::default_instance()
    }
}

impl MidiConnection {
    pub fn new() -> MidiConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_profile",
            |m: &MidiConnection| { &m.device_profile },
            |m: &mut MidiConnection| { &mut m.device_profile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MidiConnection>(
            "MidiConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MidiConnection {
    const NAME: &'static str = "MidiConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_profile = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_profile.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_profile.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MidiConnection {
        MidiConnection::new()
    }

    fn clear(&mut self) {
        self.device_profile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MidiConnection {
        static instance: MidiConnection = MidiConnection {
            device_profile: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MidiConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MidiConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MidiConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MidiDeviceProfiles)
pub struct MidiDeviceProfiles {
    // message fields
    // @@protoc_insertion_point(field:mizer.MidiDeviceProfiles.profiles)
    pub profiles: ::std::vec::Vec<MidiDeviceProfile>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MidiDeviceProfiles.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MidiDeviceProfiles {
    fn default() -> &'a MidiDeviceProfiles {
        <MidiDeviceProfiles as ::protobuf::Message>::default_instance()
    }
}

impl MidiDeviceProfiles {
    pub fn new() -> MidiDeviceProfiles {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "profiles",
            |m: &MidiDeviceProfiles| { &m.profiles },
            |m: &mut MidiDeviceProfiles| { &mut m.profiles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MidiDeviceProfiles>(
            "MidiDeviceProfiles",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MidiDeviceProfiles {
    const NAME: &'static str = "MidiDeviceProfiles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.profiles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.profiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.profiles {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MidiDeviceProfiles {
        MidiDeviceProfiles::new()
    }

    fn clear(&mut self) {
        self.profiles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MidiDeviceProfiles {
        static instance: MidiDeviceProfiles = MidiDeviceProfiles {
            profiles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MidiDeviceProfiles {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MidiDeviceProfiles").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MidiDeviceProfiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiDeviceProfiles {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MidiDeviceProfile)
pub struct MidiDeviceProfile {
    // message fields
    // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.manufacturer)
    pub manufacturer: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.model)
    pub model: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.layout)
    pub layout: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.pages)
    pub pages: ::std::vec::Vec<midi_device_profile::Page>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MidiDeviceProfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MidiDeviceProfile {
    fn default() -> &'a MidiDeviceProfile {
        <MidiDeviceProfile as ::protobuf::Message>::default_instance()
    }
}

impl MidiDeviceProfile {
    pub fn new() -> MidiDeviceProfile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &MidiDeviceProfile| { &m.id },
            |m: &mut MidiDeviceProfile| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "manufacturer",
            |m: &MidiDeviceProfile| { &m.manufacturer },
            |m: &mut MidiDeviceProfile| { &mut m.manufacturer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model",
            |m: &MidiDeviceProfile| { &m.model },
            |m: &mut MidiDeviceProfile| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "layout",
            |m: &MidiDeviceProfile| { &m.layout },
            |m: &mut MidiDeviceProfile| { &mut m.layout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pages",
            |m: &MidiDeviceProfile| { &m.pages },
            |m: &mut MidiDeviceProfile| { &mut m.pages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MidiDeviceProfile>(
            "MidiDeviceProfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MidiDeviceProfile {
    const NAME: &'static str = "MidiDeviceProfile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.manufacturer = is.read_string()?;
                },
                26 => {
                    self.model = is.read_string()?;
                },
                34 => {
                    self.layout = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.pages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.manufacturer.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.manufacturer);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.model);
        }
        if let Some(v) = self.layout.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.pages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.manufacturer.is_empty() {
            os.write_string(2, &self.manufacturer)?;
        }
        if !self.model.is_empty() {
            os.write_string(3, &self.model)?;
        }
        if let Some(v) = self.layout.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.pages {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MidiDeviceProfile {
        MidiDeviceProfile::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.manufacturer.clear();
        self.model.clear();
        self.layout = ::std::option::Option::None;
        self.pages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MidiDeviceProfile {
        static instance: MidiDeviceProfile = MidiDeviceProfile {
            id: ::std::string::String::new(),
            manufacturer: ::std::string::String::new(),
            model: ::std::string::String::new(),
            layout: ::std::option::Option::None,
            pages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MidiDeviceProfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MidiDeviceProfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MidiDeviceProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiDeviceProfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MidiDeviceProfile`
pub mod midi_device_profile {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.MidiDeviceProfile.Page)
    pub struct Page {
        // message fields
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Page.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Page.groups)
        pub groups: ::std::vec::Vec<Group>,
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Page.controls)
        pub controls: ::std::vec::Vec<Control>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.MidiDeviceProfile.Page.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Page {
        fn default() -> &'a Page {
            <Page as ::protobuf::Message>::default_instance()
        }
    }

    impl Page {
        pub fn new() -> Page {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Page| { &m.name },
                |m: &mut Page| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "groups",
                |m: &Page| { &m.groups },
                |m: &mut Page| { &mut m.groups },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "controls",
                |m: &Page| { &m.controls },
                |m: &mut Page| { &mut m.controls },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Page>(
                "MidiDeviceProfile.Page",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Page {
        const NAME: &'static str = "Page";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.groups.push(is.read_message()?);
                    },
                    26 => {
                        self.controls.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            for value in &self.groups {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.controls {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            for v in &self.groups {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.controls {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Page {
            Page::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.groups.clear();
            self.controls.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Page {
            static instance: Page = Page {
                name: ::std::string::String::new(),
                groups: ::std::vec::Vec::new(),
                controls: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Page {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MidiDeviceProfile.Page").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Page {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Page {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.MidiDeviceProfile.Group)
    pub struct Group {
        // message fields
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Group.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Group.controls)
        pub controls: ::std::vec::Vec<Control>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.MidiDeviceProfile.Group.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Group {
        fn default() -> &'a Group {
            <Group as ::protobuf::Message>::default_instance()
        }
    }

    impl Group {
        pub fn new() -> Group {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Group| { &m.name },
                |m: &mut Group| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "controls",
                |m: &Group| { &m.controls },
                |m: &mut Group| { &mut m.controls },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Group>(
                "MidiDeviceProfile.Group",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Group {
        const NAME: &'static str = "Group";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.controls.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            for value in &self.controls {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            for v in &self.controls {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Group {
            Group::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.controls.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Group {
            static instance: Group = Group {
                name: ::std::string::String::new(),
                controls: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Group {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MidiDeviceProfile.Group").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Group {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Group {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.MidiDeviceProfile.Control)
    pub struct Control {
        // message fields
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Control.id)
        pub id: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Control.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Control.channel)
        pub channel: u32,
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Control.note)
        pub note: u32,
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Control.control_type)
        pub control_type: ::protobuf::EnumOrUnknown<ControlType>,
        // @@protoc_insertion_point(field:mizer.MidiDeviceProfile.Control.has_output)
        pub has_output: bool,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.MidiDeviceProfile.Control.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Control {
        fn default() -> &'a Control {
            <Control as ::protobuf::Message>::default_instance()
        }
    }

    impl Control {
        pub fn new() -> Control {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &Control| { &m.id },
                |m: &mut Control| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Control| { &m.name },
                |m: &mut Control| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "channel",
                |m: &Control| { &m.channel },
                |m: &mut Control| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "note",
                |m: &Control| { &m.note },
                |m: &mut Control| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "control_type",
                |m: &Control| { &m.control_type },
                |m: &mut Control| { &mut m.control_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "has_output",
                |m: &Control| { &m.has_output },
                |m: &mut Control| { &mut m.has_output },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Control>(
                "MidiDeviceProfile.Control",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Control {
        const NAME: &'static str = "Control";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    },
                    18 => {
                        self.name = is.read_string()?;
                    },
                    24 => {
                        self.channel = is.read_uint32()?;
                    },
                    32 => {
                        self.note = is.read_uint32()?;
                    },
                    40 => {
                        self.control_type = is.read_enum_or_unknown()?;
                    },
                    48 => {
                        self.has_output = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.name);
            }
            if self.channel != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.channel);
            }
            if self.note != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.note);
            }
            if self.control_type != ::protobuf::EnumOrUnknown::new(ControlType::NOTE) {
                my_size += ::protobuf::rt::int32_size(5, self.control_type.value());
            }
            if self.has_output != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            if !self.name.is_empty() {
                os.write_string(2, &self.name)?;
            }
            if self.channel != 0 {
                os.write_uint32(3, self.channel)?;
            }
            if self.note != 0 {
                os.write_uint32(4, self.note)?;
            }
            if self.control_type != ::protobuf::EnumOrUnknown::new(ControlType::NOTE) {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.control_type))?;
            }
            if self.has_output != false {
                os.write_bool(6, self.has_output)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Control {
            Control::new()
        }

        fn clear(&mut self) {
            self.id.clear();
            self.name.clear();
            self.channel = 0;
            self.note = 0;
            self.control_type = ::protobuf::EnumOrUnknown::new(ControlType::NOTE);
            self.has_output = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Control {
            static instance: Control = Control {
                id: ::std::string::String::new(),
                name: ::std::string::String::new(),
                channel: 0,
                note: 0,
                control_type: ::protobuf::EnumOrUnknown::from_i32(0),
                has_output: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Control {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MidiDeviceProfile.Control").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Control {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Control {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.MidiDeviceProfile.ControlType)
    pub enum ControlType {
        // @@protoc_insertion_point(enum_value:mizer.MidiDeviceProfile.ControlType.NOTE)
        NOTE = 0,
        // @@protoc_insertion_point(enum_value:mizer.MidiDeviceProfile.ControlType.CC)
        CC = 1,
    }

    impl ::protobuf::Enum for ControlType {
        const NAME: &'static str = "ControlType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ControlType> {
            match value {
                0 => ::std::option::Option::Some(ControlType::NOTE),
                1 => ::std::option::Option::Some(ControlType::CC),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ControlType] = &[
            ControlType::NOTE,
            ControlType::CC,
        ];
    }

    impl ::protobuf::EnumFull for ControlType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MidiDeviceProfile.ControlType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ControlType {
        fn default() -> Self {
            ControlType::NOTE
        }
    }

    impl ControlType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ControlType>("MidiDeviceProfile.ControlType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.OscConnection)
pub struct OscConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.OscConnection.connection_id)
    pub connection_id: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.OscConnection.input_port)
    pub input_port: u32,
    // @@protoc_insertion_point(field:mizer.OscConnection.output_port)
    pub output_port: u32,
    // @@protoc_insertion_point(field:mizer.OscConnection.output_address)
    pub output_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.OscConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OscConnection {
    fn default() -> &'a OscConnection {
        <OscConnection as ::protobuf::Message>::default_instance()
    }
}

impl OscConnection {
    pub fn new() -> OscConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connection_id",
            |m: &OscConnection| { &m.connection_id },
            |m: &mut OscConnection| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_port",
            |m: &OscConnection| { &m.input_port },
            |m: &mut OscConnection| { &mut m.input_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output_port",
            |m: &OscConnection| { &m.output_port },
            |m: &mut OscConnection| { &mut m.output_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output_address",
            |m: &OscConnection| { &m.output_address },
            |m: &mut OscConnection| { &mut m.output_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OscConnection>(
            "OscConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OscConnection {
    const NAME: &'static str = "OscConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection_id = is.read_string()?;
                },
                16 => {
                    self.input_port = is.read_uint32()?;
                },
                24 => {
                    self.output_port = is.read_uint32()?;
                },
                34 => {
                    self.output_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.connection_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.connection_id);
        }
        if self.input_port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.input_port);
        }
        if self.output_port != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.output_port);
        }
        if !self.output_address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.output_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.connection_id.is_empty() {
            os.write_string(1, &self.connection_id)?;
        }
        if self.input_port != 0 {
            os.write_uint32(2, self.input_port)?;
        }
        if self.output_port != 0 {
            os.write_uint32(3, self.output_port)?;
        }
        if !self.output_address.is_empty() {
            os.write_string(4, &self.output_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OscConnection {
        OscConnection::new()
    }

    fn clear(&mut self) {
        self.connection_id.clear();
        self.input_port = 0;
        self.output_port = 0;
        self.output_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OscConnection {
        static instance: OscConnection = OscConnection {
            connection_id: ::std::string::String::new(),
            input_port: 0,
            output_port: 0,
            output_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OscConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OscConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OscConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OscConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.ProDjLinkConnection)
pub struct ProDjLinkConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.ProDjLinkConnection.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.ProDjLinkConnection.model)
    pub model: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.ProDjLinkConnection.player_number)
    pub player_number: u32,
    // @@protoc_insertion_point(field:mizer.ProDjLinkConnection.playback)
    pub playback: ::protobuf::MessageField<CdjPlayback>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.ProDjLinkConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProDjLinkConnection {
    fn default() -> &'a ProDjLinkConnection {
        <ProDjLinkConnection as ::protobuf::Message>::default_instance()
    }
}

impl ProDjLinkConnection {
    pub fn new() -> ProDjLinkConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &ProDjLinkConnection| { &m.address },
            |m: &mut ProDjLinkConnection| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model",
            |m: &ProDjLinkConnection| { &m.model },
            |m: &mut ProDjLinkConnection| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "player_number",
            |m: &ProDjLinkConnection| { &m.player_number },
            |m: &mut ProDjLinkConnection| { &mut m.player_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CdjPlayback>(
            "playback",
            |m: &ProDjLinkConnection| { &m.playback },
            |m: &mut ProDjLinkConnection| { &mut m.playback },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProDjLinkConnection>(
            "ProDjLinkConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProDjLinkConnection {
    const NAME: &'static str = "ProDjLinkConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.model = is.read_string()?;
                },
                24 => {
                    self.player_number = is.read_uint32()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.playback)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model);
        }
        if self.player_number != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.player_number);
        }
        if let Some(v) = self.playback.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.model.is_empty() {
            os.write_string(2, &self.model)?;
        }
        if self.player_number != 0 {
            os.write_uint32(3, self.player_number)?;
        }
        if let Some(v) = self.playback.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProDjLinkConnection {
        ProDjLinkConnection::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.model.clear();
        self.player_number = 0;
        self.playback.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProDjLinkConnection {
        static instance: ProDjLinkConnection = ProDjLinkConnection {
            address: ::std::string::String::new(),
            model: ::std::string::String::new(),
            player_number: 0,
            playback: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProDjLinkConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProDjLinkConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProDjLinkConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProDjLinkConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.CdjPlayback)
pub struct CdjPlayback {
    // message fields
    // @@protoc_insertion_point(field:mizer.CdjPlayback.live)
    pub live: bool,
    // @@protoc_insertion_point(field:mizer.CdjPlayback.bpm)
    pub bpm: f64,
    // @@protoc_insertion_point(field:mizer.CdjPlayback.frame)
    pub frame: u32,
    // @@protoc_insertion_point(field:mizer.CdjPlayback.playback)
    pub playback: ::protobuf::EnumOrUnknown<cdj_playback::State>,
    // @@protoc_insertion_point(field:mizer.CdjPlayback.track)
    pub track: ::protobuf::MessageField<cdj_playback::Track>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.CdjPlayback.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CdjPlayback {
    fn default() -> &'a CdjPlayback {
        <CdjPlayback as ::protobuf::Message>::default_instance()
    }
}

impl CdjPlayback {
    pub fn new() -> CdjPlayback {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "live",
            |m: &CdjPlayback| { &m.live },
            |m: &mut CdjPlayback| { &mut m.live },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bpm",
            |m: &CdjPlayback| { &m.bpm },
            |m: &mut CdjPlayback| { &mut m.bpm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "frame",
            |m: &CdjPlayback| { &m.frame },
            |m: &mut CdjPlayback| { &mut m.frame },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "playback",
            |m: &CdjPlayback| { &m.playback },
            |m: &mut CdjPlayback| { &mut m.playback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cdj_playback::Track>(
            "track",
            |m: &CdjPlayback| { &m.track },
            |m: &mut CdjPlayback| { &mut m.track },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CdjPlayback>(
            "CdjPlayback",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CdjPlayback {
    const NAME: &'static str = "CdjPlayback";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.live = is.read_bool()?;
                },
                17 => {
                    self.bpm = is.read_double()?;
                },
                24 => {
                    self.frame = is.read_uint32()?;
                },
                32 => {
                    self.playback = is.read_enum_or_unknown()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.track)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.live != false {
            my_size += 1 + 1;
        }
        if self.bpm != 0. {
            my_size += 1 + 8;
        }
        if self.frame != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.frame);
        }
        if self.playback != ::protobuf::EnumOrUnknown::new(cdj_playback::State::LOADING) {
            my_size += ::protobuf::rt::int32_size(4, self.playback.value());
        }
        if let Some(v) = self.track.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.live != false {
            os.write_bool(1, self.live)?;
        }
        if self.bpm != 0. {
            os.write_double(2, self.bpm)?;
        }
        if self.frame != 0 {
            os.write_uint32(3, self.frame)?;
        }
        if self.playback != ::protobuf::EnumOrUnknown::new(cdj_playback::State::LOADING) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.playback))?;
        }
        if let Some(v) = self.track.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CdjPlayback {
        CdjPlayback::new()
    }

    fn clear(&mut self) {
        self.live = false;
        self.bpm = 0.;
        self.frame = 0;
        self.playback = ::protobuf::EnumOrUnknown::new(cdj_playback::State::LOADING);
        self.track.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CdjPlayback {
        static instance: CdjPlayback = CdjPlayback {
            live: false,
            bpm: 0.,
            frame: 0,
            playback: ::protobuf::EnumOrUnknown::from_i32(0),
            track: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CdjPlayback {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CdjPlayback").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CdjPlayback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdjPlayback {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CdjPlayback`
pub mod cdj_playback {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.CdjPlayback.Track)
    pub struct Track {
        // message fields
        // @@protoc_insertion_point(field:mizer.CdjPlayback.Track.artist)
        pub artist: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.CdjPlayback.Track.title)
        pub title: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.CdjPlayback.Track.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Track {
        fn default() -> &'a Track {
            <Track as ::protobuf::Message>::default_instance()
        }
    }

    impl Track {
        pub fn new() -> Track {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "artist",
                |m: &Track| { &m.artist },
                |m: &mut Track| { &mut m.artist },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &Track| { &m.title },
                |m: &mut Track| { &mut m.title },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Track>(
                "CdjPlayback.Track",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Track {
        const NAME: &'static str = "Track";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.artist = is.read_string()?;
                    },
                    18 => {
                        self.title = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.artist.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.artist);
            }
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.title);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.artist.is_empty() {
                os.write_string(1, &self.artist)?;
            }
            if !self.title.is_empty() {
                os.write_string(2, &self.title)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Track {
            Track::new()
        }

        fn clear(&mut self) {
            self.artist.clear();
            self.title.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Track {
            static instance: Track = Track {
                artist: ::std::string::String::new(),
                title: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Track {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CdjPlayback.Track").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Track {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Track {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.CdjPlayback.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:mizer.CdjPlayback.State.LOADING)
        LOADING = 0,
        // @@protoc_insertion_point(enum_value:mizer.CdjPlayback.State.PLAYING)
        PLAYING = 1,
        // @@protoc_insertion_point(enum_value:mizer.CdjPlayback.State.CUED)
        CUED = 2,
        // @@protoc_insertion_point(enum_value:mizer.CdjPlayback.State.CUEING)
        CUEING = 3,
    }

    impl ::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::LOADING),
                1 => ::std::option::Option::Some(State::PLAYING),
                2 => ::std::option::Option::Some(State::CUED),
                3 => ::std::option::Option::Some(State::CUEING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::LOADING,
            State::PLAYING,
            State::CUED,
            State::CUEING,
        ];
    }

    impl ::protobuf::EnumFull for State {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CdjPlayback.State").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::LOADING
        }
    }

    impl State {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<State>("CdjPlayback.State")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.MqttConnection)
pub struct MqttConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.MqttConnection.connection_id)
    pub connection_id: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.MqttConnection.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.MqttConnection.username)
    pub username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:mizer.MqttConnection.password)
    pub password: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.MqttConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MqttConnection {
    fn default() -> &'a MqttConnection {
        <MqttConnection as ::protobuf::Message>::default_instance()
    }
}

impl MqttConnection {
    pub fn new() -> MqttConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connection_id",
            |m: &MqttConnection| { &m.connection_id },
            |m: &mut MqttConnection| { &mut m.connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &MqttConnection| { &m.url },
            |m: &mut MqttConnection| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "username",
            |m: &MqttConnection| { &m.username },
            |m: &mut MqttConnection| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "password",
            |m: &MqttConnection| { &m.password },
            |m: &mut MqttConnection| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MqttConnection>(
            "MqttConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MqttConnection {
    const NAME: &'static str = "MqttConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection_id = is.read_string()?;
                },
                18 => {
                    self.url = is.read_string()?;
                },
                26 => {
                    self.username = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.password = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.connection_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.connection_id);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        if let Some(v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.connection_id.is_empty() {
            os.write_string(1, &self.connection_id)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        if let Some(v) = self.username.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.password.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MqttConnection {
        MqttConnection::new()
    }

    fn clear(&mut self) {
        self.connection_id.clear();
        self.url.clear();
        self.username = ::std::option::Option::None;
        self.password = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MqttConnection {
        static instance: MqttConnection = MqttConnection {
            connection_id: ::std::string::String::new(),
            url: ::std::string::String::new(),
            username: ::std::option::Option::None,
            password: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MqttConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MqttConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MqttConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MqttConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.ConfigureConnectionRequest)
pub struct ConfigureConnectionRequest {
    // message oneof groups
    pub config: ::std::option::Option<configure_connection_request::Config>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.ConfigureConnectionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigureConnectionRequest {
    fn default() -> &'a ConfigureConnectionRequest {
        <ConfigureConnectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConfigureConnectionRequest {
    pub fn new() -> ConfigureConnectionRequest {
        ::std::default::Default::default()
    }

    // .mizer.DmxConnection dmx = 1;

    pub fn dmx(&self) -> &DmxConnection {
        match self.config {
            ::std::option::Option::Some(configure_connection_request::Config::Dmx(ref v)) => v,
            _ => <DmxConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dmx(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_dmx(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(configure_connection_request::Config::Dmx(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dmx(&mut self, v: DmxConnection) {
        self.config = ::std::option::Option::Some(configure_connection_request::Config::Dmx(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dmx(&mut self) -> &mut DmxConnection {
        if let ::std::option::Option::Some(configure_connection_request::Config::Dmx(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(configure_connection_request::Config::Dmx(DmxConnection::new()));
        }
        match self.config {
            ::std::option::Option::Some(configure_connection_request::Config::Dmx(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dmx(&mut self) -> DmxConnection {
        if self.has_dmx() {
            match self.config.take() {
                ::std::option::Option::Some(configure_connection_request::Config::Dmx(v)) => v,
                _ => panic!(),
            }
        } else {
            DmxConnection::new()
        }
    }

    // .mizer.MqttConnection mqtt = 2;

    pub fn mqtt(&self) -> &MqttConnection {
        match self.config {
            ::std::option::Option::Some(configure_connection_request::Config::Mqtt(ref v)) => v,
            _ => <MqttConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mqtt(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_mqtt(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(configure_connection_request::Config::Mqtt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mqtt(&mut self, v: MqttConnection) {
        self.config = ::std::option::Option::Some(configure_connection_request::Config::Mqtt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mqtt(&mut self) -> &mut MqttConnection {
        if let ::std::option::Option::Some(configure_connection_request::Config::Mqtt(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(configure_connection_request::Config::Mqtt(MqttConnection::new()));
        }
        match self.config {
            ::std::option::Option::Some(configure_connection_request::Config::Mqtt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mqtt(&mut self) -> MqttConnection {
        if self.has_mqtt() {
            match self.config.take() {
                ::std::option::Option::Some(configure_connection_request::Config::Mqtt(v)) => v,
                _ => panic!(),
            }
        } else {
            MqttConnection::new()
        }
    }

    // .mizer.OscConnection osc = 3;

    pub fn osc(&self) -> &OscConnection {
        match self.config {
            ::std::option::Option::Some(configure_connection_request::Config::Osc(ref v)) => v,
            _ => <OscConnection as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_osc(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_osc(&self) -> bool {
        match self.config {
            ::std::option::Option::Some(configure_connection_request::Config::Osc(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_osc(&mut self, v: OscConnection) {
        self.config = ::std::option::Option::Some(configure_connection_request::Config::Osc(v))
    }

    // Mutable pointer to the field.
    pub fn mut_osc(&mut self) -> &mut OscConnection {
        if let ::std::option::Option::Some(configure_connection_request::Config::Osc(_)) = self.config {
        } else {
            self.config = ::std::option::Option::Some(configure_connection_request::Config::Osc(OscConnection::new()));
        }
        match self.config {
            ::std::option::Option::Some(configure_connection_request::Config::Osc(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_osc(&mut self) -> OscConnection {
        if self.has_osc() {
            match self.config.take() {
                ::std::option::Option::Some(configure_connection_request::Config::Osc(v)) => v,
                _ => panic!(),
            }
        } else {
            OscConnection::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DmxConnection>(
            "dmx",
            ConfigureConnectionRequest::has_dmx,
            ConfigureConnectionRequest::dmx,
            ConfigureConnectionRequest::mut_dmx,
            ConfigureConnectionRequest::set_dmx,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MqttConnection>(
            "mqtt",
            ConfigureConnectionRequest::has_mqtt,
            ConfigureConnectionRequest::mqtt,
            ConfigureConnectionRequest::mut_mqtt,
            ConfigureConnectionRequest::set_mqtt,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OscConnection>(
            "osc",
            ConfigureConnectionRequest::has_osc,
            ConfigureConnectionRequest::osc,
            ConfigureConnectionRequest::mut_osc,
            ConfigureConnectionRequest::set_osc,
        ));
        oneofs.push(configure_connection_request::Config::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigureConnectionRequest>(
            "ConfigureConnectionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigureConnectionRequest {
    const NAME: &'static str = "ConfigureConnectionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.config = ::std::option::Option::Some(configure_connection_request::Config::Dmx(is.read_message()?));
                },
                18 => {
                    self.config = ::std::option::Option::Some(configure_connection_request::Config::Mqtt(is.read_message()?));
                },
                26 => {
                    self.config = ::std::option::Option::Some(configure_connection_request::Config::Osc(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &configure_connection_request::Config::Dmx(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &configure_connection_request::Config::Mqtt(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &configure_connection_request::Config::Osc(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.config {
            match v {
                &configure_connection_request::Config::Dmx(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &configure_connection_request::Config::Mqtt(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &configure_connection_request::Config::Osc(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigureConnectionRequest {
        ConfigureConnectionRequest::new()
    }

    fn clear(&mut self) {
        self.config = ::std::option::Option::None;
        self.config = ::std::option::Option::None;
        self.config = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigureConnectionRequest {
        static instance: ConfigureConnectionRequest = ConfigureConnectionRequest {
            config: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigureConnectionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigureConnectionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigureConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigureConnectionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ConfigureConnectionRequest`
pub mod configure_connection_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.ConfigureConnectionRequest.config)
    pub enum Config {
        // @@protoc_insertion_point(oneof_field:mizer.ConfigureConnectionRequest.dmx)
        Dmx(super::DmxConnection),
        // @@protoc_insertion_point(oneof_field:mizer.ConfigureConnectionRequest.mqtt)
        Mqtt(super::MqttConnection),
        // @@protoc_insertion_point(oneof_field:mizer.ConfigureConnectionRequest.osc)
        Osc(super::OscConnection),
    }

    impl ::protobuf::Oneof for Config {
    }

    impl ::protobuf::OneofFull for Config {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ConfigureConnectionRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("config").unwrap()).clone()
        }
    }

    impl Config {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Config>("config")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11connections.proto\x12\x05mizer\"0\n\x11MonitorDmxRequest\x12\x1b\n\
    \toutput_id\x18\x01\x20\x01(\tR\x08outputId\"M\n\x12MonitorDmxResponse\
    \x127\n\tuniverses\x18\x01\x20\x03(\x0b2\x19.mizer.MonitorDmxUniverseR\t\
    universes\"L\n\x12MonitorDmxUniverse\x12\x1a\n\x08universe\x18\x01\x20\
    \x01(\rR\x08universe\x12\x1a\n\x08channels\x18\x02\x20\x01(\x0cR\x08chan\
    nels\"(\n\x12MonitorMidiRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\"\xc0\x04\n\x13MonitorMidiResponse\x12\x1c\n\ttimestamp\x18\x02\
    \x20\x01(\x04R\ttimestamp\x124\n\x02cc\x18\x03\x20\x01(\x0b2\".mizer.Mon\
    itorMidiResponse.NoteMsgH\0R\x02cc\x12?\n\x08note_off\x18\x04\x20\x01(\
    \x0b2\".mizer.MonitorMidiResponse.NoteMsgH\0R\x07noteOff\x12=\n\x07note_\
    on\x18\x05\x20\x01(\x0b2\".mizer.MonitorMidiResponse.NoteMsgH\0R\x06note\
    On\x129\n\x06sys_ex\x18\x06\x20\x01(\x0b2\x20.mizer.MonitorMidiResponse.\
    SysExH\0R\x05sysEx\x12\x1a\n\x07unknown\x18\x07\x20\x01(\x0cH\0R\x07unkn\
    own\x1aM\n\x07NoteMsg\x12\x18\n\x07channel\x18\x01\x20\x01(\rR\x07channe\
    l\x12\x12\n\x04note\x18\x02\x20\x01(\rR\x04note\x12\x14\n\x05value\x18\
    \x03\x20\x01(\rR\x05value\x1a\xa3\x01\n\x05SysEx\x12$\n\rmanufacturer1\
    \x18\x01\x20\x01(\rR\rmanufacturer1\x12$\n\rmanufacturer2\x18\x02\x20\
    \x01(\rR\rmanufacturer2\x12$\n\rmanufacturer3\x18\x03\x20\x01(\rR\rmanuf\
    acturer3\x12\x14\n\x05model\x18\x04\x20\x01(\rR\x05model\x12\x12\n\x04da\
    ta\x18\x05\x20\x01(\x0cR\x04dataB\t\n\x07message\"'\n\x11MonitorOscReque\
    st\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\xb5\x03\n\x12MonitorO\
    scResponse\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimestamp\x12\x12\
    \n\x04path\x18\x02\x20\x01(\tR\x04path\x129\n\x04args\x18\x03\x20\x03(\
    \x0b2%.mizer.MonitorOscResponse.OscArgumentR\x04args\x1a\xb1\x02\n\x0bOs\
    cArgument\x12\x12\n\x03int\x18\x01\x20\x01(\x05H\0R\x03int\x12\x16\n\x05\
    float\x18\x02\x20\x01(\x02H\0R\x05float\x12\x14\n\x04long\x18\x03\x20\
    \x01(\x03H\0R\x04long\x12\x18\n\x06double\x18\x04\x20\x01(\x01H\0R\x06do\
    uble\x12\x14\n\x04bool\x18\x05\x20\x01(\x08H\0R\x04bool\x12F\n\x05color\
    \x18\x06\x20\x01(\x0b2..mizer.MonitorOscResponse.OscArgument.OscColorH\0\
    R\x05color\x1a\\\n\x08OscColor\x12\x10\n\x03red\x18\x01\x20\x01(\rR\x03r\
    ed\x12\x14\n\x05green\x18\x02\x20\x01(\rR\x05green\x12\x12\n\x04blue\x18\
    \x03\x20\x01(\rR\x04blue\x12\x14\n\x05alpha\x18\x04\x20\x01(\rR\x05alpha\
    B\n\n\x08argument\"\x17\n\x15GetConnectionsRequest\"\x1a\n\x18GetDeviceP\
    rofilesRequest\"J\n\x0cArtnetConfig\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12\x12\n\x04host\x18\x02\x20\x01(\tR\x04host\x12\x12\n\x04por\
    t\x18\x03\x20\x01(\rR\x04port\"\x20\n\nSacnConfig\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\"B\n\x0bConnections\x123\n\x0bconnections\x18\
    \x01\x20\x03(\x0b2\x11.mizer.ConnectionR\x0bconnections\"\xed\x03\n\nCon\
    nection\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12(\n\x03dmx\x18\
    \n\x20\x01(\x0b2\x14.mizer.DmxConnectionH\0R\x03dmx\x12+\n\x04midi\x18\
    \x0b\x20\x01(\x0b2\x15.mizer.MidiConnectionH\0R\x04midi\x12(\n\x03osc\
    \x18\x0c\x20\x01(\x0b2\x14.mizer.OscConnectionH\0R\x03osc\x12<\n\x0bpro_\
    dj_link\x18\r\x20\x01(\x0b2\x1a.mizer.ProDjLinkConnectionH\0R\tproDjLink\
    \x121\n\x06helios\x18\x0e\x20\x01(\x0b2\x17.mizer.HeliosConnectionH\0R\
    \x06helios\x12>\n\x0bether_dream\x18\x0f\x20\x01(\x0b2\x1b.mizer.EtherDr\
    eamConnectionH\0R\netherDream\x124\n\x07gamepad\x18\x10\x20\x01(\x0b2\
    \x18.mizer.GamepadConnectionH\0R\x07gamepad\x12+\n\x04mqtt\x18\x11\x20\
    \x01(\x0b2\x15.mizer.MqttConnectionH\0R\x04mqtt\x12(\n\x03g13\x18\x12\
    \x20\x01(\x0b2\x14.mizer.G13ConnectionH\0R\x03g13B\x0c\n\nconnection\"\
    \x8e\x01\n\rDmxConnection\x12\x1b\n\toutput_id\x18\x01\x20\x01(\tR\x08ou\
    tputId\x12-\n\x06artnet\x18\x03\x20\x01(\x0b2\x13.mizer.ArtnetConfigH\0R\
    \x06artnet\x12'\n\x04sacn\x18\x04\x20\x01(\x0b2\x11.mizer.SacnConfigH\0R\
    \x04sacnB\x08\n\x06config\"B\n\x10HeliosConnection\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x1a\n\x08firmware\x18\x02\x20\x01(\rR\x08fi\
    rmware\"*\n\x14EtherDreamConnection\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\"7\n\x11GamepadConnection\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"\x1f\n\rG13Connect\
    ion\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"O\n\x0eMidiConnection\x12\
    *\n\x0edevice_profile\x18\x01\x20\x01(\tH\0R\rdeviceProfile\x88\x01\x01B\
    \x11\n\x0f_device_profile\"J\n\x12MidiDeviceProfiles\x124\n\x08profiles\
    \x18\x01\x20\x03(\x0b2\x18.mizer.MidiDeviceProfileR\x08profiles\"\x8f\
    \x05\n\x11MidiDeviceProfile\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\"\n\x0cmanufacturer\x18\x02\x20\x01(\tR\x0cmanufacturer\x12\x14\n\
    \x05model\x18\x03\x20\x01(\tR\x05model\x12\x1b\n\x06layout\x18\x04\x20\
    \x01(\tH\0R\x06layout\x88\x01\x01\x123\n\x05pages\x18\x05\x20\x03(\x0b2\
    \x1d.mizer.MidiDeviceProfile.PageR\x05pages\x1a\x90\x01\n\x04Page\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x126\n\x06groups\x18\x02\x20\
    \x03(\x0b2\x1e.mizer.MidiDeviceProfile.GroupR\x06groups\x12<\n\x08contro\
    ls\x18\x03\x20\x03(\x0b2\x20.mizer.MidiDeviceProfile.ControlR\x08control\
    s\x1aY\n\x05Group\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12<\n\
    \x08controls\x18\x02\x20\x03(\x0b2\x20.mizer.MidiDeviceProfile.ControlR\
    \x08controls\x1a\xc3\x01\n\x07Control\x12\x0e\n\x02id\x18\x01\x20\x01(\t\
    R\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x18\n\x07chann\
    el\x18\x03\x20\x01(\rR\x07channel\x12\x12\n\x04note\x18\x04\x20\x01(\rR\
    \x04note\x12G\n\x0ccontrol_type\x18\x05\x20\x01(\x0e2$.mizer.MidiDeviceP\
    rofile.ControlTypeR\x0bcontrolType\x12\x1d\n\nhas_output\x18\x06\x20\x01\
    (\x08R\thasOutput\"\x1f\n\x0bControlType\x12\x08\n\x04NOTE\x10\0\x12\x06\
    \n\x02CC\x10\x01B\t\n\x07_layout\"\x9b\x01\n\rOscConnection\x12#\n\rconn\
    ection_id\x18\x01\x20\x01(\tR\x0cconnectionId\x12\x1d\n\ninput_port\x18\
    \x02\x20\x01(\rR\tinputPort\x12\x1f\n\x0boutput_port\x18\x03\x20\x01(\rR\
    \noutputPort\x12%\n\x0eoutput_address\x18\x04\x20\x01(\tR\routputAddress\
    \"\x9a\x01\n\x13ProDjLinkConnection\x12\x18\n\x07address\x18\x01\x20\x01\
    (\tR\x07address\x12\x14\n\x05model\x18\x02\x20\x01(\tR\x05model\x12#\n\r\
    player_number\x18\x03\x20\x01(\rR\x0cplayerNumber\x12.\n\x08playback\x18\
    \x05\x20\x01(\x0b2\x12.mizer.CdjPlaybackR\x08playback\"\x9f\x02\n\x0bCdj\
    Playback\x12\x12\n\x04live\x18\x01\x20\x01(\x08R\x04live\x12\x10\n\x03bp\
    m\x18\x02\x20\x01(\x01R\x03bpm\x12\x14\n\x05frame\x18\x03\x20\x01(\rR\
    \x05frame\x124\n\x08playback\x18\x04\x20\x01(\x0e2\x18.mizer.CdjPlayback\
    .StateR\x08playback\x12.\n\x05track\x18\x05\x20\x01(\x0b2\x18.mizer.CdjP\
    layback.TrackR\x05track\x1a5\n\x05Track\x12\x16\n\x06artist\x18\x01\x20\
    \x01(\tR\x06artist\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\"7\n\
    \x05State\x12\x0b\n\x07LOADING\x10\0\x12\x0b\n\x07PLAYING\x10\x01\x12\
    \x08\n\x04CUED\x10\x02\x12\n\n\x06CUEING\x10\x03\"\xa3\x01\n\x0eMqttConn\
    ection\x12#\n\rconnection_id\x18\x01\x20\x01(\tR\x0cconnectionId\x12\x10\
    \n\x03url\x18\x02\x20\x01(\tR\x03url\x12\x1f\n\x08username\x18\x03\x20\
    \x01(\tH\0R\x08username\x88\x01\x01\x12\x1f\n\x08password\x18\x04\x20\
    \x01(\tH\x01R\x08password\x88\x01\x01B\x0b\n\t_usernameB\x0b\n\t_passwor\
    d\"\xa7\x01\n\x1aConfigureConnectionRequest\x12(\n\x03dmx\x18\x01\x20\
    \x01(\x0b2\x14.mizer.DmxConnectionH\0R\x03dmx\x12+\n\x04mqtt\x18\x02\x20\
    \x01(\x0b2\x15.mizer.MqttConnectionH\0R\x04mqtt\x12(\n\x03osc\x18\x03\
    \x20\x01(\x0b2\x14.mizer.OscConnectionH\0R\x03oscB\x08\n\x06config2\xf9\
    \x04\n\x0eConnectionsApi\x12B\n\x0eGetConnections\x12\x1c.mizer.GetConne\
    ctionsRequest\x1a\x12.mizer.Connections\x12A\n\nMonitorDmx\x12\x18.mizer\
    .MonitorDmxRequest\x1a\x19.mizer.MonitorDmxResponse\x12D\n\x0bMonitorMid\
    i\x12\x19.mizer.MonitorMidiRequest\x1a\x1a.mizer.MonitorMidiResponse\x12\
    A\n\nMonitorOsc\x12\x18.mizer.MonitorOscRequest\x1a\x19.mizer.MonitorOsc\
    Response\x12>\n\x13AddArtnetConnection\x12\x13.mizer.ArtnetConfig\x1a\
    \x12.mizer.Connections\x12:\n\x11AddSacnConnection\x12\x11.mizer.SacnCon\
    fig\x1a\x12.mizer.Connections\x12S\n\x15GetMidiDeviceProfiles\x12\x1f.mi\
    zer.GetDeviceProfilesRequest\x1a\x19.mizer.MidiDeviceProfiles\x129\n\x10\
    DeleteConnection\x12\x11.mizer.Connection\x1a\x12.mizer.Connections\x12K\
    \n\x13ConfigureConnection\x12!.mizer.ConfigureConnectionRequest\x1a\x11.\
    mizer.Connectionb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(34);
            messages.push(MonitorDmxRequest::generated_message_descriptor_data());
            messages.push(MonitorDmxResponse::generated_message_descriptor_data());
            messages.push(MonitorDmxUniverse::generated_message_descriptor_data());
            messages.push(MonitorMidiRequest::generated_message_descriptor_data());
            messages.push(MonitorMidiResponse::generated_message_descriptor_data());
            messages.push(MonitorOscRequest::generated_message_descriptor_data());
            messages.push(MonitorOscResponse::generated_message_descriptor_data());
            messages.push(GetConnectionsRequest::generated_message_descriptor_data());
            messages.push(GetDeviceProfilesRequest::generated_message_descriptor_data());
            messages.push(ArtnetConfig::generated_message_descriptor_data());
            messages.push(SacnConfig::generated_message_descriptor_data());
            messages.push(Connections::generated_message_descriptor_data());
            messages.push(Connection::generated_message_descriptor_data());
            messages.push(DmxConnection::generated_message_descriptor_data());
            messages.push(HeliosConnection::generated_message_descriptor_data());
            messages.push(EtherDreamConnection::generated_message_descriptor_data());
            messages.push(GamepadConnection::generated_message_descriptor_data());
            messages.push(G13Connection::generated_message_descriptor_data());
            messages.push(MidiConnection::generated_message_descriptor_data());
            messages.push(MidiDeviceProfiles::generated_message_descriptor_data());
            messages.push(MidiDeviceProfile::generated_message_descriptor_data());
            messages.push(OscConnection::generated_message_descriptor_data());
            messages.push(ProDjLinkConnection::generated_message_descriptor_data());
            messages.push(CdjPlayback::generated_message_descriptor_data());
            messages.push(MqttConnection::generated_message_descriptor_data());
            messages.push(ConfigureConnectionRequest::generated_message_descriptor_data());
            messages.push(monitor_midi_response::NoteMsg::generated_message_descriptor_data());
            messages.push(monitor_midi_response::SysEx::generated_message_descriptor_data());
            messages.push(monitor_osc_response::OscArgument::generated_message_descriptor_data());
            messages.push(monitor_osc_response::osc_argument::OscColor::generated_message_descriptor_data());
            messages.push(midi_device_profile::Page::generated_message_descriptor_data());
            messages.push(midi_device_profile::Group::generated_message_descriptor_data());
            messages.push(midi_device_profile::Control::generated_message_descriptor_data());
            messages.push(cdj_playback::Track::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(midi_device_profile::ControlType::generated_enum_descriptor_data());
            enums.push(cdj_playback::State::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
