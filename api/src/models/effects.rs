// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `effects.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.GetEffectsRequest)
pub struct GetEffectsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.GetEffectsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetEffectsRequest {
    fn default() -> &'a GetEffectsRequest {
        <GetEffectsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEffectsRequest {
    pub fn new() -> GetEffectsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetEffectsRequest>(
            "GetEffectsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetEffectsRequest {
    const NAME: &'static str = "GetEffectsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetEffectsRequest {
        GetEffectsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetEffectsRequest {
        static instance: GetEffectsRequest = GetEffectsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetEffectsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetEffectsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetEffectsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEffectsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.AddEffectRequest)
pub struct AddEffectRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.AddEffectRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.AddEffectRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddEffectRequest {
    fn default() -> &'a AddEffectRequest {
        <AddEffectRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddEffectRequest {
    pub fn new() -> AddEffectRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AddEffectRequest| { &m.name },
            |m: &mut AddEffectRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddEffectRequest>(
            "AddEffectRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddEffectRequest {
    const NAME: &'static str = "AddEffectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddEffectRequest {
        AddEffectRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddEffectRequest {
        static instance: AddEffectRequest = AddEffectRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddEffectRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddEffectRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddEffectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddEffectRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.UpdateEffectStepRequest)
pub struct UpdateEffectStepRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.UpdateEffectStepRequest.effect_id)
    pub effect_id: u32,
    // @@protoc_insertion_point(field:mizer.effects.UpdateEffectStepRequest.channel_index)
    pub channel_index: u32,
    // @@protoc_insertion_point(field:mizer.effects.UpdateEffectStepRequest.step_index)
    pub step_index: u32,
    // @@protoc_insertion_point(field:mizer.effects.UpdateEffectStepRequest.step)
    pub step: ::protobuf::MessageField<EffectStep>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.UpdateEffectStepRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateEffectStepRequest {
    fn default() -> &'a UpdateEffectStepRequest {
        <UpdateEffectStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEffectStepRequest {
    pub fn new() -> UpdateEffectStepRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_id",
            |m: &UpdateEffectStepRequest| { &m.effect_id },
            |m: &mut UpdateEffectStepRequest| { &mut m.effect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_index",
            |m: &UpdateEffectStepRequest| { &m.channel_index },
            |m: &mut UpdateEffectStepRequest| { &mut m.channel_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "step_index",
            |m: &UpdateEffectStepRequest| { &m.step_index },
            |m: &mut UpdateEffectStepRequest| { &mut m.step_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EffectStep>(
            "step",
            |m: &UpdateEffectStepRequest| { &m.step },
            |m: &mut UpdateEffectStepRequest| { &mut m.step },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateEffectStepRequest>(
            "UpdateEffectStepRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateEffectStepRequest {
    const NAME: &'static str = "UpdateEffectStepRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.effect_id = is.read_uint32()?;
                },
                16 => {
                    self.channel_index = is.read_uint32()?;
                },
                24 => {
                    self.step_index = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.step)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.effect_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.effect_id);
        }
        if self.channel_index != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.channel_index);
        }
        if self.step_index != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.step_index);
        }
        if let Some(v) = self.step.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.effect_id != 0 {
            os.write_uint32(1, self.effect_id)?;
        }
        if self.channel_index != 0 {
            os.write_uint32(2, self.channel_index)?;
        }
        if self.step_index != 0 {
            os.write_uint32(3, self.step_index)?;
        }
        if let Some(v) = self.step.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateEffectStepRequest {
        UpdateEffectStepRequest::new()
    }

    fn clear(&mut self) {
        self.effect_id = 0;
        self.channel_index = 0;
        self.step_index = 0;
        self.step.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateEffectStepRequest {
        static instance: UpdateEffectStepRequest = UpdateEffectStepRequest {
            effect_id: 0,
            channel_index: 0,
            step_index: 0,
            step: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateEffectStepRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateEffectStepRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateEffectStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEffectStepRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.AddEffectChannelRequest)
pub struct AddEffectChannelRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.AddEffectChannelRequest.effect_id)
    pub effect_id: u32,
    // @@protoc_insertion_point(field:mizer.effects.AddEffectChannelRequest.control)
    pub control: ::protobuf::MessageField<super::fixtures::FixtureFaderControl>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.AddEffectChannelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddEffectChannelRequest {
    fn default() -> &'a AddEffectChannelRequest {
        <AddEffectChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddEffectChannelRequest {
    pub fn new() -> AddEffectChannelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_id",
            |m: &AddEffectChannelRequest| { &m.effect_id },
            |m: &mut AddEffectChannelRequest| { &mut m.effect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::fixtures::FixtureFaderControl>(
            "control",
            |m: &AddEffectChannelRequest| { &m.control },
            |m: &mut AddEffectChannelRequest| { &mut m.control },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddEffectChannelRequest>(
            "AddEffectChannelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddEffectChannelRequest {
    const NAME: &'static str = "AddEffectChannelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.effect_id = is.read_uint32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.control)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.effect_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.effect_id);
        }
        if let Some(v) = self.control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.effect_id != 0 {
            os.write_uint32(1, self.effect_id)?;
        }
        if let Some(v) = self.control.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddEffectChannelRequest {
        AddEffectChannelRequest::new()
    }

    fn clear(&mut self) {
        self.effect_id = 0;
        self.control.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddEffectChannelRequest {
        static instance: AddEffectChannelRequest = AddEffectChannelRequest {
            effect_id: 0,
            control: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddEffectChannelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddEffectChannelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddEffectChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddEffectChannelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.DeleteEffectChannelRequest)
pub struct DeleteEffectChannelRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.DeleteEffectChannelRequest.effect_id)
    pub effect_id: u32,
    // @@protoc_insertion_point(field:mizer.effects.DeleteEffectChannelRequest.channel_index)
    pub channel_index: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.DeleteEffectChannelRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteEffectChannelRequest {
    fn default() -> &'a DeleteEffectChannelRequest {
        <DeleteEffectChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteEffectChannelRequest {
    pub fn new() -> DeleteEffectChannelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_id",
            |m: &DeleteEffectChannelRequest| { &m.effect_id },
            |m: &mut DeleteEffectChannelRequest| { &mut m.effect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_index",
            |m: &DeleteEffectChannelRequest| { &m.channel_index },
            |m: &mut DeleteEffectChannelRequest| { &mut m.channel_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteEffectChannelRequest>(
            "DeleteEffectChannelRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteEffectChannelRequest {
    const NAME: &'static str = "DeleteEffectChannelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.effect_id = is.read_uint32()?;
                },
                16 => {
                    self.channel_index = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.effect_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.effect_id);
        }
        if self.channel_index != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.channel_index);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.effect_id != 0 {
            os.write_uint32(1, self.effect_id)?;
        }
        if self.channel_index != 0 {
            os.write_uint32(2, self.channel_index)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteEffectChannelRequest {
        DeleteEffectChannelRequest::new()
    }

    fn clear(&mut self) {
        self.effect_id = 0;
        self.channel_index = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteEffectChannelRequest {
        static instance: DeleteEffectChannelRequest = DeleteEffectChannelRequest {
            effect_id: 0,
            channel_index: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteEffectChannelRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteEffectChannelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteEffectChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteEffectChannelRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.AddEffectStepRequest)
pub struct AddEffectStepRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.AddEffectStepRequest.effect_id)
    pub effect_id: u32,
    // @@protoc_insertion_point(field:mizer.effects.AddEffectStepRequest.channel_index)
    pub channel_index: u32,
    // @@protoc_insertion_point(field:mizer.effects.AddEffectStepRequest.step)
    pub step: ::protobuf::MessageField<EffectStep>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.AddEffectStepRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddEffectStepRequest {
    fn default() -> &'a AddEffectStepRequest {
        <AddEffectStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddEffectStepRequest {
    pub fn new() -> AddEffectStepRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_id",
            |m: &AddEffectStepRequest| { &m.effect_id },
            |m: &mut AddEffectStepRequest| { &mut m.effect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_index",
            |m: &AddEffectStepRequest| { &m.channel_index },
            |m: &mut AddEffectStepRequest| { &mut m.channel_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EffectStep>(
            "step",
            |m: &AddEffectStepRequest| { &m.step },
            |m: &mut AddEffectStepRequest| { &mut m.step },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddEffectStepRequest>(
            "AddEffectStepRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddEffectStepRequest {
    const NAME: &'static str = "AddEffectStepRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.effect_id = is.read_uint32()?;
                },
                16 => {
                    self.channel_index = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.step)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.effect_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.effect_id);
        }
        if self.channel_index != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.channel_index);
        }
        if let Some(v) = self.step.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.effect_id != 0 {
            os.write_uint32(1, self.effect_id)?;
        }
        if self.channel_index != 0 {
            os.write_uint32(2, self.channel_index)?;
        }
        if let Some(v) = self.step.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddEffectStepRequest {
        AddEffectStepRequest::new()
    }

    fn clear(&mut self) {
        self.effect_id = 0;
        self.channel_index = 0;
        self.step.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddEffectStepRequest {
        static instance: AddEffectStepRequest = AddEffectStepRequest {
            effect_id: 0,
            channel_index: 0,
            step: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddEffectStepRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddEffectStepRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddEffectStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddEffectStepRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.DeleteEffectStepRequest)
pub struct DeleteEffectStepRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.DeleteEffectStepRequest.effect_id)
    pub effect_id: u32,
    // @@protoc_insertion_point(field:mizer.effects.DeleteEffectStepRequest.channel_index)
    pub channel_index: u32,
    // @@protoc_insertion_point(field:mizer.effects.DeleteEffectStepRequest.step_index)
    pub step_index: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.DeleteEffectStepRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteEffectStepRequest {
    fn default() -> &'a DeleteEffectStepRequest {
        <DeleteEffectStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteEffectStepRequest {
    pub fn new() -> DeleteEffectStepRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_id",
            |m: &DeleteEffectStepRequest| { &m.effect_id },
            |m: &mut DeleteEffectStepRequest| { &mut m.effect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_index",
            |m: &DeleteEffectStepRequest| { &m.channel_index },
            |m: &mut DeleteEffectStepRequest| { &mut m.channel_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "step_index",
            |m: &DeleteEffectStepRequest| { &m.step_index },
            |m: &mut DeleteEffectStepRequest| { &mut m.step_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteEffectStepRequest>(
            "DeleteEffectStepRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteEffectStepRequest {
    const NAME: &'static str = "DeleteEffectStepRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.effect_id = is.read_uint32()?;
                },
                16 => {
                    self.channel_index = is.read_uint32()?;
                },
                24 => {
                    self.step_index = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.effect_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.effect_id);
        }
        if self.channel_index != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.channel_index);
        }
        if self.step_index != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.step_index);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.effect_id != 0 {
            os.write_uint32(1, self.effect_id)?;
        }
        if self.channel_index != 0 {
            os.write_uint32(2, self.channel_index)?;
        }
        if self.step_index != 0 {
            os.write_uint32(3, self.step_index)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteEffectStepRequest {
        DeleteEffectStepRequest::new()
    }

    fn clear(&mut self) {
        self.effect_id = 0;
        self.channel_index = 0;
        self.step_index = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteEffectStepRequest {
        static instance: DeleteEffectStepRequest = DeleteEffectStepRequest {
            effect_id: 0,
            channel_index: 0,
            step_index: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteEffectStepRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteEffectStepRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteEffectStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteEffectStepRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.Effects)
pub struct Effects {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.Effects.effects)
    pub effects: ::std::vec::Vec<Effect>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.Effects.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Effects {
    fn default() -> &'a Effects {
        <Effects as ::protobuf::Message>::default_instance()
    }
}

impl Effects {
    pub fn new() -> Effects {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "effects",
            |m: &Effects| { &m.effects },
            |m: &mut Effects| { &mut m.effects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Effects>(
            "Effects",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Effects {
    const NAME: &'static str = "Effects";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.effects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.effects {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Effects {
        Effects::new()
    }

    fn clear(&mut self) {
        self.effects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Effects {
        static instance: Effects = Effects {
            effects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Effects {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Effects").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Effects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Effects {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.Effect)
pub struct Effect {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.Effect.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.effects.Effect.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.effects.Effect.channels)
    pub channels: ::std::vec::Vec<EffectChannel>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.Effect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Effect {
    fn default() -> &'a Effect {
        <Effect as ::protobuf::Message>::default_instance()
    }
}

impl Effect {
    pub fn new() -> Effect {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Effect| { &m.id },
            |m: &mut Effect| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Effect| { &m.name },
            |m: &mut Effect| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels",
            |m: &Effect| { &m.channels },
            |m: &mut Effect| { &mut m.channels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Effect>(
            "Effect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Effect {
    const NAME: &'static str = "Effect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.channels.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Effect {
        Effect::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.channels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Effect {
        static instance: Effect = Effect {
            id: 0,
            name: ::std::string::String::new(),
            channels: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Effect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Effect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Effect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Effect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.EffectChannel)
pub struct EffectChannel {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.EffectChannel.control)
    pub control: ::protobuf::EnumOrUnknown<super::fixtures::FixtureControl>,
    // @@protoc_insertion_point(field:mizer.effects.EffectChannel.steps)
    pub steps: ::std::vec::Vec<EffectStep>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.EffectChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EffectChannel {
    fn default() -> &'a EffectChannel {
        <EffectChannel as ::protobuf::Message>::default_instance()
    }
}

impl EffectChannel {
    pub fn new() -> EffectChannel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "control",
            |m: &EffectChannel| { &m.control },
            |m: &mut EffectChannel| { &mut m.control },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &EffectChannel| { &m.steps },
            |m: &mut EffectChannel| { &mut m.steps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EffectChannel>(
            "EffectChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EffectChannel {
    const NAME: &'static str = "EffectChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.control = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.steps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.control != ::protobuf::EnumOrUnknown::new(super::fixtures::FixtureControl::INTENSITY) {
            my_size += ::protobuf::rt::int32_size(1, self.control.value());
        }
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.control != ::protobuf::EnumOrUnknown::new(super::fixtures::FixtureControl::INTENSITY) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.control))?;
        }
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EffectChannel {
        EffectChannel::new()
    }

    fn clear(&mut self) {
        self.control = ::protobuf::EnumOrUnknown::new(super::fixtures::FixtureControl::INTENSITY);
        self.steps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EffectChannel {
        static instance: EffectChannel = EffectChannel {
            control: ::protobuf::EnumOrUnknown::from_i32(0),
            steps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EffectChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EffectChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EffectChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EffectChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.EffectStep)
pub struct EffectStep {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.EffectStep.value)
    pub value: ::protobuf::MessageField<super::sequencer::CueValue>,
    // message oneof groups
    pub control_point: ::std::option::Option<effect_step::Control_point>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.EffectStep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EffectStep {
    fn default() -> &'a EffectStep {
        <EffectStep as ::protobuf::Message>::default_instance()
    }
}

impl EffectStep {
    pub fn new() -> EffectStep {
        ::std::default::Default::default()
    }

    // .mizer.effects.SimpleControlPoint simple = 2;

    pub fn simple(&self) -> &SimpleControlPoint {
        match self.control_point {
            ::std::option::Option::Some(effect_step::Control_point::Simple(ref v)) => v,
            _ => <SimpleControlPoint as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_simple(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_simple(&self) -> bool {
        match self.control_point {
            ::std::option::Option::Some(effect_step::Control_point::Simple(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_simple(&mut self, v: SimpleControlPoint) {
        self.control_point = ::std::option::Option::Some(effect_step::Control_point::Simple(v))
    }

    // Mutable pointer to the field.
    pub fn mut_simple(&mut self) -> &mut SimpleControlPoint {
        if let ::std::option::Option::Some(effect_step::Control_point::Simple(_)) = self.control_point {
        } else {
            self.control_point = ::std::option::Option::Some(effect_step::Control_point::Simple(SimpleControlPoint::new()));
        }
        match self.control_point {
            ::std::option::Option::Some(effect_step::Control_point::Simple(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_simple(&mut self) -> SimpleControlPoint {
        if self.has_simple() {
            match self.control_point.take() {
                ::std::option::Option::Some(effect_step::Control_point::Simple(v)) => v,
                _ => panic!(),
            }
        } else {
            SimpleControlPoint::new()
        }
    }

    // .mizer.effects.QuadraticControlPoint quadratic = 3;

    pub fn quadratic(&self) -> &QuadraticControlPoint {
        match self.control_point {
            ::std::option::Option::Some(effect_step::Control_point::Quadratic(ref v)) => v,
            _ => <QuadraticControlPoint as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quadratic(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_quadratic(&self) -> bool {
        match self.control_point {
            ::std::option::Option::Some(effect_step::Control_point::Quadratic(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quadratic(&mut self, v: QuadraticControlPoint) {
        self.control_point = ::std::option::Option::Some(effect_step::Control_point::Quadratic(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quadratic(&mut self) -> &mut QuadraticControlPoint {
        if let ::std::option::Option::Some(effect_step::Control_point::Quadratic(_)) = self.control_point {
        } else {
            self.control_point = ::std::option::Option::Some(effect_step::Control_point::Quadratic(QuadraticControlPoint::new()));
        }
        match self.control_point {
            ::std::option::Option::Some(effect_step::Control_point::Quadratic(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quadratic(&mut self) -> QuadraticControlPoint {
        if self.has_quadratic() {
            match self.control_point.take() {
                ::std::option::Option::Some(effect_step::Control_point::Quadratic(v)) => v,
                _ => panic!(),
            }
        } else {
            QuadraticControlPoint::new()
        }
    }

    // .mizer.effects.CubicControlPoint cubic = 4;

    pub fn cubic(&self) -> &CubicControlPoint {
        match self.control_point {
            ::std::option::Option::Some(effect_step::Control_point::Cubic(ref v)) => v,
            _ => <CubicControlPoint as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cubic(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_cubic(&self) -> bool {
        match self.control_point {
            ::std::option::Option::Some(effect_step::Control_point::Cubic(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cubic(&mut self, v: CubicControlPoint) {
        self.control_point = ::std::option::Option::Some(effect_step::Control_point::Cubic(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cubic(&mut self) -> &mut CubicControlPoint {
        if let ::std::option::Option::Some(effect_step::Control_point::Cubic(_)) = self.control_point {
        } else {
            self.control_point = ::std::option::Option::Some(effect_step::Control_point::Cubic(CubicControlPoint::new()));
        }
        match self.control_point {
            ::std::option::Option::Some(effect_step::Control_point::Cubic(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cubic(&mut self) -> CubicControlPoint {
        if self.has_cubic() {
            match self.control_point.take() {
                ::std::option::Option::Some(effect_step::Control_point::Cubic(v)) => v,
                _ => panic!(),
            }
        } else {
            CubicControlPoint::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::sequencer::CueValue>(
            "value",
            |m: &EffectStep| { &m.value },
            |m: &mut EffectStep| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SimpleControlPoint>(
            "simple",
            EffectStep::has_simple,
            EffectStep::simple,
            EffectStep::mut_simple,
            EffectStep::set_simple,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, QuadraticControlPoint>(
            "quadratic",
            EffectStep::has_quadratic,
            EffectStep::quadratic,
            EffectStep::mut_quadratic,
            EffectStep::set_quadratic,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CubicControlPoint>(
            "cubic",
            EffectStep::has_cubic,
            EffectStep::cubic,
            EffectStep::mut_cubic,
            EffectStep::set_cubic,
        ));
        oneofs.push(effect_step::Control_point::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EffectStep>(
            "EffectStep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EffectStep {
    const NAME: &'static str = "EffectStep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                18 => {
                    self.control_point = ::std::option::Option::Some(effect_step::Control_point::Simple(is.read_message()?));
                },
                26 => {
                    self.control_point = ::std::option::Option::Some(effect_step::Control_point::Quadratic(is.read_message()?));
                },
                34 => {
                    self.control_point = ::std::option::Option::Some(effect_step::Control_point::Cubic(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.control_point {
            match v {
                &effect_step::Control_point::Simple(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &effect_step::Control_point::Quadratic(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &effect_step::Control_point::Cubic(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.control_point {
            match v {
                &effect_step::Control_point::Simple(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &effect_step::Control_point::Quadratic(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &effect_step::Control_point::Cubic(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EffectStep {
        EffectStep::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.control_point = ::std::option::Option::None;
        self.control_point = ::std::option::Option::None;
        self.control_point = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EffectStep {
        static instance: EffectStep = EffectStep {
            value: ::protobuf::MessageField::none(),
            control_point: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EffectStep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EffectStep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EffectStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EffectStep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `EffectStep`
pub mod effect_step {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.effects.EffectStep.control_point)
    pub enum Control_point {
        // @@protoc_insertion_point(oneof_field:mizer.effects.EffectStep.simple)
        Simple(super::SimpleControlPoint),
        // @@protoc_insertion_point(oneof_field:mizer.effects.EffectStep.quadratic)
        Quadratic(super::QuadraticControlPoint),
        // @@protoc_insertion_point(oneof_field:mizer.effects.EffectStep.cubic)
        Cubic(super::CubicControlPoint),
    }

    impl ::protobuf::Oneof for Control_point {
    }

    impl ::protobuf::OneofFull for Control_point {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::EffectStep as ::protobuf::MessageFull>::descriptor().oneof_by_name("control_point").unwrap()).clone()
        }
    }

    impl Control_point {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Control_point>("control_point")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.SimpleControlPoint)
pub struct SimpleControlPoint {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.SimpleControlPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SimpleControlPoint {
    fn default() -> &'a SimpleControlPoint {
        <SimpleControlPoint as ::protobuf::Message>::default_instance()
    }
}

impl SimpleControlPoint {
    pub fn new() -> SimpleControlPoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SimpleControlPoint>(
            "SimpleControlPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SimpleControlPoint {
    const NAME: &'static str = "SimpleControlPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SimpleControlPoint {
        SimpleControlPoint::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SimpleControlPoint {
        static instance: SimpleControlPoint = SimpleControlPoint {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SimpleControlPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SimpleControlPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SimpleControlPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SimpleControlPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.QuadraticControlPoint)
pub struct QuadraticControlPoint {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.QuadraticControlPoint.c0a)
    pub c0a: f64,
    // @@protoc_insertion_point(field:mizer.effects.QuadraticControlPoint.c0b)
    pub c0b: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.QuadraticControlPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuadraticControlPoint {
    fn default() -> &'a QuadraticControlPoint {
        <QuadraticControlPoint as ::protobuf::Message>::default_instance()
    }
}

impl QuadraticControlPoint {
    pub fn new() -> QuadraticControlPoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "c0a",
            |m: &QuadraticControlPoint| { &m.c0a },
            |m: &mut QuadraticControlPoint| { &mut m.c0a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "c0b",
            |m: &QuadraticControlPoint| { &m.c0b },
            |m: &mut QuadraticControlPoint| { &mut m.c0b },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuadraticControlPoint>(
            "QuadraticControlPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuadraticControlPoint {
    const NAME: &'static str = "QuadraticControlPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.c0a = is.read_double()?;
                },
                17 => {
                    self.c0b = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.c0a != 0. {
            my_size += 1 + 8;
        }
        if self.c0b != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.c0a != 0. {
            os.write_double(1, self.c0a)?;
        }
        if self.c0b != 0. {
            os.write_double(2, self.c0b)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuadraticControlPoint {
        QuadraticControlPoint::new()
    }

    fn clear(&mut self) {
        self.c0a = 0.;
        self.c0b = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuadraticControlPoint {
        static instance: QuadraticControlPoint = QuadraticControlPoint {
            c0a: 0.,
            c0b: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QuadraticControlPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuadraticControlPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuadraticControlPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuadraticControlPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.effects.CubicControlPoint)
pub struct CubicControlPoint {
    // message fields
    // @@protoc_insertion_point(field:mizer.effects.CubicControlPoint.c0a)
    pub c0a: f64,
    // @@protoc_insertion_point(field:mizer.effects.CubicControlPoint.c0b)
    pub c0b: f64,
    // @@protoc_insertion_point(field:mizer.effects.CubicControlPoint.c1a)
    pub c1a: f64,
    // @@protoc_insertion_point(field:mizer.effects.CubicControlPoint.c1b)
    pub c1b: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.effects.CubicControlPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CubicControlPoint {
    fn default() -> &'a CubicControlPoint {
        <CubicControlPoint as ::protobuf::Message>::default_instance()
    }
}

impl CubicControlPoint {
    pub fn new() -> CubicControlPoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "c0a",
            |m: &CubicControlPoint| { &m.c0a },
            |m: &mut CubicControlPoint| { &mut m.c0a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "c0b",
            |m: &CubicControlPoint| { &m.c0b },
            |m: &mut CubicControlPoint| { &mut m.c0b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "c1a",
            |m: &CubicControlPoint| { &m.c1a },
            |m: &mut CubicControlPoint| { &mut m.c1a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "c1b",
            |m: &CubicControlPoint| { &m.c1b },
            |m: &mut CubicControlPoint| { &mut m.c1b },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CubicControlPoint>(
            "CubicControlPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CubicControlPoint {
    const NAME: &'static str = "CubicControlPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.c0a = is.read_double()?;
                },
                17 => {
                    self.c0b = is.read_double()?;
                },
                25 => {
                    self.c1a = is.read_double()?;
                },
                33 => {
                    self.c1b = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.c0a != 0. {
            my_size += 1 + 8;
        }
        if self.c0b != 0. {
            my_size += 1 + 8;
        }
        if self.c1a != 0. {
            my_size += 1 + 8;
        }
        if self.c1b != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.c0a != 0. {
            os.write_double(1, self.c0a)?;
        }
        if self.c0b != 0. {
            os.write_double(2, self.c0b)?;
        }
        if self.c1a != 0. {
            os.write_double(3, self.c1a)?;
        }
        if self.c1b != 0. {
            os.write_double(4, self.c1b)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CubicControlPoint {
        CubicControlPoint::new()
    }

    fn clear(&mut self) {
        self.c0a = 0.;
        self.c0b = 0.;
        self.c1a = 0.;
        self.c1b = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CubicControlPoint {
        static instance: CubicControlPoint = CubicControlPoint {
            c0a: 0.,
            c0b: 0.,
            c1a: 0.,
            c1b: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CubicControlPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CubicControlPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CubicControlPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CubicControlPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\reffects.proto\x12\rmizer.effects\x1a\x0efixtures.proto\x1a\x0fsequen\
    cer.proto\"\x13\n\x11GetEffectsRequest\"&\n\x10AddEffectRequest\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\"\xa9\x01\n\x17UpdateEffectStepRe\
    quest\x12\x1b\n\teffect_id\x18\x01\x20\x01(\rR\x08effectId\x12#\n\rchann\
    el_index\x18\x02\x20\x01(\rR\x0cchannelIndex\x12\x1d\n\nstep_index\x18\
    \x03\x20\x01(\rR\tstepIndex\x12-\n\x04step\x18\x04\x20\x01(\x0b2\x19.miz\
    er.effects.EffectStepR\x04step\"u\n\x17AddEffectChannelRequest\x12\x1b\n\
    \teffect_id\x18\x01\x20\x01(\rR\x08effectId\x12=\n\x07control\x18\x02\
    \x20\x01(\x0b2#.mizer.fixtures.FixtureFaderControlR\x07control\"^\n\x1aD\
    eleteEffectChannelRequest\x12\x1b\n\teffect_id\x18\x01\x20\x01(\rR\x08ef\
    fectId\x12#\n\rchannel_index\x18\x02\x20\x01(\rR\x0cchannelIndex\"\x87\
    \x01\n\x14AddEffectStepRequest\x12\x1b\n\teffect_id\x18\x01\x20\x01(\rR\
    \x08effectId\x12#\n\rchannel_index\x18\x02\x20\x01(\rR\x0cchannelIndex\
    \x12-\n\x04step\x18\x03\x20\x01(\x0b2\x19.mizer.effects.EffectStepR\x04s\
    tep\"z\n\x17DeleteEffectStepRequest\x12\x1b\n\teffect_id\x18\x01\x20\x01\
    (\rR\x08effectId\x12#\n\rchannel_index\x18\x02\x20\x01(\rR\x0cchannelInd\
    ex\x12\x1d\n\nstep_index\x18\x03\x20\x01(\rR\tstepIndex\":\n\x07Effects\
    \x12/\n\x07effects\x18\x01\x20\x03(\x0b2\x15.mizer.effects.EffectR\x07ef\
    fects\"f\n\x06Effect\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x128\n\x08channels\x18\x03\x20\x03(\
    \x0b2\x1c.mizer.effects.EffectChannelR\x08channels\"z\n\rEffectChannel\
    \x128\n\x07control\x18\x01\x20\x01(\x0e2\x1e.mizer.fixtures.FixtureContr\
    olR\x07control\x12/\n\x05steps\x18\x02\x20\x03(\x0b2\x19.mizer.effects.E\
    ffectStepR\x05steps\"\x8b\x02\n\nEffectStep\x12/\n\x05value\x18\x01\x20\
    \x01(\x0b2\x19.mizer.sequencer.CueValueR\x05value\x12;\n\x06simple\x18\
    \x02\x20\x01(\x0b2!.mizer.effects.SimpleControlPointH\0R\x06simple\x12D\
    \n\tquadratic\x18\x03\x20\x01(\x0b2$.mizer.effects.QuadraticControlPoint\
    H\0R\tquadratic\x128\n\x05cubic\x18\x04\x20\x01(\x0b2\x20.mizer.effects.\
    CubicControlPointH\0R\x05cubicB\x0f\n\rcontrol_point\"\x14\n\x12SimpleCo\
    ntrolPoint\";\n\x15QuadraticControlPoint\x12\x10\n\x03c0a\x18\x01\x20\
    \x01(\x01R\x03c0a\x12\x10\n\x03c0b\x18\x02\x20\x01(\x01R\x03c0b\"[\n\x11\
    CubicControlPoint\x12\x10\n\x03c0a\x18\x01\x20\x01(\x01R\x03c0a\x12\x10\
    \n\x03c0b\x18\x02\x20\x01(\x01R\x03c0b\x12\x10\n\x03c1a\x18\x03\x20\x01(\
    \x01R\x03c1a\x12\x10\n\x03c1b\x18\x04\x20\x01(\x01R\x03c1b2\xb8\x04\n\nE\
    ffectsApi\x12F\n\nGetEffects\x12\x20.mizer.effects.GetEffectsRequest\x1a\
    \x16.mizer.effects.Effects\x12C\n\tAddEffect\x12\x1f.mizer.effects.AddEf\
    fectRequest\x1a\x15.mizer.effects.Effect\x12Q\n\x10AddEffectChannel\x12&\
    .mizer.effects.AddEffectChannelRequest\x1a\x15.mizer.effects.Effect\x12W\
    \n\x13DeleteEffectChannel\x12).mizer.effects.DeleteEffectChannelRequest\
    \x1a\x15.mizer.effects.Effect\x12Q\n\x10UpdateEffectStep\x12&.mizer.effe\
    cts.UpdateEffectStepRequest\x1a\x15.mizer.effects.Effect\x12K\n\rAddEffe\
    ctStep\x12#.mizer.effects.AddEffectStepRequest\x1a\x15.mizer.effects.Eff\
    ect\x12Q\n\x10DeleteEffectStep\x12&.mizer.effects.DeleteEffectStepReques\
    t\x1a\x15.mizer.effects.Effectb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::fixtures::file_descriptor().clone());
            deps.push(super::sequencer::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(14);
            messages.push(GetEffectsRequest::generated_message_descriptor_data());
            messages.push(AddEffectRequest::generated_message_descriptor_data());
            messages.push(UpdateEffectStepRequest::generated_message_descriptor_data());
            messages.push(AddEffectChannelRequest::generated_message_descriptor_data());
            messages.push(DeleteEffectChannelRequest::generated_message_descriptor_data());
            messages.push(AddEffectStepRequest::generated_message_descriptor_data());
            messages.push(DeleteEffectStepRequest::generated_message_descriptor_data());
            messages.push(Effects::generated_message_descriptor_data());
            messages.push(Effect::generated_message_descriptor_data());
            messages.push(EffectChannel::generated_message_descriptor_data());
            messages.push(EffectStep::generated_message_descriptor_data());
            messages.push(SimpleControlPoint::generated_message_descriptor_data());
            messages.push(QuadraticControlPoint::generated_message_descriptor_data());
            messages.push(CubicControlPoint::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
