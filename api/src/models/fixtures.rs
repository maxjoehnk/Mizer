// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `fixtures.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.AddFixturesRequest)
pub struct AddFixturesRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.AddFixturesRequest.request)
    pub request: ::protobuf::MessageField<AddFixtureRequest>,
    // @@protoc_insertion_point(field:mizer.fixtures.AddFixturesRequest.count)
    pub count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.AddFixturesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddFixturesRequest {
    fn default() -> &'a AddFixturesRequest {
        <AddFixturesRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddFixturesRequest {
    pub fn new() -> AddFixturesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AddFixtureRequest>(
            "request",
            |m: &AddFixturesRequest| { &m.request },
            |m: &mut AddFixturesRequest| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &AddFixturesRequest| { &m.count },
            |m: &mut AddFixturesRequest| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddFixturesRequest>(
            "AddFixturesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddFixturesRequest {
    const NAME: &'static str = "AddFixturesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.request)?;
                },
                16 => {
                    self.count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.count != 0 {
            os.write_uint32(2, self.count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddFixturesRequest {
        AddFixturesRequest::new()
    }

    fn clear(&mut self) {
        self.request.clear();
        self.count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddFixturesRequest {
        static instance: AddFixturesRequest = AddFixturesRequest {
            request: ::protobuf::MessageField::none(),
            count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddFixturesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddFixturesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddFixturesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddFixturesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.AddFixtureRequest)
pub struct AddFixtureRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.AddFixtureRequest.definition_id)
    pub definition_id: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.AddFixtureRequest.mode)
    pub mode: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.AddFixtureRequest.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.AddFixtureRequest.channel)
    pub channel: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.AddFixtureRequest.universe)
    pub universe: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.AddFixtureRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.AddFixtureRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddFixtureRequest {
    fn default() -> &'a AddFixtureRequest {
        <AddFixtureRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddFixtureRequest {
    pub fn new() -> AddFixtureRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "definition_id",
            |m: &AddFixtureRequest| { &m.definition_id },
            |m: &mut AddFixtureRequest| { &mut m.definition_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &AddFixtureRequest| { &m.mode },
            |m: &mut AddFixtureRequest| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &AddFixtureRequest| { &m.id },
            |m: &mut AddFixtureRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel",
            |m: &AddFixtureRequest| { &m.channel },
            |m: &mut AddFixtureRequest| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "universe",
            |m: &AddFixtureRequest| { &m.universe },
            |m: &mut AddFixtureRequest| { &mut m.universe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AddFixtureRequest| { &m.name },
            |m: &mut AddFixtureRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddFixtureRequest>(
            "AddFixtureRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddFixtureRequest {
    const NAME: &'static str = "AddFixtureRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.definition_id = is.read_string()?;
                },
                18 => {
                    self.mode = is.read_string()?;
                },
                24 => {
                    self.id = is.read_uint32()?;
                },
                32 => {
                    self.channel = is.read_uint32()?;
                },
                40 => {
                    self.universe = is.read_uint32()?;
                },
                50 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.definition_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.definition_id);
        }
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.mode);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.id);
        }
        if self.channel != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.channel);
        }
        if self.universe != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.universe);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.definition_id.is_empty() {
            os.write_string(1, &self.definition_id)?;
        }
        if !self.mode.is_empty() {
            os.write_string(2, &self.mode)?;
        }
        if self.id != 0 {
            os.write_uint32(3, self.id)?;
        }
        if self.channel != 0 {
            os.write_uint32(4, self.channel)?;
        }
        if self.universe != 0 {
            os.write_uint32(5, self.universe)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddFixtureRequest {
        AddFixtureRequest::new()
    }

    fn clear(&mut self) {
        self.definition_id.clear();
        self.mode.clear();
        self.id = 0;
        self.channel = 0;
        self.universe = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddFixtureRequest {
        static instance: AddFixtureRequest = AddFixtureRequest {
            definition_id: ::std::string::String::new(),
            mode: ::std::string::String::new(),
            id: 0,
            channel: 0,
            universe: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddFixtureRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddFixtureRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddFixtureRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddFixtureRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.GetFixturesRequest)
pub struct GetFixturesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.GetFixturesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFixturesRequest {
    fn default() -> &'a GetFixturesRequest {
        <GetFixturesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFixturesRequest {
    pub fn new() -> GetFixturesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFixturesRequest>(
            "GetFixturesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFixturesRequest {
    const NAME: &'static str = "GetFixturesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFixturesRequest {
        GetFixturesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFixturesRequest {
        static instance: GetFixturesRequest = GetFixturesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFixturesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFixturesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFixturesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFixturesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.DeleteFixturesRequest)
pub struct DeleteFixturesRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.DeleteFixturesRequest.fixture_ids)
    pub fixture_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.DeleteFixturesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteFixturesRequest {
    fn default() -> &'a DeleteFixturesRequest {
        <DeleteFixturesRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteFixturesRequest {
    pub fn new() -> DeleteFixturesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixture_ids",
            |m: &DeleteFixturesRequest| { &m.fixture_ids },
            |m: &mut DeleteFixturesRequest| { &mut m.fixture_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteFixturesRequest>(
            "DeleteFixturesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteFixturesRequest {
    const NAME: &'static str = "DeleteFixturesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.fixture_ids)?;
                },
                8 => {
                    self.fixture_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.fixture_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fixture_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteFixturesRequest {
        DeleteFixturesRequest::new()
    }

    fn clear(&mut self) {
        self.fixture_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteFixturesRequest {
        static instance: DeleteFixturesRequest = DeleteFixturesRequest {
            fixture_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteFixturesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteFixturesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteFixturesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteFixturesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.UpdateFixtureRequest)
pub struct UpdateFixtureRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.UpdateFixtureRequest.fixture_id)
    pub fixture_id: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.UpdateFixtureRequest.invert_pan)
    pub invert_pan: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:mizer.fixtures.UpdateFixtureRequest.invert_tilt)
    pub invert_tilt: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:mizer.fixtures.UpdateFixtureRequest.reverse_pixel_order)
    pub reverse_pixel_order: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:mizer.fixtures.UpdateFixtureRequest.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:mizer.fixtures.UpdateFixtureRequest.address)
    pub address: ::protobuf::MessageField<FixtureAddress>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.UpdateFixtureRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateFixtureRequest {
    fn default() -> &'a UpdateFixtureRequest {
        <UpdateFixtureRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateFixtureRequest {
    pub fn new() -> UpdateFixtureRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fixture_id",
            |m: &UpdateFixtureRequest| { &m.fixture_id },
            |m: &mut UpdateFixtureRequest| { &mut m.fixture_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invert_pan",
            |m: &UpdateFixtureRequest| { &m.invert_pan },
            |m: &mut UpdateFixtureRequest| { &mut m.invert_pan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "invert_tilt",
            |m: &UpdateFixtureRequest| { &m.invert_tilt },
            |m: &mut UpdateFixtureRequest| { &mut m.invert_tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse_pixel_order",
            |m: &UpdateFixtureRequest| { &m.reverse_pixel_order },
            |m: &mut UpdateFixtureRequest| { &mut m.reverse_pixel_order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &UpdateFixtureRequest| { &m.name },
            |m: &mut UpdateFixtureRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FixtureAddress>(
            "address",
            |m: &UpdateFixtureRequest| { &m.address },
            |m: &mut UpdateFixtureRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateFixtureRequest>(
            "UpdateFixtureRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateFixtureRequest {
    const NAME: &'static str = "UpdateFixtureRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fixture_id = is.read_uint32()?;
                },
                16 => {
                    self.invert_pan = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.invert_tilt = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.reverse_pixel_order = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.address)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fixture_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fixture_id);
        }
        if let Some(v) = self.invert_pan {
            my_size += 1 + 1;
        }
        if let Some(v) = self.invert_tilt {
            my_size += 1 + 1;
        }
        if let Some(v) = self.reverse_pixel_order {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fixture_id != 0 {
            os.write_uint32(1, self.fixture_id)?;
        }
        if let Some(v) = self.invert_pan {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.invert_tilt {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.reverse_pixel_order {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateFixtureRequest {
        UpdateFixtureRequest::new()
    }

    fn clear(&mut self) {
        self.fixture_id = 0;
        self.invert_pan = ::std::option::Option::None;
        self.invert_tilt = ::std::option::Option::None;
        self.reverse_pixel_order = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateFixtureRequest {
        static instance: UpdateFixtureRequest = UpdateFixtureRequest {
            fixture_id: 0,
            invert_pan: ::std::option::Option::None,
            invert_tilt: ::std::option::Option::None,
            reverse_pixel_order: ::std::option::Option::None,
            name: ::std::option::Option::None,
            address: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateFixtureRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateFixtureRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateFixtureRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateFixtureRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixtureAddress)
pub struct FixtureAddress {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureAddress.universe)
    pub universe: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureAddress.channel)
    pub channel: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureAddress {
    fn default() -> &'a FixtureAddress {
        <FixtureAddress as ::protobuf::Message>::default_instance()
    }
}

impl FixtureAddress {
    pub fn new() -> FixtureAddress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "universe",
            |m: &FixtureAddress| { &m.universe },
            |m: &mut FixtureAddress| { &mut m.universe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel",
            |m: &FixtureAddress| { &m.channel },
            |m: &mut FixtureAddress| { &mut m.channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureAddress>(
            "FixtureAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureAddress {
    const NAME: &'static str = "FixtureAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.universe = is.read_uint32()?;
                },
                16 => {
                    self.channel = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.universe != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.universe);
        }
        if self.channel != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.channel);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.universe != 0 {
            os.write_uint32(1, self.universe)?;
        }
        if self.channel != 0 {
            os.write_uint32(2, self.channel)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureAddress {
        FixtureAddress::new()
    }

    fn clear(&mut self) {
        self.universe = 0;
        self.channel = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureAddress {
        static instance: FixtureAddress = FixtureAddress {
            universe: 0,
            channel: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixtureId)
pub struct FixtureId {
    // message oneof groups
    pub id: ::std::option::Option<fixture_id::Id>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureId {
    fn default() -> &'a FixtureId {
        <FixtureId as ::protobuf::Message>::default_instance()
    }
}

impl FixtureId {
    pub fn new() -> FixtureId {
        ::std::default::Default::default()
    }

    // uint32 fixture = 1;

    pub fn fixture(&self) -> u32 {
        match self.id {
            ::std::option::Option::Some(fixture_id::Id::Fixture(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_fixture(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_fixture(&self) -> bool {
        match self.id {
            ::std::option::Option::Some(fixture_id::Id::Fixture(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixture(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(fixture_id::Id::Fixture(v))
    }

    // .mizer.fixtures.SubFixtureId sub_fixture = 2;

    pub fn sub_fixture(&self) -> &SubFixtureId {
        match self.id {
            ::std::option::Option::Some(fixture_id::Id::SubFixture(ref v)) => v,
            _ => <SubFixtureId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sub_fixture(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_sub_fixture(&self) -> bool {
        match self.id {
            ::std::option::Option::Some(fixture_id::Id::SubFixture(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sub_fixture(&mut self, v: SubFixtureId) {
        self.id = ::std::option::Option::Some(fixture_id::Id::SubFixture(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sub_fixture(&mut self) -> &mut SubFixtureId {
        if let ::std::option::Option::Some(fixture_id::Id::SubFixture(_)) = self.id {
        } else {
            self.id = ::std::option::Option::Some(fixture_id::Id::SubFixture(SubFixtureId::new()));
        }
        match self.id {
            ::std::option::Option::Some(fixture_id::Id::SubFixture(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sub_fixture(&mut self) -> SubFixtureId {
        if self.has_sub_fixture() {
            match self.id.take() {
                ::std::option::Option::Some(fixture_id::Id::SubFixture(v)) => v,
                _ => panic!(),
            }
        } else {
            SubFixtureId::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "fixture",
            FixtureId::has_fixture,
            FixtureId::fixture,
            FixtureId::set_fixture,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SubFixtureId>(
            "sub_fixture",
            FixtureId::has_sub_fixture,
            FixtureId::sub_fixture,
            FixtureId::mut_sub_fixture,
            FixtureId::set_sub_fixture,
        ));
        oneofs.push(fixture_id::Id::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureId>(
            "FixtureId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureId {
    const NAME: &'static str = "FixtureId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(fixture_id::Id::Fixture(is.read_uint32()?));
                },
                18 => {
                    self.id = ::std::option::Option::Some(fixture_id::Id::SubFixture(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.id {
            match v {
                &fixture_id::Id::Fixture(v) => {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                },
                &fixture_id::Id::SubFixture(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.id {
            match v {
                &fixture_id::Id::Fixture(v) => {
                    os.write_uint32(1, v)?;
                },
                &fixture_id::Id::SubFixture(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureId {
        FixtureId::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureId {
        static instance: FixtureId = FixtureId {
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FixtureId`
pub mod fixture_id {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.fixtures.FixtureId.id)
    pub enum Id {
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureId.fixture)
        Fixture(u32),
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureId.sub_fixture)
        SubFixture(super::SubFixtureId),
    }

    impl ::protobuf::Oneof for Id {
    }

    impl ::protobuf::OneofFull for Id {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FixtureId as ::protobuf::MessageFull>::descriptor().oneof_by_name("id").unwrap()).clone()
        }
    }

    impl Id {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Id>("id")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.SubFixtureId)
pub struct SubFixtureId {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.SubFixtureId.fixture_id)
    pub fixture_id: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.SubFixtureId.child_id)
    pub child_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.SubFixtureId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubFixtureId {
    fn default() -> &'a SubFixtureId {
        <SubFixtureId as ::protobuf::Message>::default_instance()
    }
}

impl SubFixtureId {
    pub fn new() -> SubFixtureId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fixture_id",
            |m: &SubFixtureId| { &m.fixture_id },
            |m: &mut SubFixtureId| { &mut m.fixture_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "child_id",
            |m: &SubFixtureId| { &m.child_id },
            |m: &mut SubFixtureId| { &mut m.child_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubFixtureId>(
            "SubFixtureId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubFixtureId {
    const NAME: &'static str = "SubFixtureId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fixture_id = is.read_uint32()?;
                },
                16 => {
                    self.child_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fixture_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fixture_id);
        }
        if self.child_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.child_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fixture_id != 0 {
            os.write_uint32(1, self.fixture_id)?;
        }
        if self.child_id != 0 {
            os.write_uint32(2, self.child_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubFixtureId {
        SubFixtureId::new()
    }

    fn clear(&mut self) {
        self.fixture_id = 0;
        self.child_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubFixtureId {
        static instance: SubFixtureId = SubFixtureId {
            fixture_id: 0,
            child_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubFixtureId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubFixtureId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubFixtureId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubFixtureId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.Fixtures)
pub struct Fixtures {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.Fixtures.fixtures)
    pub fixtures: ::std::vec::Vec<Fixture>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.Fixtures.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Fixtures {
    fn default() -> &'a Fixtures {
        <Fixtures as ::protobuf::Message>::default_instance()
    }
}

impl Fixtures {
    pub fn new() -> Fixtures {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixtures",
            |m: &Fixtures| { &m.fixtures },
            |m: &mut Fixtures| { &mut m.fixtures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Fixtures>(
            "Fixtures",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Fixtures {
    const NAME: &'static str = "Fixtures";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fixtures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Fixtures {
        Fixtures::new()
    }

    fn clear(&mut self) {
        self.fixtures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Fixtures {
        static instance: Fixtures = Fixtures {
            fixtures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Fixtures {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Fixtures").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Fixtures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Fixtures {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.Fixture)
pub struct Fixture {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.manufacturer)
    pub manufacturer: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.model)
    pub model: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.mode)
    pub mode: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.universe)
    pub universe: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.channel)
    pub channel: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.channel_count)
    pub channel_count: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.controls)
    pub controls: ::std::vec::Vec<FixtureControls>,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.children)
    pub children: ::std::vec::Vec<SubFixture>,
    // @@protoc_insertion_point(field:mizer.fixtures.Fixture.config)
    pub config: ::protobuf::MessageField<FixtureConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.Fixture.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Fixture {
    fn default() -> &'a Fixture {
        <Fixture as ::protobuf::Message>::default_instance()
    }
}

impl Fixture {
    pub fn new() -> Fixture {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Fixture| { &m.id },
            |m: &mut Fixture| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Fixture| { &m.name },
            |m: &mut Fixture| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "manufacturer",
            |m: &Fixture| { &m.manufacturer },
            |m: &mut Fixture| { &mut m.manufacturer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model",
            |m: &Fixture| { &m.model },
            |m: &mut Fixture| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &Fixture| { &m.mode },
            |m: &mut Fixture| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "universe",
            |m: &Fixture| { &m.universe },
            |m: &mut Fixture| { &mut m.universe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel",
            |m: &Fixture| { &m.channel },
            |m: &mut Fixture| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel_count",
            |m: &Fixture| { &m.channel_count },
            |m: &mut Fixture| { &mut m.channel_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "controls",
            |m: &Fixture| { &m.controls },
            |m: &mut Fixture| { &mut m.controls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "children",
            |m: &Fixture| { &m.children },
            |m: &mut Fixture| { &mut m.children },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FixtureConfig>(
            "config",
            |m: &Fixture| { &m.config },
            |m: &mut Fixture| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Fixture>(
            "Fixture",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Fixture {
    const NAME: &'static str = "Fixture";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.manufacturer = is.read_string()?;
                },
                34 => {
                    self.model = is.read_string()?;
                },
                42 => {
                    self.mode = is.read_string()?;
                },
                48 => {
                    self.universe = is.read_uint32()?;
                },
                56 => {
                    self.channel = is.read_uint32()?;
                },
                64 => {
                    self.channel_count = is.read_uint32()?;
                },
                74 => {
                    self.controls.push(is.read_message()?);
                },
                82 => {
                    self.children.push(is.read_message()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.manufacturer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.manufacturer);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.model);
        }
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.mode);
        }
        if self.universe != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.universe);
        }
        if self.channel != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.channel);
        }
        if self.channel_count != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.channel_count);
        }
        for value in &self.controls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.manufacturer.is_empty() {
            os.write_string(3, &self.manufacturer)?;
        }
        if !self.model.is_empty() {
            os.write_string(4, &self.model)?;
        }
        if !self.mode.is_empty() {
            os.write_string(5, &self.mode)?;
        }
        if self.universe != 0 {
            os.write_uint32(6, self.universe)?;
        }
        if self.channel != 0 {
            os.write_uint32(7, self.channel)?;
        }
        if self.channel_count != 0 {
            os.write_uint32(8, self.channel_count)?;
        }
        for v in &self.controls {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.children {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Fixture {
        Fixture::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.manufacturer.clear();
        self.model.clear();
        self.mode.clear();
        self.universe = 0;
        self.channel = 0;
        self.channel_count = 0;
        self.controls.clear();
        self.children.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Fixture {
        static instance: Fixture = Fixture {
            id: 0,
            name: ::std::string::String::new(),
            manufacturer: ::std::string::String::new(),
            model: ::std::string::String::new(),
            mode: ::std::string::String::new(),
            universe: 0,
            channel: 0,
            channel_count: 0,
            controls: ::std::vec::Vec::new(),
            children: ::std::vec::Vec::new(),
            config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Fixture {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Fixture").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Fixture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Fixture {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixtureConfig)
pub struct FixtureConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureConfig.invert_pan)
    pub invert_pan: bool,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureConfig.invert_tilt)
    pub invert_tilt: bool,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureConfig.reverse_pixel_order)
    pub reverse_pixel_order: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureConfig {
    fn default() -> &'a FixtureConfig {
        <FixtureConfig as ::protobuf::Message>::default_instance()
    }
}

impl FixtureConfig {
    pub fn new() -> FixtureConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invert_pan",
            |m: &FixtureConfig| { &m.invert_pan },
            |m: &mut FixtureConfig| { &mut m.invert_pan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invert_tilt",
            |m: &FixtureConfig| { &m.invert_tilt },
            |m: &mut FixtureConfig| { &mut m.invert_tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reverse_pixel_order",
            |m: &FixtureConfig| { &m.reverse_pixel_order },
            |m: &mut FixtureConfig| { &mut m.reverse_pixel_order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureConfig>(
            "FixtureConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureConfig {
    const NAME: &'static str = "FixtureConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.invert_pan = is.read_bool()?;
                },
                16 => {
                    self.invert_tilt = is.read_bool()?;
                },
                24 => {
                    self.reverse_pixel_order = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.invert_pan != false {
            my_size += 1 + 1;
        }
        if self.invert_tilt != false {
            my_size += 1 + 1;
        }
        if self.reverse_pixel_order != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.invert_pan != false {
            os.write_bool(1, self.invert_pan)?;
        }
        if self.invert_tilt != false {
            os.write_bool(2, self.invert_tilt)?;
        }
        if self.reverse_pixel_order != false {
            os.write_bool(3, self.reverse_pixel_order)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureConfig {
        FixtureConfig::new()
    }

    fn clear(&mut self) {
        self.invert_pan = false;
        self.invert_tilt = false;
        self.reverse_pixel_order = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureConfig {
        static instance: FixtureConfig = FixtureConfig {
            invert_pan: false,
            invert_tilt: false,
            reverse_pixel_order: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.SubFixture)
pub struct SubFixture {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.SubFixture.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.fixtures.SubFixture.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.SubFixture.controls)
    pub controls: ::std::vec::Vec<FixtureControls>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.SubFixture.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubFixture {
    fn default() -> &'a SubFixture {
        <SubFixture as ::protobuf::Message>::default_instance()
    }
}

impl SubFixture {
    pub fn new() -> SubFixture {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SubFixture| { &m.id },
            |m: &mut SubFixture| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &SubFixture| { &m.name },
            |m: &mut SubFixture| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "controls",
            |m: &SubFixture| { &m.controls },
            |m: &mut SubFixture| { &mut m.controls },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubFixture>(
            "SubFixture",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubFixture {
    const NAME: &'static str = "SubFixture";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.controls.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.controls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.controls {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubFixture {
        SubFixture::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.controls.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubFixture {
        static instance: SubFixture = SubFixture {
            id: 0,
            name: ::std::string::String::new(),
            controls: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubFixture {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubFixture").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubFixture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubFixture {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixtureControls)
pub struct FixtureControls {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureControls.control)
    pub control: ::protobuf::EnumOrUnknown<FixtureControl>,
    // message oneof groups
    pub value: ::std::option::Option<fixture_controls::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureControls.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureControls {
    fn default() -> &'a FixtureControls {
        <FixtureControls as ::protobuf::Message>::default_instance()
    }
}

impl FixtureControls {
    pub fn new() -> FixtureControls {
        ::std::default::Default::default()
    }

    // .mizer.fixtures.FaderChannel fader = 2;

    pub fn fader(&self) -> &FaderChannel {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Fader(ref v)) => v,
            _ => <FaderChannel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fader(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_fader(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Fader(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fader(&mut self, v: FaderChannel) {
        self.value = ::std::option::Option::Some(fixture_controls::Value::Fader(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fader(&mut self) -> &mut FaderChannel {
        if let ::std::option::Option::Some(fixture_controls::Value::Fader(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(fixture_controls::Value::Fader(FaderChannel::new()));
        }
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Fader(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fader(&mut self) -> FaderChannel {
        if self.has_fader() {
            match self.value.take() {
                ::std::option::Option::Some(fixture_controls::Value::Fader(v)) => v,
                _ => panic!(),
            }
        } else {
            FaderChannel::new()
        }
    }

    // .mizer.fixtures.ColorMixerChannel color_mixer = 3;

    pub fn color_mixer(&self) -> &ColorMixerChannel {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::ColorMixer(ref v)) => v,
            _ => <ColorMixerChannel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_color_mixer(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_color_mixer(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::ColorMixer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color_mixer(&mut self, v: ColorMixerChannel) {
        self.value = ::std::option::Option::Some(fixture_controls::Value::ColorMixer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_color_mixer(&mut self) -> &mut ColorMixerChannel {
        if let ::std::option::Option::Some(fixture_controls::Value::ColorMixer(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(fixture_controls::Value::ColorMixer(ColorMixerChannel::new()));
        }
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::ColorMixer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_color_mixer(&mut self) -> ColorMixerChannel {
        if self.has_color_mixer() {
            match self.value.take() {
                ::std::option::Option::Some(fixture_controls::Value::ColorMixer(v)) => v,
                _ => panic!(),
            }
        } else {
            ColorMixerChannel::new()
        }
    }

    // .mizer.fixtures.ColorWheelChannel color_wheel = 4;

    pub fn color_wheel(&self) -> &ColorWheelChannel {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::ColorWheel(ref v)) => v,
            _ => <ColorWheelChannel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_color_wheel(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_color_wheel(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::ColorWheel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color_wheel(&mut self, v: ColorWheelChannel) {
        self.value = ::std::option::Option::Some(fixture_controls::Value::ColorWheel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_color_wheel(&mut self) -> &mut ColorWheelChannel {
        if let ::std::option::Option::Some(fixture_controls::Value::ColorWheel(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(fixture_controls::Value::ColorWheel(ColorWheelChannel::new()));
        }
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::ColorWheel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_color_wheel(&mut self) -> ColorWheelChannel {
        if self.has_color_wheel() {
            match self.value.take() {
                ::std::option::Option::Some(fixture_controls::Value::ColorWheel(v)) => v,
                _ => panic!(),
            }
        } else {
            ColorWheelChannel::new()
        }
    }

    // .mizer.fixtures.AxisChannel axis = 5;

    pub fn axis(&self) -> &AxisChannel {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Axis(ref v)) => v,
            _ => <AxisChannel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_axis(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_axis(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Axis(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_axis(&mut self, v: AxisChannel) {
        self.value = ::std::option::Option::Some(fixture_controls::Value::Axis(v))
    }

    // Mutable pointer to the field.
    pub fn mut_axis(&mut self) -> &mut AxisChannel {
        if let ::std::option::Option::Some(fixture_controls::Value::Axis(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(fixture_controls::Value::Axis(AxisChannel::new()));
        }
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Axis(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_axis(&mut self) -> AxisChannel {
        if self.has_axis() {
            match self.value.take() {
                ::std::option::Option::Some(fixture_controls::Value::Axis(v)) => v,
                _ => panic!(),
            }
        } else {
            AxisChannel::new()
        }
    }

    // .mizer.fixtures.GoboChannel gobo = 6;

    pub fn gobo(&self) -> &GoboChannel {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Gobo(ref v)) => v,
            _ => <GoboChannel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_gobo(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_gobo(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Gobo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gobo(&mut self, v: GoboChannel) {
        self.value = ::std::option::Option::Some(fixture_controls::Value::Gobo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gobo(&mut self) -> &mut GoboChannel {
        if let ::std::option::Option::Some(fixture_controls::Value::Gobo(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(fixture_controls::Value::Gobo(GoboChannel::new()));
        }
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Gobo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gobo(&mut self) -> GoboChannel {
        if self.has_gobo() {
            match self.value.take() {
                ::std::option::Option::Some(fixture_controls::Value::Gobo(v)) => v,
                _ => panic!(),
            }
        } else {
            GoboChannel::new()
        }
    }

    // .mizer.fixtures.GenericChannel generic = 7;

    pub fn generic(&self) -> &GenericChannel {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Generic(ref v)) => v,
            _ => <GenericChannel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_generic(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_generic(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Generic(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_generic(&mut self, v: GenericChannel) {
        self.value = ::std::option::Option::Some(fixture_controls::Value::Generic(v))
    }

    // Mutable pointer to the field.
    pub fn mut_generic(&mut self) -> &mut GenericChannel {
        if let ::std::option::Option::Some(fixture_controls::Value::Generic(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(fixture_controls::Value::Generic(GenericChannel::new()));
        }
        match self.value {
            ::std::option::Option::Some(fixture_controls::Value::Generic(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_generic(&mut self) -> GenericChannel {
        if self.has_generic() {
            match self.value.take() {
                ::std::option::Option::Some(fixture_controls::Value::Generic(v)) => v,
                _ => panic!(),
            }
        } else {
            GenericChannel::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "control",
            |m: &FixtureControls| { &m.control },
            |m: &mut FixtureControls| { &mut m.control },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FaderChannel>(
            "fader",
            FixtureControls::has_fader,
            FixtureControls::fader,
            FixtureControls::mut_fader,
            FixtureControls::set_fader,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ColorMixerChannel>(
            "color_mixer",
            FixtureControls::has_color_mixer,
            FixtureControls::color_mixer,
            FixtureControls::mut_color_mixer,
            FixtureControls::set_color_mixer,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ColorWheelChannel>(
            "color_wheel",
            FixtureControls::has_color_wheel,
            FixtureControls::color_wheel,
            FixtureControls::mut_color_wheel,
            FixtureControls::set_color_wheel,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AxisChannel>(
            "axis",
            FixtureControls::has_axis,
            FixtureControls::axis,
            FixtureControls::mut_axis,
            FixtureControls::set_axis,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GoboChannel>(
            "gobo",
            FixtureControls::has_gobo,
            FixtureControls::gobo,
            FixtureControls::mut_gobo,
            FixtureControls::set_gobo,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GenericChannel>(
            "generic",
            FixtureControls::has_generic,
            FixtureControls::generic,
            FixtureControls::mut_generic,
            FixtureControls::set_generic,
        ));
        oneofs.push(fixture_controls::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureControls>(
            "FixtureControls",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureControls {
    const NAME: &'static str = "FixtureControls";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.control = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.value = ::std::option::Option::Some(fixture_controls::Value::Fader(is.read_message()?));
                },
                26 => {
                    self.value = ::std::option::Option::Some(fixture_controls::Value::ColorMixer(is.read_message()?));
                },
                34 => {
                    self.value = ::std::option::Option::Some(fixture_controls::Value::ColorWheel(is.read_message()?));
                },
                42 => {
                    self.value = ::std::option::Option::Some(fixture_controls::Value::Axis(is.read_message()?));
                },
                50 => {
                    self.value = ::std::option::Option::Some(fixture_controls::Value::Gobo(is.read_message()?));
                },
                58 => {
                    self.value = ::std::option::Option::Some(fixture_controls::Value::Generic(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.control != ::protobuf::EnumOrUnknown::new(FixtureControl::INTENSITY) {
            my_size += ::protobuf::rt::int32_size(1, self.control.value());
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &fixture_controls::Value::Fader(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &fixture_controls::Value::ColorMixer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &fixture_controls::Value::ColorWheel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &fixture_controls::Value::Axis(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &fixture_controls::Value::Gobo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &fixture_controls::Value::Generic(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.control != ::protobuf::EnumOrUnknown::new(FixtureControl::INTENSITY) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.control))?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &fixture_controls::Value::Fader(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &fixture_controls::Value::ColorMixer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &fixture_controls::Value::ColorWheel(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &fixture_controls::Value::Axis(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &fixture_controls::Value::Gobo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &fixture_controls::Value::Generic(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureControls {
        FixtureControls::new()
    }

    fn clear(&mut self) {
        self.control = ::protobuf::EnumOrUnknown::new(FixtureControl::INTENSITY);
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureControls {
        static instance: FixtureControls = FixtureControls {
            control: ::protobuf::EnumOrUnknown::from_i32(0),
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureControls {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureControls").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureControls {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureControls {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FixtureControls`
pub mod fixture_controls {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.fixtures.FixtureControls.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureControls.fader)
        Fader(super::FaderChannel),
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureControls.color_mixer)
        ColorMixer(super::ColorMixerChannel),
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureControls.color_wheel)
        ColorWheel(super::ColorWheelChannel),
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureControls.axis)
        Axis(super::AxisChannel),
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureControls.gobo)
        Gobo(super::GoboChannel),
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureControls.generic)
        Generic(super::GenericChannel),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FixtureControls as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FaderChannel)
pub struct FaderChannel {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FaderChannel.value)
    pub value: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FaderChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FaderChannel {
    fn default() -> &'a FaderChannel {
        <FaderChannel as ::protobuf::Message>::default_instance()
    }
}

impl FaderChannel {
    pub fn new() -> FaderChannel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &FaderChannel| { &m.value },
            |m: &mut FaderChannel| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FaderChannel>(
            "FaderChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FaderChannel {
    const NAME: &'static str = "FaderChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.value = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FaderChannel {
        FaderChannel::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FaderChannel {
        static instance: FaderChannel = FaderChannel {
            value: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FaderChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FaderChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FaderChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FaderChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.ColorMixerChannel)
pub struct ColorMixerChannel {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.ColorMixerChannel.red)
    pub red: f64,
    // @@protoc_insertion_point(field:mizer.fixtures.ColorMixerChannel.green)
    pub green: f64,
    // @@protoc_insertion_point(field:mizer.fixtures.ColorMixerChannel.blue)
    pub blue: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.ColorMixerChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorMixerChannel {
    fn default() -> &'a ColorMixerChannel {
        <ColorMixerChannel as ::protobuf::Message>::default_instance()
    }
}

impl ColorMixerChannel {
    pub fn new() -> ColorMixerChannel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "red",
            |m: &ColorMixerChannel| { &m.red },
            |m: &mut ColorMixerChannel| { &mut m.red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "green",
            |m: &ColorMixerChannel| { &m.green },
            |m: &mut ColorMixerChannel| { &mut m.green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blue",
            |m: &ColorMixerChannel| { &m.blue },
            |m: &mut ColorMixerChannel| { &mut m.blue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorMixerChannel>(
            "ColorMixerChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorMixerChannel {
    const NAME: &'static str = "ColorMixerChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.red = is.read_double()?;
                },
                17 => {
                    self.green = is.read_double()?;
                },
                25 => {
                    self.blue = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.red != 0. {
            my_size += 1 + 8;
        }
        if self.green != 0. {
            my_size += 1 + 8;
        }
        if self.blue != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.red != 0. {
            os.write_double(1, self.red)?;
        }
        if self.green != 0. {
            os.write_double(2, self.green)?;
        }
        if self.blue != 0. {
            os.write_double(3, self.blue)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorMixerChannel {
        ColorMixerChannel::new()
    }

    fn clear(&mut self) {
        self.red = 0.;
        self.green = 0.;
        self.blue = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorMixerChannel {
        static instance: ColorMixerChannel = ColorMixerChannel {
            red: 0.,
            green: 0.,
            blue: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorMixerChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorMixerChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorMixerChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorMixerChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.ColorWheelChannel)
pub struct ColorWheelChannel {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.ColorWheelChannel.value)
    pub value: f64,
    // @@protoc_insertion_point(field:mizer.fixtures.ColorWheelChannel.colors)
    pub colors: ::std::vec::Vec<ColorWheelSlot>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.ColorWheelChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorWheelChannel {
    fn default() -> &'a ColorWheelChannel {
        <ColorWheelChannel as ::protobuf::Message>::default_instance()
    }
}

impl ColorWheelChannel {
    pub fn new() -> ColorWheelChannel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &ColorWheelChannel| { &m.value },
            |m: &mut ColorWheelChannel| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colors",
            |m: &ColorWheelChannel| { &m.colors },
            |m: &mut ColorWheelChannel| { &mut m.colors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorWheelChannel>(
            "ColorWheelChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorWheelChannel {
    const NAME: &'static str = "ColorWheelChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.value = is.read_double()?;
                },
                18 => {
                    self.colors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 8;
        }
        for value in &self.colors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        for v in &self.colors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorWheelChannel {
        ColorWheelChannel::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.colors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorWheelChannel {
        static instance: ColorWheelChannel = ColorWheelChannel {
            value: 0.,
            colors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorWheelChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorWheelChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorWheelChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorWheelChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.ColorWheelSlot)
pub struct ColorWheelSlot {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.ColorWheelSlot.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.ColorWheelSlot.value)
    pub value: f64,
    // @@protoc_insertion_point(field:mizer.fixtures.ColorWheelSlot.colors)
    pub colors: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.ColorWheelSlot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorWheelSlot {
    fn default() -> &'a ColorWheelSlot {
        <ColorWheelSlot as ::protobuf::Message>::default_instance()
    }
}

impl ColorWheelSlot {
    pub fn new() -> ColorWheelSlot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ColorWheelSlot| { &m.name },
            |m: &mut ColorWheelSlot| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &ColorWheelSlot| { &m.value },
            |m: &mut ColorWheelSlot| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colors",
            |m: &ColorWheelSlot| { &m.colors },
            |m: &mut ColorWheelSlot| { &mut m.colors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorWheelSlot>(
            "ColorWheelSlot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorWheelSlot {
    const NAME: &'static str = "ColorWheelSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                17 => {
                    self.value = is.read_double()?;
                },
                26 => {
                    self.colors.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.value != 0. {
            my_size += 1 + 8;
        }
        for value in &self.colors {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.value != 0. {
            os.write_double(2, self.value)?;
        }
        for v in &self.colors {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorWheelSlot {
        ColorWheelSlot::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.value = 0.;
        self.colors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorWheelSlot {
        static instance: ColorWheelSlot = ColorWheelSlot {
            name: ::std::string::String::new(),
            value: 0.,
            colors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorWheelSlot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorWheelSlot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorWheelSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorWheelSlot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.AxisChannel)
pub struct AxisChannel {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.AxisChannel.value)
    pub value: f64,
    // @@protoc_insertion_point(field:mizer.fixtures.AxisChannel.angle_from)
    pub angle_from: f64,
    // @@protoc_insertion_point(field:mizer.fixtures.AxisChannel.angle_to)
    pub angle_to: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.AxisChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AxisChannel {
    fn default() -> &'a AxisChannel {
        <AxisChannel as ::protobuf::Message>::default_instance()
    }
}

impl AxisChannel {
    pub fn new() -> AxisChannel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &AxisChannel| { &m.value },
            |m: &mut AxisChannel| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "angle_from",
            |m: &AxisChannel| { &m.angle_from },
            |m: &mut AxisChannel| { &mut m.angle_from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "angle_to",
            |m: &AxisChannel| { &m.angle_to },
            |m: &mut AxisChannel| { &mut m.angle_to },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AxisChannel>(
            "AxisChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AxisChannel {
    const NAME: &'static str = "AxisChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.value = is.read_double()?;
                },
                17 => {
                    self.angle_from = is.read_double()?;
                },
                25 => {
                    self.angle_to = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 8;
        }
        if self.angle_from != 0. {
            my_size += 1 + 8;
        }
        if self.angle_to != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        if self.angle_from != 0. {
            os.write_double(2, self.angle_from)?;
        }
        if self.angle_to != 0. {
            os.write_double(3, self.angle_to)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AxisChannel {
        AxisChannel::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.angle_from = 0.;
        self.angle_to = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AxisChannel {
        static instance: AxisChannel = AxisChannel {
            value: 0.,
            angle_from: 0.,
            angle_to: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AxisChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AxisChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AxisChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AxisChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.GoboChannel)
pub struct GoboChannel {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.GoboChannel.value)
    pub value: f64,
    // @@protoc_insertion_point(field:mizer.fixtures.GoboChannel.gobos)
    pub gobos: ::std::vec::Vec<Gobo>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.GoboChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GoboChannel {
    fn default() -> &'a GoboChannel {
        <GoboChannel as ::protobuf::Message>::default_instance()
    }
}

impl GoboChannel {
    pub fn new() -> GoboChannel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &GoboChannel| { &m.value },
            |m: &mut GoboChannel| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gobos",
            |m: &GoboChannel| { &m.gobos },
            |m: &mut GoboChannel| { &mut m.gobos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GoboChannel>(
            "GoboChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GoboChannel {
    const NAME: &'static str = "GoboChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.value = is.read_double()?;
                },
                18 => {
                    self.gobos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 8;
        }
        for value in &self.gobos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        for v in &self.gobos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GoboChannel {
        GoboChannel::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.gobos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GoboChannel {
        static instance: GoboChannel = GoboChannel {
            value: 0.,
            gobos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GoboChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GoboChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GoboChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoboChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.Gobo)
pub struct Gobo {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.Gobo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.Gobo.value)
    pub value: f64,
    // message oneof groups
    pub image: ::std::option::Option<gobo::Image>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.Gobo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Gobo {
    fn default() -> &'a Gobo {
        <Gobo as ::protobuf::Message>::default_instance()
    }
}

impl Gobo {
    pub fn new() -> Gobo {
        ::std::default::Default::default()
    }

    // string svg = 3;

    pub fn svg(&self) -> &str {
        match self.image {
            ::std::option::Option::Some(gobo::Image::Svg(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_svg(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_svg(&self) -> bool {
        match self.image {
            ::std::option::Option::Some(gobo::Image::Svg(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_svg(&mut self, v: ::std::string::String) {
        self.image = ::std::option::Option::Some(gobo::Image::Svg(v))
    }

    // Mutable pointer to the field.
    pub fn mut_svg(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(gobo::Image::Svg(_)) = self.image {
        } else {
            self.image = ::std::option::Option::Some(gobo::Image::Svg(::std::string::String::new()));
        }
        match self.image {
            ::std::option::Option::Some(gobo::Image::Svg(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_svg(&mut self) -> ::std::string::String {
        if self.has_svg() {
            match self.image.take() {
                ::std::option::Option::Some(gobo::Image::Svg(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes raster = 4;

    pub fn raster(&self) -> &[u8] {
        match self.image {
            ::std::option::Option::Some(gobo::Image::Raster(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_raster(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_raster(&self) -> bool {
        match self.image {
            ::std::option::Option::Some(gobo::Image::Raster(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_raster(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::std::option::Option::Some(gobo::Image::Raster(v))
    }

    // Mutable pointer to the field.
    pub fn mut_raster(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(gobo::Image::Raster(_)) = self.image {
        } else {
            self.image = ::std::option::Option::Some(gobo::Image::Raster(::std::vec::Vec::new()));
        }
        match self.image {
            ::std::option::Option::Some(gobo::Image::Raster(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_raster(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_raster() {
            match self.image.take() {
                ::std::option::Option::Some(gobo::Image::Raster(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Gobo| { &m.name },
            |m: &mut Gobo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Gobo| { &m.value },
            |m: &mut Gobo| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "svg",
            Gobo::has_svg,
            Gobo::svg,
            Gobo::set_svg,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "raster",
            Gobo::has_raster,
            Gobo::raster,
            Gobo::set_raster,
        ));
        oneofs.push(gobo::Image::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Gobo>(
            "Gobo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Gobo {
    const NAME: &'static str = "Gobo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                17 => {
                    self.value = is.read_double()?;
                },
                26 => {
                    self.image = ::std::option::Option::Some(gobo::Image::Svg(is.read_string()?));
                },
                34 => {
                    self.image = ::std::option::Option::Some(gobo::Image::Raster(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.value != 0. {
            my_size += 1 + 8;
        }
        if let ::std::option::Option::Some(ref v) = self.image {
            match v {
                &gobo::Image::Svg(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &gobo::Image::Raster(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.value != 0. {
            os.write_double(2, self.value)?;
        }
        if let ::std::option::Option::Some(ref v) = self.image {
            match v {
                &gobo::Image::Svg(ref v) => {
                    os.write_string(3, v)?;
                },
                &gobo::Image::Raster(ref v) => {
                    os.write_bytes(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Gobo {
        Gobo::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.value = 0.;
        self.image = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Gobo {
        static instance: Gobo = Gobo {
            name: ::std::string::String::new(),
            value: 0.,
            image: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Gobo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Gobo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Gobo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Gobo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Gobo`
pub mod gobo {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.fixtures.Gobo.image)
    pub enum Image {
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.Gobo.svg)
        Svg(::std::string::String),
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.Gobo.raster)
        Raster(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Image {
    }

    impl ::protobuf::OneofFull for Image {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Gobo as ::protobuf::MessageFull>::descriptor().oneof_by_name("image").unwrap()).clone()
        }
    }

    impl Image {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Image>("image")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.GenericChannel)
pub struct GenericChannel {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.GenericChannel.value)
    pub value: f64,
    // @@protoc_insertion_point(field:mizer.fixtures.GenericChannel.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.GenericChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenericChannel {
    fn default() -> &'a GenericChannel {
        <GenericChannel as ::protobuf::Message>::default_instance()
    }
}

impl GenericChannel {
    pub fn new() -> GenericChannel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &GenericChannel| { &m.value },
            |m: &mut GenericChannel| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &GenericChannel| { &m.name },
            |m: &mut GenericChannel| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericChannel>(
            "GenericChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenericChannel {
    const NAME: &'static str = "GenericChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.value = is.read_double()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 8;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenericChannel {
        GenericChannel::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenericChannel {
        static instance: GenericChannel = GenericChannel {
            value: 0.,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenericChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenericChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenericChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.GetFixtureDefinitionsRequest)
pub struct GetFixtureDefinitionsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.GetFixtureDefinitionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFixtureDefinitionsRequest {
    fn default() -> &'a GetFixtureDefinitionsRequest {
        <GetFixtureDefinitionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFixtureDefinitionsRequest {
    pub fn new() -> GetFixtureDefinitionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFixtureDefinitionsRequest>(
            "GetFixtureDefinitionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFixtureDefinitionsRequest {
    const NAME: &'static str = "GetFixtureDefinitionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFixtureDefinitionsRequest {
        GetFixtureDefinitionsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFixtureDefinitionsRequest {
        static instance: GetFixtureDefinitionsRequest = GetFixtureDefinitionsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFixtureDefinitionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFixtureDefinitionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFixtureDefinitionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFixtureDefinitionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixtureDefinitions)
pub struct FixtureDefinitions {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureDefinitions.definitions)
    pub definitions: ::std::vec::Vec<FixtureDefinition>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureDefinitions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureDefinitions {
    fn default() -> &'a FixtureDefinitions {
        <FixtureDefinitions as ::protobuf::Message>::default_instance()
    }
}

impl FixtureDefinitions {
    pub fn new() -> FixtureDefinitions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "definitions",
            |m: &FixtureDefinitions| { &m.definitions },
            |m: &mut FixtureDefinitions| { &mut m.definitions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureDefinitions>(
            "FixtureDefinitions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureDefinitions {
    const NAME: &'static str = "FixtureDefinitions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.definitions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.definitions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.definitions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureDefinitions {
        FixtureDefinitions::new()
    }

    fn clear(&mut self) {
        self.definitions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureDefinitions {
        static instance: FixtureDefinitions = FixtureDefinitions {
            definitions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureDefinitions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureDefinitions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureDefinitions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureDefinitions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixtureDefinition)
pub struct FixtureDefinition {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureDefinition.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureDefinition.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureDefinition.manufacturer)
    pub manufacturer: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureDefinition.modes)
    pub modes: ::std::vec::Vec<FixtureMode>,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureDefinition.physical)
    pub physical: ::protobuf::MessageField<FixturePhysicalData>,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureDefinition.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureDefinition.provider)
    pub provider: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureDefinition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureDefinition {
    fn default() -> &'a FixtureDefinition {
        <FixtureDefinition as ::protobuf::Message>::default_instance()
    }
}

impl FixtureDefinition {
    pub fn new() -> FixtureDefinition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &FixtureDefinition| { &m.id },
            |m: &mut FixtureDefinition| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FixtureDefinition| { &m.name },
            |m: &mut FixtureDefinition| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "manufacturer",
            |m: &FixtureDefinition| { &m.manufacturer },
            |m: &mut FixtureDefinition| { &mut m.manufacturer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modes",
            |m: &FixtureDefinition| { &m.modes },
            |m: &mut FixtureDefinition| { &mut m.modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FixturePhysicalData>(
            "physical",
            |m: &FixtureDefinition| { &m.physical },
            |m: &mut FixtureDefinition| { &mut m.physical },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &FixtureDefinition| { &m.tags },
            |m: &mut FixtureDefinition| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "provider",
            |m: &FixtureDefinition| { &m.provider },
            |m: &mut FixtureDefinition| { &mut m.provider },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureDefinition>(
            "FixtureDefinition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureDefinition {
    const NAME: &'static str = "FixtureDefinition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.manufacturer = is.read_string()?;
                },
                34 => {
                    self.modes.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.physical)?;
                },
                50 => {
                    self.tags.push(is.read_string()?);
                },
                58 => {
                    self.provider = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.manufacturer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.manufacturer);
        }
        for value in &self.modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.physical.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.provider.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.provider);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.manufacturer.is_empty() {
            os.write_string(3, &self.manufacturer)?;
        }
        for v in &self.modes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.physical.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.tags {
            os.write_string(6, &v)?;
        };
        if !self.provider.is_empty() {
            os.write_string(7, &self.provider)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureDefinition {
        FixtureDefinition::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.manufacturer.clear();
        self.modes.clear();
        self.physical.clear();
        self.tags.clear();
        self.provider.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureDefinition {
        static instance: FixtureDefinition = FixtureDefinition {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            manufacturer: ::std::string::String::new(),
            modes: ::std::vec::Vec::new(),
            physical: ::protobuf::MessageField::none(),
            tags: ::std::vec::Vec::new(),
            provider: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureDefinition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureDefinition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureDefinition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixtureMode)
pub struct FixtureMode {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureMode.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureMode.channels)
    pub channels: ::std::vec::Vec<FixtureChannel>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureMode {
    fn default() -> &'a FixtureMode {
        <FixtureMode as ::protobuf::Message>::default_instance()
    }
}

impl FixtureMode {
    pub fn new() -> FixtureMode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FixtureMode| { &m.name },
            |m: &mut FixtureMode| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels",
            |m: &FixtureMode| { &m.channels },
            |m: &mut FixtureMode| { &mut m.channels },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureMode>(
            "FixtureMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureMode {
    const NAME: &'static str = "FixtureMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.channels.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureMode {
        FixtureMode::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.channels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureMode {
        static instance: FixtureMode = FixtureMode {
            name: ::std::string::String::new(),
            channels: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixtureChannel)
pub struct FixtureChannel {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureChannel.name)
    pub name: ::std::string::String,
    // message oneof groups
    pub resolution: ::std::option::Option<fixture_channel::Resolution>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureChannel {
    fn default() -> &'a FixtureChannel {
        <FixtureChannel as ::protobuf::Message>::default_instance()
    }
}

impl FixtureChannel {
    pub fn new() -> FixtureChannel {
        ::std::default::Default::default()
    }

    // .mizer.fixtures.FixtureChannel.CoarseResolution coarse = 2;

    pub fn coarse(&self) -> &fixture_channel::CoarseResolution {
        match self.resolution {
            ::std::option::Option::Some(fixture_channel::Resolution::Coarse(ref v)) => v,
            _ => <fixture_channel::CoarseResolution as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_coarse(&mut self) {
        self.resolution = ::std::option::Option::None;
    }

    pub fn has_coarse(&self) -> bool {
        match self.resolution {
            ::std::option::Option::Some(fixture_channel::Resolution::Coarse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_coarse(&mut self, v: fixture_channel::CoarseResolution) {
        self.resolution = ::std::option::Option::Some(fixture_channel::Resolution::Coarse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_coarse(&mut self) -> &mut fixture_channel::CoarseResolution {
        if let ::std::option::Option::Some(fixture_channel::Resolution::Coarse(_)) = self.resolution {
        } else {
            self.resolution = ::std::option::Option::Some(fixture_channel::Resolution::Coarse(fixture_channel::CoarseResolution::new()));
        }
        match self.resolution {
            ::std::option::Option::Some(fixture_channel::Resolution::Coarse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_coarse(&mut self) -> fixture_channel::CoarseResolution {
        if self.has_coarse() {
            match self.resolution.take() {
                ::std::option::Option::Some(fixture_channel::Resolution::Coarse(v)) => v,
                _ => panic!(),
            }
        } else {
            fixture_channel::CoarseResolution::new()
        }
    }

    // .mizer.fixtures.FixtureChannel.FineResolution fine = 3;

    pub fn fine(&self) -> &fixture_channel::FineResolution {
        match self.resolution {
            ::std::option::Option::Some(fixture_channel::Resolution::Fine(ref v)) => v,
            _ => <fixture_channel::FineResolution as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fine(&mut self) {
        self.resolution = ::std::option::Option::None;
    }

    pub fn has_fine(&self) -> bool {
        match self.resolution {
            ::std::option::Option::Some(fixture_channel::Resolution::Fine(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fine(&mut self, v: fixture_channel::FineResolution) {
        self.resolution = ::std::option::Option::Some(fixture_channel::Resolution::Fine(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fine(&mut self) -> &mut fixture_channel::FineResolution {
        if let ::std::option::Option::Some(fixture_channel::Resolution::Fine(_)) = self.resolution {
        } else {
            self.resolution = ::std::option::Option::Some(fixture_channel::Resolution::Fine(fixture_channel::FineResolution::new()));
        }
        match self.resolution {
            ::std::option::Option::Some(fixture_channel::Resolution::Fine(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fine(&mut self) -> fixture_channel::FineResolution {
        if self.has_fine() {
            match self.resolution.take() {
                ::std::option::Option::Some(fixture_channel::Resolution::Fine(v)) => v,
                _ => panic!(),
            }
        } else {
            fixture_channel::FineResolution::new()
        }
    }

    // .mizer.fixtures.FixtureChannel.FinestResolution finest = 4;

    pub fn finest(&self) -> &fixture_channel::FinestResolution {
        match self.resolution {
            ::std::option::Option::Some(fixture_channel::Resolution::Finest(ref v)) => v,
            _ => <fixture_channel::FinestResolution as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_finest(&mut self) {
        self.resolution = ::std::option::Option::None;
    }

    pub fn has_finest(&self) -> bool {
        match self.resolution {
            ::std::option::Option::Some(fixture_channel::Resolution::Finest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finest(&mut self, v: fixture_channel::FinestResolution) {
        self.resolution = ::std::option::Option::Some(fixture_channel::Resolution::Finest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finest(&mut self) -> &mut fixture_channel::FinestResolution {
        if let ::std::option::Option::Some(fixture_channel::Resolution::Finest(_)) = self.resolution {
        } else {
            self.resolution = ::std::option::Option::Some(fixture_channel::Resolution::Finest(fixture_channel::FinestResolution::new()));
        }
        match self.resolution {
            ::std::option::Option::Some(fixture_channel::Resolution::Finest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finest(&mut self) -> fixture_channel::FinestResolution {
        if self.has_finest() {
            match self.resolution.take() {
                ::std::option::Option::Some(fixture_channel::Resolution::Finest(v)) => v,
                _ => panic!(),
            }
        } else {
            fixture_channel::FinestResolution::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FixtureChannel| { &m.name },
            |m: &mut FixtureChannel| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, fixture_channel::CoarseResolution>(
            "coarse",
            FixtureChannel::has_coarse,
            FixtureChannel::coarse,
            FixtureChannel::mut_coarse,
            FixtureChannel::set_coarse,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, fixture_channel::FineResolution>(
            "fine",
            FixtureChannel::has_fine,
            FixtureChannel::fine,
            FixtureChannel::mut_fine,
            FixtureChannel::set_fine,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, fixture_channel::FinestResolution>(
            "finest",
            FixtureChannel::has_finest,
            FixtureChannel::finest,
            FixtureChannel::mut_finest,
            FixtureChannel::set_finest,
        ));
        oneofs.push(fixture_channel::Resolution::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureChannel>(
            "FixtureChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureChannel {
    const NAME: &'static str = "FixtureChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.resolution = ::std::option::Option::Some(fixture_channel::Resolution::Coarse(is.read_message()?));
                },
                26 => {
                    self.resolution = ::std::option::Option::Some(fixture_channel::Resolution::Fine(is.read_message()?));
                },
                34 => {
                    self.resolution = ::std::option::Option::Some(fixture_channel::Resolution::Finest(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.resolution {
            match v {
                &fixture_channel::Resolution::Coarse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &fixture_channel::Resolution::Fine(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &fixture_channel::Resolution::Finest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.resolution {
            match v {
                &fixture_channel::Resolution::Coarse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &fixture_channel::Resolution::Fine(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &fixture_channel::Resolution::Finest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureChannel {
        FixtureChannel::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.resolution = ::std::option::Option::None;
        self.resolution = ::std::option::Option::None;
        self.resolution = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureChannel {
        static instance: FixtureChannel = FixtureChannel {
            name: ::std::string::String::new(),
            resolution: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FixtureChannel`
pub mod fixture_channel {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.fixtures.FixtureChannel.resolution)
    pub enum Resolution {
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureChannel.coarse)
        Coarse(CoarseResolution),
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureChannel.fine)
        Fine(FineResolution),
        // @@protoc_insertion_point(oneof_field:mizer.fixtures.FixtureChannel.finest)
        Finest(FinestResolution),
    }

    impl ::protobuf::Oneof for Resolution {
    }

    impl ::protobuf::OneofFull for Resolution {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FixtureChannel as ::protobuf::MessageFull>::descriptor().oneof_by_name("resolution").unwrap()).clone()
        }
    }

    impl Resolution {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Resolution>("resolution")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.fixtures.FixtureChannel.CoarseResolution)
    pub struct CoarseResolution {
        // message fields
        // @@protoc_insertion_point(field:mizer.fixtures.FixtureChannel.CoarseResolution.channel)
        pub channel: u32,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureChannel.CoarseResolution.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CoarseResolution {
        fn default() -> &'a CoarseResolution {
            <CoarseResolution as ::protobuf::Message>::default_instance()
        }
    }

    impl CoarseResolution {
        pub fn new() -> CoarseResolution {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "channel",
                |m: &CoarseResolution| { &m.channel },
                |m: &mut CoarseResolution| { &mut m.channel },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CoarseResolution>(
                "FixtureChannel.CoarseResolution",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CoarseResolution {
        const NAME: &'static str = "CoarseResolution";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.channel = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.channel != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.channel);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.channel != 0 {
                os.write_uint32(1, self.channel)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CoarseResolution {
            CoarseResolution::new()
        }

        fn clear(&mut self) {
            self.channel = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CoarseResolution {
            static instance: CoarseResolution = CoarseResolution {
                channel: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CoarseResolution {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FixtureChannel.CoarseResolution").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CoarseResolution {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CoarseResolution {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.fixtures.FixtureChannel.FineResolution)
    pub struct FineResolution {
        // message fields
        // @@protoc_insertion_point(field:mizer.fixtures.FixtureChannel.FineResolution.fine_channel)
        pub fine_channel: u32,
        // @@protoc_insertion_point(field:mizer.fixtures.FixtureChannel.FineResolution.coarse_channel)
        pub coarse_channel: u32,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureChannel.FineResolution.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FineResolution {
        fn default() -> &'a FineResolution {
            <FineResolution as ::protobuf::Message>::default_instance()
        }
    }

    impl FineResolution {
        pub fn new() -> FineResolution {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fine_channel",
                |m: &FineResolution| { &m.fine_channel },
                |m: &mut FineResolution| { &mut m.fine_channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "coarse_channel",
                |m: &FineResolution| { &m.coarse_channel },
                |m: &mut FineResolution| { &mut m.coarse_channel },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FineResolution>(
                "FixtureChannel.FineResolution",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FineResolution {
        const NAME: &'static str = "FineResolution";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.fine_channel = is.read_uint32()?;
                    },
                    16 => {
                        self.coarse_channel = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.fine_channel != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.fine_channel);
            }
            if self.coarse_channel != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.coarse_channel);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.fine_channel != 0 {
                os.write_uint32(1, self.fine_channel)?;
            }
            if self.coarse_channel != 0 {
                os.write_uint32(2, self.coarse_channel)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FineResolution {
            FineResolution::new()
        }

        fn clear(&mut self) {
            self.fine_channel = 0;
            self.coarse_channel = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FineResolution {
            static instance: FineResolution = FineResolution {
                fine_channel: 0,
                coarse_channel: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FineResolution {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FixtureChannel.FineResolution").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FineResolution {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FineResolution {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.fixtures.FixtureChannel.FinestResolution)
    pub struct FinestResolution {
        // message fields
        // @@protoc_insertion_point(field:mizer.fixtures.FixtureChannel.FinestResolution.finest_channel)
        pub finest_channel: u32,
        // @@protoc_insertion_point(field:mizer.fixtures.FixtureChannel.FinestResolution.fine_channel)
        pub fine_channel: u32,
        // @@protoc_insertion_point(field:mizer.fixtures.FixtureChannel.FinestResolution.coarse_channel)
        pub coarse_channel: u32,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureChannel.FinestResolution.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FinestResolution {
        fn default() -> &'a FinestResolution {
            <FinestResolution as ::protobuf::Message>::default_instance()
        }
    }

    impl FinestResolution {
        pub fn new() -> FinestResolution {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "finest_channel",
                |m: &FinestResolution| { &m.finest_channel },
                |m: &mut FinestResolution| { &mut m.finest_channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fine_channel",
                |m: &FinestResolution| { &m.fine_channel },
                |m: &mut FinestResolution| { &mut m.fine_channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "coarse_channel",
                |m: &FinestResolution| { &m.coarse_channel },
                |m: &mut FinestResolution| { &mut m.coarse_channel },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FinestResolution>(
                "FixtureChannel.FinestResolution",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FinestResolution {
        const NAME: &'static str = "FinestResolution";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.finest_channel = is.read_uint32()?;
                    },
                    16 => {
                        self.fine_channel = is.read_uint32()?;
                    },
                    24 => {
                        self.coarse_channel = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.finest_channel != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.finest_channel);
            }
            if self.fine_channel != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.fine_channel);
            }
            if self.coarse_channel != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.coarse_channel);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.finest_channel != 0 {
                os.write_uint32(1, self.finest_channel)?;
            }
            if self.fine_channel != 0 {
                os.write_uint32(2, self.fine_channel)?;
            }
            if self.coarse_channel != 0 {
                os.write_uint32(3, self.coarse_channel)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FinestResolution {
            FinestResolution::new()
        }

        fn clear(&mut self) {
            self.finest_channel = 0;
            self.fine_channel = 0;
            self.coarse_channel = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FinestResolution {
            static instance: FinestResolution = FinestResolution {
                finest_channel: 0,
                fine_channel: 0,
                coarse_channel: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FinestResolution {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FixtureChannel.FinestResolution").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FinestResolution {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FinestResolution {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixturePhysicalData)
pub struct FixturePhysicalData {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FixturePhysicalData.width)
    pub width: f32,
    // @@protoc_insertion_point(field:mizer.fixtures.FixturePhysicalData.height)
    pub height: f32,
    // @@protoc_insertion_point(field:mizer.fixtures.FixturePhysicalData.depth)
    pub depth: f32,
    // @@protoc_insertion_point(field:mizer.fixtures.FixturePhysicalData.weight)
    pub weight: f32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixturePhysicalData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixturePhysicalData {
    fn default() -> &'a FixturePhysicalData {
        <FixturePhysicalData as ::protobuf::Message>::default_instance()
    }
}

impl FixturePhysicalData {
    pub fn new() -> FixturePhysicalData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &FixturePhysicalData| { &m.width },
            |m: &mut FixturePhysicalData| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &FixturePhysicalData| { &m.height },
            |m: &mut FixturePhysicalData| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "depth",
            |m: &FixturePhysicalData| { &m.depth },
            |m: &mut FixturePhysicalData| { &mut m.depth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "weight",
            |m: &FixturePhysicalData| { &m.weight },
            |m: &mut FixturePhysicalData| { &mut m.weight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixturePhysicalData>(
            "FixturePhysicalData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixturePhysicalData {
    const NAME: &'static str = "FixturePhysicalData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.width = is.read_float()?;
                },
                21 => {
                    self.height = is.read_float()?;
                },
                29 => {
                    self.depth = is.read_float()?;
                },
                37 => {
                    self.weight = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.width != 0. {
            my_size += 1 + 4;
        }
        if self.height != 0. {
            my_size += 1 + 4;
        }
        if self.depth != 0. {
            my_size += 1 + 4;
        }
        if self.weight != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.width != 0. {
            os.write_float(1, self.width)?;
        }
        if self.height != 0. {
            os.write_float(2, self.height)?;
        }
        if self.depth != 0. {
            os.write_float(3, self.depth)?;
        }
        if self.weight != 0. {
            os.write_float(4, self.weight)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixturePhysicalData {
        FixturePhysicalData::new()
    }

    fn clear(&mut self) {
        self.width = 0.;
        self.height = 0.;
        self.depth = 0.;
        self.weight = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixturePhysicalData {
        static instance: FixturePhysicalData = FixturePhysicalData {
            width: 0.,
            height: 0.,
            depth: 0.,
            weight: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixturePhysicalData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixturePhysicalData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixturePhysicalData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixturePhysicalData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.fixtures.FixtureFaderControl)
pub struct FixtureFaderControl {
    // message fields
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureFaderControl.control)
    pub control: ::protobuf::EnumOrUnknown<FixtureControl>,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureFaderControl.color_mixer_channel)
    pub color_mixer_channel: ::std::option::Option<::protobuf::EnumOrUnknown<fixture_fader_control::ColorMixerControlChannel>>,
    // @@protoc_insertion_point(field:mizer.fixtures.FixtureFaderControl.generic_channel)
    pub generic_channel: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.fixtures.FixtureFaderControl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureFaderControl {
    fn default() -> &'a FixtureFaderControl {
        <FixtureFaderControl as ::protobuf::Message>::default_instance()
    }
}

impl FixtureFaderControl {
    pub fn new() -> FixtureFaderControl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "control",
            |m: &FixtureFaderControl| { &m.control },
            |m: &mut FixtureFaderControl| { &mut m.control },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color_mixer_channel",
            |m: &FixtureFaderControl| { &m.color_mixer_channel },
            |m: &mut FixtureFaderControl| { &mut m.color_mixer_channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generic_channel",
            |m: &FixtureFaderControl| { &m.generic_channel },
            |m: &mut FixtureFaderControl| { &mut m.generic_channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureFaderControl>(
            "FixtureFaderControl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureFaderControl {
    const NAME: &'static str = "FixtureFaderControl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.control = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.color_mixer_channel = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.generic_channel = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.control != ::protobuf::EnumOrUnknown::new(FixtureControl::INTENSITY) {
            my_size += ::protobuf::rt::int32_size(1, self.control.value());
        }
        if let Some(v) = self.color_mixer_channel {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.generic_channel.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.control != ::protobuf::EnumOrUnknown::new(FixtureControl::INTENSITY) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.control))?;
        }
        if let Some(v) = self.color_mixer_channel {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.generic_channel.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureFaderControl {
        FixtureFaderControl::new()
    }

    fn clear(&mut self) {
        self.control = ::protobuf::EnumOrUnknown::new(FixtureControl::INTENSITY);
        self.color_mixer_channel = ::std::option::Option::None;
        self.generic_channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureFaderControl {
        static instance: FixtureFaderControl = FixtureFaderControl {
            control: ::protobuf::EnumOrUnknown::from_i32(0),
            color_mixer_channel: ::std::option::Option::None,
            generic_channel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureFaderControl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureFaderControl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureFaderControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureFaderControl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FixtureFaderControl`
pub mod fixture_fader_control {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.fixtures.FixtureFaderControl.ColorMixerControlChannel)
    pub enum ColorMixerControlChannel {
        // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureFaderControl.ColorMixerControlChannel.RED)
        RED = 0,
        // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureFaderControl.ColorMixerControlChannel.GREEN)
        GREEN = 1,
        // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureFaderControl.ColorMixerControlChannel.BLUE)
        BLUE = 2,
    }

    impl ::protobuf::Enum for ColorMixerControlChannel {
        const NAME: &'static str = "ColorMixerControlChannel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ColorMixerControlChannel> {
            match value {
                0 => ::std::option::Option::Some(ColorMixerControlChannel::RED),
                1 => ::std::option::Option::Some(ColorMixerControlChannel::GREEN),
                2 => ::std::option::Option::Some(ColorMixerControlChannel::BLUE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ColorMixerControlChannel] = &[
            ColorMixerControlChannel::RED,
            ColorMixerControlChannel::GREEN,
            ColorMixerControlChannel::BLUE,
        ];
    }

    impl ::protobuf::EnumFull for ColorMixerControlChannel {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FixtureFaderControl.ColorMixerControlChannel").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ColorMixerControlChannel {
        fn default() -> Self {
            ColorMixerControlChannel::RED
        }
    }

    impl ColorMixerControlChannel {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ColorMixerControlChannel>("FixtureFaderControl.ColorMixerControlChannel")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:mizer.fixtures.FixtureControl)
pub enum FixtureControl {
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.INTENSITY)
    INTENSITY = 0,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.SHUTTER)
    SHUTTER = 1,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.COLOR_MIXER)
    COLOR_MIXER = 2,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.COLOR_WHEEL)
    COLOR_WHEEL = 3,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.PAN)
    PAN = 4,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.TILT)
    TILT = 5,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.FOCUS)
    FOCUS = 6,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.ZOOM)
    ZOOM = 7,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.PRISM)
    PRISM = 8,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.IRIS)
    IRIS = 9,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.FROST)
    FROST = 10,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.GOBO)
    GOBO = 11,
    // @@protoc_insertion_point(enum_value:mizer.fixtures.FixtureControl.GENERIC)
    GENERIC = 12,
}

impl ::protobuf::Enum for FixtureControl {
    const NAME: &'static str = "FixtureControl";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FixtureControl> {
        match value {
            0 => ::std::option::Option::Some(FixtureControl::INTENSITY),
            1 => ::std::option::Option::Some(FixtureControl::SHUTTER),
            2 => ::std::option::Option::Some(FixtureControl::COLOR_MIXER),
            3 => ::std::option::Option::Some(FixtureControl::COLOR_WHEEL),
            4 => ::std::option::Option::Some(FixtureControl::PAN),
            5 => ::std::option::Option::Some(FixtureControl::TILT),
            6 => ::std::option::Option::Some(FixtureControl::FOCUS),
            7 => ::std::option::Option::Some(FixtureControl::ZOOM),
            8 => ::std::option::Option::Some(FixtureControl::PRISM),
            9 => ::std::option::Option::Some(FixtureControl::IRIS),
            10 => ::std::option::Option::Some(FixtureControl::FROST),
            11 => ::std::option::Option::Some(FixtureControl::GOBO),
            12 => ::std::option::Option::Some(FixtureControl::GENERIC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FixtureControl] = &[
        FixtureControl::INTENSITY,
        FixtureControl::SHUTTER,
        FixtureControl::COLOR_MIXER,
        FixtureControl::COLOR_WHEEL,
        FixtureControl::PAN,
        FixtureControl::TILT,
        FixtureControl::FOCUS,
        FixtureControl::ZOOM,
        FixtureControl::PRISM,
        FixtureControl::IRIS,
        FixtureControl::FROST,
        FixtureControl::GOBO,
        FixtureControl::GENERIC,
    ];
}

impl ::protobuf::EnumFull for FixtureControl {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FixtureControl").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FixtureControl {
    fn default() -> Self {
        FixtureControl::INTENSITY
    }
}

impl FixtureControl {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FixtureControl>("FixtureControl")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0efixtures.proto\x12\x0emizer.fixtures\"g\n\x12AddFixturesRequest\
    \x12;\n\x07request\x18\x01\x20\x01(\x0b2!.mizer.fixtures.AddFixtureReque\
    stR\x07request\x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05count\"\xa6\x01\
    \n\x11AddFixtureRequest\x12#\n\rdefinition_id\x18\x01\x20\x01(\tR\x0cdef\
    initionId\x12\x12\n\x04mode\x18\x02\x20\x01(\tR\x04mode\x12\x0e\n\x02id\
    \x18\x03\x20\x01(\rR\x02id\x12\x18\n\x07channel\x18\x04\x20\x01(\rR\x07c\
    hannel\x12\x1a\n\x08universe\x18\x05\x20\x01(\rR\x08universe\x12\x12\n\
    \x04name\x18\x06\x20\x01(\tR\x04name\"\x14\n\x12GetFixturesRequest\"8\n\
    \x15DeleteFixturesRequest\x12\x1f\n\x0bfixture_ids\x18\x01\x20\x03(\rR\n\
    fixtureIds\"\xd8\x02\n\x14UpdateFixtureRequest\x12\x1d\n\nfixture_id\x18\
    \x01\x20\x01(\rR\tfixtureId\x12\"\n\ninvert_pan\x18\x02\x20\x01(\x08H\0R\
    \tinvertPan\x88\x01\x01\x12$\n\x0binvert_tilt\x18\x03\x20\x01(\x08H\x01R\
    \ninvertTilt\x88\x01\x01\x123\n\x13reverse_pixel_order\x18\x04\x20\x01(\
    \x08H\x02R\x11reversePixelOrder\x88\x01\x01\x12\x17\n\x04name\x18\x05\
    \x20\x01(\tH\x03R\x04name\x88\x01\x01\x12=\n\x07address\x18\x06\x20\x01(\
    \x0b2\x1e.mizer.fixtures.FixtureAddressH\x04R\x07address\x88\x01\x01B\r\
    \n\x0b_invert_panB\x0e\n\x0c_invert_tiltB\x16\n\x14_reverse_pixel_orderB\
    \x07\n\x05_nameB\n\n\x08_address\"F\n\x0eFixtureAddress\x12\x1a\n\x08uni\
    verse\x18\x01\x20\x01(\rR\x08universe\x12\x18\n\x07channel\x18\x02\x20\
    \x01(\rR\x07channel\"n\n\tFixtureId\x12\x1a\n\x07fixture\x18\x01\x20\x01\
    (\rH\0R\x07fixture\x12?\n\x0bsub_fixture\x18\x02\x20\x01(\x0b2\x1c.mizer\
    .fixtures.SubFixtureIdH\0R\nsubFixtureB\x04\n\x02id\"H\n\x0cSubFixtureId\
    \x12\x1d\n\nfixture_id\x18\x01\x20\x01(\rR\tfixtureId\x12\x19\n\x08child\
    _id\x18\x02\x20\x01(\rR\x07childId\"?\n\x08Fixtures\x123\n\x08fixtures\
    \x18\x01\x20\x03(\x0b2\x17.mizer.fixtures.FixtureR\x08fixtures\"\x82\x03\
    \n\x07Fixture\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04nam\
    e\x18\x02\x20\x01(\tR\x04name\x12\"\n\x0cmanufacturer\x18\x03\x20\x01(\t\
    R\x0cmanufacturer\x12\x14\n\x05model\x18\x04\x20\x01(\tR\x05model\x12\
    \x12\n\x04mode\x18\x05\x20\x01(\tR\x04mode\x12\x1a\n\x08universe\x18\x06\
    \x20\x01(\rR\x08universe\x12\x18\n\x07channel\x18\x07\x20\x01(\rR\x07cha\
    nnel\x12#\n\rchannel_count\x18\x08\x20\x01(\rR\x0cchannelCount\x12;\n\
    \x08controls\x18\t\x20\x03(\x0b2\x1f.mizer.fixtures.FixtureControlsR\x08\
    controls\x126\n\x08children\x18\n\x20\x03(\x0b2\x1a.mizer.fixtures.SubFi\
    xtureR\x08children\x125\n\x06config\x18\x0b\x20\x01(\x0b2\x1d.mizer.fixt\
    ures.FixtureConfigR\x06config\"\x7f\n\rFixtureConfig\x12\x1d\n\ninvert_p\
    an\x18\x01\x20\x01(\x08R\tinvertPan\x12\x1f\n\x0binvert_tilt\x18\x02\x20\
    \x01(\x08R\ninvertTilt\x12.\n\x13reverse_pixel_order\x18\x03\x20\x01(\
    \x08R\x11reversePixelOrder\"m\n\nSubFixture\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12;\n\x08c\
    ontrols\x18\x03\x20\x03(\x0b2\x1f.mizer.fixtures.FixtureControlsR\x08con\
    trols\"\xb8\x03\n\x0fFixtureControls\x128\n\x07control\x18\x01\x20\x01(\
    \x0e2\x1e.mizer.fixtures.FixtureControlR\x07control\x124\n\x05fader\x18\
    \x02\x20\x01(\x0b2\x1c.mizer.fixtures.FaderChannelH\0R\x05fader\x12D\n\
    \x0bcolor_mixer\x18\x03\x20\x01(\x0b2!.mizer.fixtures.ColorMixerChannelH\
    \0R\ncolorMixer\x12D\n\x0bcolor_wheel\x18\x04\x20\x01(\x0b2!.mizer.fixtu\
    res.ColorWheelChannelH\0R\ncolorWheel\x121\n\x04axis\x18\x05\x20\x01(\
    \x0b2\x1b.mizer.fixtures.AxisChannelH\0R\x04axis\x121\n\x04gobo\x18\x06\
    \x20\x01(\x0b2\x1b.mizer.fixtures.GoboChannelH\0R\x04gobo\x12:\n\x07gene\
    ric\x18\x07\x20\x01(\x0b2\x1e.mizer.fixtures.GenericChannelH\0R\x07gener\
    icB\x07\n\x05value\"$\n\x0cFaderChannel\x12\x14\n\x05value\x18\x01\x20\
    \x01(\x01R\x05value\"O\n\x11ColorMixerChannel\x12\x10\n\x03red\x18\x01\
    \x20\x01(\x01R\x03red\x12\x14\n\x05green\x18\x02\x20\x01(\x01R\x05green\
    \x12\x12\n\x04blue\x18\x03\x20\x01(\x01R\x04blue\"a\n\x11ColorWheelChann\
    el\x12\x14\n\x05value\x18\x01\x20\x01(\x01R\x05value\x126\n\x06colors\
    \x18\x02\x20\x03(\x0b2\x1e.mizer.fixtures.ColorWheelSlotR\x06colors\"R\n\
    \x0eColorWheelSlot\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\
    \n\x05value\x18\x02\x20\x01(\x01R\x05value\x12\x16\n\x06colors\x18\x03\
    \x20\x03(\tR\x06colors\"]\n\x0bAxisChannel\x12\x14\n\x05value\x18\x01\
    \x20\x01(\x01R\x05value\x12\x1d\n\nangle_from\x18\x02\x20\x01(\x01R\tang\
    leFrom\x12\x19\n\x08angle_to\x18\x03\x20\x01(\x01R\x07angleTo\"O\n\x0bGo\
    boChannel\x12\x14\n\x05value\x18\x01\x20\x01(\x01R\x05value\x12*\n\x05go\
    bos\x18\x02\x20\x03(\x0b2\x14.mizer.fixtures.GoboR\x05gobos\"g\n\x04Gobo\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x01R\x05value\x12\x12\n\x03svg\x18\x03\x20\x01(\tH\0R\x03s\
    vg\x12\x18\n\x06raster\x18\x04\x20\x01(\x0cH\0R\x06rasterB\x07\n\x05imag\
    e\":\n\x0eGenericChannel\x12\x14\n\x05value\x18\x01\x20\x01(\x01R\x05val\
    ue\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"\x1e\n\x1cGetFixtureDe\
    finitionsRequest\"Y\n\x12FixtureDefinitions\x12C\n\x0bdefinitions\x18\
    \x01\x20\x03(\x0b2!.mizer.fixtures.FixtureDefinitionR\x0bdefinitions\"\
    \xff\x01\n\x11FixtureDefinition\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02i\
    d\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\"\n\x0cmanufacturer\
    \x18\x03\x20\x01(\tR\x0cmanufacturer\x121\n\x05modes\x18\x04\x20\x03(\
    \x0b2\x1b.mizer.fixtures.FixtureModeR\x05modes\x12?\n\x08physical\x18\
    \x05\x20\x01(\x0b2#.mizer.fixtures.FixturePhysicalDataR\x08physical\x12\
    \x12\n\x04tags\x18\x06\x20\x03(\tR\x04tags\x12\x1a\n\x08provider\x18\x07\
    \x20\x01(\tR\x08provider\"]\n\x0bFixtureMode\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12:\n\x08channels\x18\x02\x20\x03(\x0b2\x1e.mizer.\
    fixtures.FixtureChannelR\x08channels\"\x9d\x04\n\x0eFixtureChannel\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12I\n\x06coarse\x18\x02\x20\
    \x01(\x0b2/.mizer.fixtures.FixtureChannel.CoarseResolutionH\0R\x06coarse\
    \x12C\n\x04fine\x18\x03\x20\x01(\x0b2-.mizer.fixtures.FixtureChannel.Fin\
    eResolutionH\0R\x04fine\x12I\n\x06finest\x18\x04\x20\x01(\x0b2/.mizer.fi\
    xtures.FixtureChannel.FinestResolutionH\0R\x06finest\x1a,\n\x10CoarseRes\
    olution\x12\x18\n\x07channel\x18\x01\x20\x01(\rR\x07channel\x1aZ\n\x0eFi\
    neResolution\x12!\n\x0cfine_channel\x18\x01\x20\x01(\rR\x0bfineChannel\
    \x12%\n\x0ecoarse_channel\x18\x02\x20\x01(\rR\rcoarseChannel\x1a\x83\x01\
    \n\x10FinestResolution\x12%\n\x0efinest_channel\x18\x01\x20\x01(\rR\rfin\
    estChannel\x12!\n\x0cfine_channel\x18\x02\x20\x01(\rR\x0bfineChannel\x12\
    %\n\x0ecoarse_channel\x18\x03\x20\x01(\rR\rcoarseChannelB\x0c\n\nresolut\
    ion\"q\n\x13FixturePhysicalData\x12\x14\n\x05width\x18\x01\x20\x01(\x02R\
    \x05width\x12\x16\n\x06height\x18\x02\x20\x01(\x02R\x06height\x12\x14\n\
    \x05depth\x18\x03\x20\x01(\x02R\x05depth\x12\x16\n\x06weight\x18\x04\x20\
    \x01(\x02R\x06weight\"\xd6\x02\n\x13FixtureFaderControl\x128\n\x07contro\
    l\x18\x01\x20\x01(\x0e2\x1e.mizer.fixtures.FixtureControlR\x07control\
    \x12q\n\x13color_mixer_channel\x18\x02\x20\x01(\x0e2<.mizer.fixtures.Fix\
    tureFaderControl.ColorMixerControlChannelH\0R\x11colorMixerChannel\x88\
    \x01\x01\x12,\n\x0fgeneric_channel\x18\x03\x20\x01(\tH\x01R\x0egenericCh\
    annel\x88\x01\x01\"8\n\x18ColorMixerControlChannel\x12\x07\n\x03RED\x10\
    \0\x12\t\n\x05GREEN\x10\x01\x12\x08\n\x04BLUE\x10\x02B\x16\n\x14_color_m\
    ixer_channelB\x12\n\x10_generic_channel*\xad\x01\n\x0eFixtureControl\x12\
    \r\n\tINTENSITY\x10\0\x12\x0b\n\x07SHUTTER\x10\x01\x12\x0f\n\x0bCOLOR_MI\
    XER\x10\x02\x12\x0f\n\x0bCOLOR_WHEEL\x10\x03\x12\x07\n\x03PAN\x10\x04\
    \x12\x08\n\x04TILT\x10\x05\x12\t\n\x05FOCUS\x10\x06\x12\x08\n\x04ZOOM\
    \x10\x07\x12\t\n\x05PRISM\x10\x08\x12\x08\n\x04IRIS\x10\t\x12\t\n\x05FRO\
    ST\x10\n\x12\x08\n\x04GOBO\x10\x0b\x12\x0b\n\x07GENERIC\x10\x0c2\xb6\x03\
    \n\x0bFixturesApi\x12K\n\x0bGetFixtures\x12\".mizer.fixtures.GetFixtures\
    Request\x1a\x18.mizer.fixtures.Fixtures\x12i\n\x15GetFixtureDefinitions\
    \x12,.mizer.fixtures.GetFixtureDefinitionsRequest\x1a\".mizer.fixtures.F\
    ixtureDefinitions\x12K\n\x0bAddFixtures\x12\".mizer.fixtures.AddFixtures\
    Request\x1a\x18.mizer.fixtures.Fixtures\x12Q\n\x0eDeleteFixtures\x12%.mi\
    zer.fixtures.DeleteFixturesRequest\x1a\x18.mizer.fixtures.Fixtures\x12O\
    \n\rUpdateFixture\x12$.mizer.fixtures.UpdateFixtureRequest\x1a\x18.mizer\
    .fixtures.Fixturesb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(31);
            messages.push(AddFixturesRequest::generated_message_descriptor_data());
            messages.push(AddFixtureRequest::generated_message_descriptor_data());
            messages.push(GetFixturesRequest::generated_message_descriptor_data());
            messages.push(DeleteFixturesRequest::generated_message_descriptor_data());
            messages.push(UpdateFixtureRequest::generated_message_descriptor_data());
            messages.push(FixtureAddress::generated_message_descriptor_data());
            messages.push(FixtureId::generated_message_descriptor_data());
            messages.push(SubFixtureId::generated_message_descriptor_data());
            messages.push(Fixtures::generated_message_descriptor_data());
            messages.push(Fixture::generated_message_descriptor_data());
            messages.push(FixtureConfig::generated_message_descriptor_data());
            messages.push(SubFixture::generated_message_descriptor_data());
            messages.push(FixtureControls::generated_message_descriptor_data());
            messages.push(FaderChannel::generated_message_descriptor_data());
            messages.push(ColorMixerChannel::generated_message_descriptor_data());
            messages.push(ColorWheelChannel::generated_message_descriptor_data());
            messages.push(ColorWheelSlot::generated_message_descriptor_data());
            messages.push(AxisChannel::generated_message_descriptor_data());
            messages.push(GoboChannel::generated_message_descriptor_data());
            messages.push(Gobo::generated_message_descriptor_data());
            messages.push(GenericChannel::generated_message_descriptor_data());
            messages.push(GetFixtureDefinitionsRequest::generated_message_descriptor_data());
            messages.push(FixtureDefinitions::generated_message_descriptor_data());
            messages.push(FixtureDefinition::generated_message_descriptor_data());
            messages.push(FixtureMode::generated_message_descriptor_data());
            messages.push(FixtureChannel::generated_message_descriptor_data());
            messages.push(FixturePhysicalData::generated_message_descriptor_data());
            messages.push(FixtureFaderControl::generated_message_descriptor_data());
            messages.push(fixture_channel::CoarseResolution::generated_message_descriptor_data());
            messages.push(fixture_channel::FineResolution::generated_message_descriptor_data());
            messages.push(fixture_channel::FinestResolution::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(FixtureControl::generated_enum_descriptor_data());
            enums.push(fixture_fader_control::ColorMixerControlChannel::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
