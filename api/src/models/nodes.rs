// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `nodes.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.AddNodeRequest)
pub struct AddNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.AddNodeRequest.type)
    pub type_: ::protobuf::EnumOrUnknown<node::NodeType>,
    // @@protoc_insertion_point(field:mizer.nodes.AddNodeRequest.position)
    pub position: ::protobuf::MessageField<NodePosition>,
    // @@protoc_insertion_point(field:mizer.nodes.AddNodeRequest.parent)
    pub parent: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.AddNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddNodeRequest {
    fn default() -> &'a AddNodeRequest {
        <AddNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddNodeRequest {
    pub fn new() -> AddNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &AddNodeRequest| { &m.type_ },
            |m: &mut AddNodeRequest| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodePosition>(
            "position",
            |m: &AddNodeRequest| { &m.position },
            |m: &mut AddNodeRequest| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &AddNodeRequest| { &m.parent },
            |m: &mut AddNodeRequest| { &mut m.parent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddNodeRequest>(
            "AddNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddNodeRequest {
    const NAME: &'static str = "AddNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                26 => {
                    self.parent = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::Fader) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.parent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::Fader) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.parent.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddNodeRequest {
        AddNodeRequest::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(node::NodeType::Fader);
        self.position.clear();
        self.parent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddNodeRequest {
        static instance: AddNodeRequest = AddNodeRequest {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            position: ::protobuf::MessageField::none(),
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.DuplicateNodeRequest)
pub struct DuplicateNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.DuplicateNodeRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.DuplicateNodeRequest.parent)
    pub parent: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.DuplicateNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DuplicateNodeRequest {
    fn default() -> &'a DuplicateNodeRequest {
        <DuplicateNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DuplicateNodeRequest {
    pub fn new() -> DuplicateNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &DuplicateNodeRequest| { &m.path },
            |m: &mut DuplicateNodeRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &DuplicateNodeRequest| { &m.parent },
            |m: &mut DuplicateNodeRequest| { &mut m.parent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DuplicateNodeRequest>(
            "DuplicateNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DuplicateNodeRequest {
    const NAME: &'static str = "DuplicateNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.parent = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(v) = self.parent.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(v) = self.parent.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DuplicateNodeRequest {
        DuplicateNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.parent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DuplicateNodeRequest {
        static instance: DuplicateNodeRequest = DuplicateNodeRequest {
            path: ::std::string::String::new(),
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DuplicateNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DuplicateNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DuplicateNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DuplicateNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodesRequest)
pub struct NodesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodesRequest {
    fn default() -> &'a NodesRequest {
        <NodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl NodesRequest {
    pub fn new() -> NodesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodesRequest>(
            "NodesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodesRequest {
    const NAME: &'static str = "NodesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodesRequest {
        NodesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodesRequest {
        static instance: NodesRequest = NodesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.WriteControl)
pub struct WriteControl {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.WriteControl.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.WriteControl.port)
    pub port: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.WriteControl.value)
    pub value: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.WriteControl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteControl {
    fn default() -> &'a WriteControl {
        <WriteControl as ::protobuf::Message>::default_instance()
    }
}

impl WriteControl {
    pub fn new() -> WriteControl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &WriteControl| { &m.path },
            |m: &mut WriteControl| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &WriteControl| { &m.port },
            |m: &mut WriteControl| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &WriteControl| { &m.value },
            |m: &mut WriteControl| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteControl>(
            "WriteControl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteControl {
    const NAME: &'static str = "WriteControl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.port = is.read_string()?;
                },
                25 => {
                    self.value = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.port.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.port);
        }
        if self.value != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.port.is_empty() {
            os.write_string(2, &self.port)?;
        }
        if self.value != 0. {
            os.write_double(3, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteControl {
        WriteControl::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.port.clear();
        self.value = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteControl {
        static instance: WriteControl = WriteControl {
            path: ::std::string::String::new(),
            port: ::std::string::String::new(),
            value: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteControl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteControl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteControl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.WriteResponse)
pub struct WriteResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.WriteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteResponse {
    fn default() -> &'a WriteResponse {
        <WriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteResponse {
    pub fn new() -> WriteResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteResponse>(
            "WriteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteResponse {
    const NAME: &'static str = "WriteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteResponse {
        WriteResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteResponse {
        static instance: WriteResponse = WriteResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.UpdateNodeConfigRequest)
pub struct UpdateNodeConfigRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.UpdateNodeConfigRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.UpdateNodeConfigRequest.config)
    pub config: ::protobuf::MessageField<NodeConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.UpdateNodeConfigRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateNodeConfigRequest {
    fn default() -> &'a UpdateNodeConfigRequest {
        <UpdateNodeConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNodeConfigRequest {
    pub fn new() -> UpdateNodeConfigRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &UpdateNodeConfigRequest| { &m.path },
            |m: &mut UpdateNodeConfigRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeConfig>(
            "config",
            |m: &UpdateNodeConfigRequest| { &m.config },
            |m: &mut UpdateNodeConfigRequest| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateNodeConfigRequest>(
            "UpdateNodeConfigRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateNodeConfigRequest {
    const NAME: &'static str = "UpdateNodeConfigRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateNodeConfigRequest {
        UpdateNodeConfigRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateNodeConfigRequest {
        static instance: UpdateNodeConfigRequest = UpdateNodeConfigRequest {
            path: ::std::string::String::new(),
            config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateNodeConfigRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateNodeConfigRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateNodeConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNodeConfigRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.UpdateNodeConfigResponse)
pub struct UpdateNodeConfigResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.UpdateNodeConfigResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateNodeConfigResponse {
    fn default() -> &'a UpdateNodeConfigResponse {
        <UpdateNodeConfigResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNodeConfigResponse {
    pub fn new() -> UpdateNodeConfigResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateNodeConfigResponse>(
            "UpdateNodeConfigResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateNodeConfigResponse {
    const NAME: &'static str = "UpdateNodeConfigResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateNodeConfigResponse {
        UpdateNodeConfigResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateNodeConfigResponse {
        static instance: UpdateNodeConfigResponse = UpdateNodeConfigResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateNodeConfigResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateNodeConfigResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateNodeConfigResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNodeConfigResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MoveNodeRequest)
pub struct MoveNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.MoveNodeRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.MoveNodeRequest.position)
    pub position: ::protobuf::MessageField<NodePosition>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MoveNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveNodeRequest {
    fn default() -> &'a MoveNodeRequest {
        <MoveNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoveNodeRequest {
    pub fn new() -> MoveNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &MoveNodeRequest| { &m.path },
            |m: &mut MoveNodeRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodePosition>(
            "position",
            |m: &MoveNodeRequest| { &m.position },
            |m: &mut MoveNodeRequest| { &mut m.position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveNodeRequest>(
            "MoveNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveNodeRequest {
    const NAME: &'static str = "MoveNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveNodeRequest {
        MoveNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.position.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveNodeRequest {
        static instance: MoveNodeRequest = MoveNodeRequest {
            path: ::std::string::String::new(),
            position: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MoveNodeResponse)
pub struct MoveNodeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MoveNodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveNodeResponse {
    fn default() -> &'a MoveNodeResponse {
        <MoveNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MoveNodeResponse {
    pub fn new() -> MoveNodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveNodeResponse>(
            "MoveNodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveNodeResponse {
    const NAME: &'static str = "MoveNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveNodeResponse {
        MoveNodeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveNodeResponse {
        static instance: MoveNodeResponse = MoveNodeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveNodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveNodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveNodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ShowNodeRequest)
pub struct ShowNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.ShowNodeRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.ShowNodeRequest.position)
    pub position: ::protobuf::MessageField<NodePosition>,
    // @@protoc_insertion_point(field:mizer.nodes.ShowNodeRequest.parent)
    pub parent: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ShowNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShowNodeRequest {
    fn default() -> &'a ShowNodeRequest {
        <ShowNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ShowNodeRequest {
    pub fn new() -> ShowNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ShowNodeRequest| { &m.path },
            |m: &mut ShowNodeRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodePosition>(
            "position",
            |m: &ShowNodeRequest| { &m.position },
            |m: &mut ShowNodeRequest| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &ShowNodeRequest| { &m.parent },
            |m: &mut ShowNodeRequest| { &mut m.parent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShowNodeRequest>(
            "ShowNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShowNodeRequest {
    const NAME: &'static str = "ShowNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                26 => {
                    self.parent = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.parent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.parent.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShowNodeRequest {
        ShowNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.position.clear();
        self.parent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShowNodeRequest {
        static instance: ShowNodeRequest = ShowNodeRequest {
            path: ::std::string::String::new(),
            position: ::protobuf::MessageField::none(),
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShowNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShowNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShowNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShowNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ShowNodeResponse)
pub struct ShowNodeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ShowNodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShowNodeResponse {
    fn default() -> &'a ShowNodeResponse {
        <ShowNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ShowNodeResponse {
    pub fn new() -> ShowNodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShowNodeResponse>(
            "ShowNodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShowNodeResponse {
    const NAME: &'static str = "ShowNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShowNodeResponse {
        ShowNodeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShowNodeResponse {
        static instance: ShowNodeResponse = ShowNodeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShowNodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShowNodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShowNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShowNodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.DeleteNodeRequest)
pub struct DeleteNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.DeleteNodeRequest.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.DeleteNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteNodeRequest {
    fn default() -> &'a DeleteNodeRequest {
        <DeleteNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNodeRequest {
    pub fn new() -> DeleteNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &DeleteNodeRequest| { &m.path },
            |m: &mut DeleteNodeRequest| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteNodeRequest>(
            "DeleteNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteNodeRequest {
    const NAME: &'static str = "DeleteNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteNodeRequest {
        DeleteNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteNodeRequest {
        static instance: DeleteNodeRequest = DeleteNodeRequest {
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.DeleteNodeResponse)
pub struct DeleteNodeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.DeleteNodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteNodeResponse {
    fn default() -> &'a DeleteNodeResponse {
        <DeleteNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNodeResponse {
    pub fn new() -> DeleteNodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteNodeResponse>(
            "DeleteNodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteNodeResponse {
    const NAME: &'static str = "DeleteNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteNodeResponse {
        DeleteNodeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteNodeResponse {
        static instance: DeleteNodeResponse = DeleteNodeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteNodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteNodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.HideNodeRequest)
pub struct HideNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.HideNodeRequest.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.HideNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HideNodeRequest {
    fn default() -> &'a HideNodeRequest {
        <HideNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl HideNodeRequest {
    pub fn new() -> HideNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &HideNodeRequest| { &m.path },
            |m: &mut HideNodeRequest| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HideNodeRequest>(
            "HideNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HideNodeRequest {
    const NAME: &'static str = "HideNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HideNodeRequest {
        HideNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HideNodeRequest {
        static instance: HideNodeRequest = HideNodeRequest {
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HideNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HideNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HideNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HideNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.HideNodeResponse)
pub struct HideNodeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.HideNodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HideNodeResponse {
    fn default() -> &'a HideNodeResponse {
        <HideNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl HideNodeResponse {
    pub fn new() -> HideNodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HideNodeResponse>(
            "HideNodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HideNodeResponse {
    const NAME: &'static str = "HideNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HideNodeResponse {
        HideNodeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HideNodeResponse {
        static instance: HideNodeResponse = HideNodeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HideNodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HideNodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HideNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HideNodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.Nodes)
pub struct Nodes {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.Nodes.nodes)
    pub nodes: ::std::vec::Vec<Node>,
    // @@protoc_insertion_point(field:mizer.nodes.Nodes.channels)
    pub channels: ::std::vec::Vec<NodeConnection>,
    // @@protoc_insertion_point(field:mizer.nodes.Nodes.all_nodes)
    pub all_nodes: ::std::vec::Vec<Node>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.Nodes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Nodes {
    fn default() -> &'a Nodes {
        <Nodes as ::protobuf::Message>::default_instance()
    }
}

impl Nodes {
    pub fn new() -> Nodes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &Nodes| { &m.nodes },
            |m: &mut Nodes| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels",
            |m: &Nodes| { &m.channels },
            |m: &mut Nodes| { &mut m.channels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "all_nodes",
            |m: &Nodes| { &m.all_nodes },
            |m: &mut Nodes| { &mut m.all_nodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Nodes>(
            "Nodes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Nodes {
    const NAME: &'static str = "Nodes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nodes.push(is.read_message()?);
                },
                18 => {
                    self.channels.push(is.read_message()?);
                },
                26 => {
                    self.all_nodes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.all_nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.all_nodes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Nodes {
        Nodes::new()
    }

    fn clear(&mut self) {
        self.nodes.clear();
        self.channels.clear();
        self.all_nodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Nodes {
        static instance: Nodes = Nodes {
            nodes: ::std::vec::Vec::new(),
            channels: ::std::vec::Vec::new(),
            all_nodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Nodes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Nodes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Nodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Nodes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodeConnection)
pub struct NodeConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.targetNode)
    pub targetNode: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.targetPort)
    pub targetPort: ::protobuf::MessageField<Port>,
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.sourceNode)
    pub sourceNode: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.sourcePort)
    pub sourcePort: ::protobuf::MessageField<Port>,
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.protocol)
    pub protocol: ::protobuf::EnumOrUnknown<ChannelProtocol>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodeConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeConnection {
    fn default() -> &'a NodeConnection {
        <NodeConnection as ::protobuf::Message>::default_instance()
    }
}

impl NodeConnection {
    pub fn new() -> NodeConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "targetNode",
            |m: &NodeConnection| { &m.targetNode },
            |m: &mut NodeConnection| { &mut m.targetNode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Port>(
            "targetPort",
            |m: &NodeConnection| { &m.targetPort },
            |m: &mut NodeConnection| { &mut m.targetPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sourceNode",
            |m: &NodeConnection| { &m.sourceNode },
            |m: &mut NodeConnection| { &mut m.sourceNode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Port>(
            "sourcePort",
            |m: &NodeConnection| { &m.sourcePort },
            |m: &mut NodeConnection| { &mut m.sourcePort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol",
            |m: &NodeConnection| { &m.protocol },
            |m: &mut NodeConnection| { &mut m.protocol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeConnection>(
            "NodeConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeConnection {
    const NAME: &'static str = "NodeConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.targetNode = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.targetPort)?;
                },
                26 => {
                    self.sourceNode = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sourcePort)?;
                },
                40 => {
                    self.protocol = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.targetNode.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.targetNode);
        }
        if let Some(v) = self.targetPort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.sourceNode.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sourceNode);
        }
        if let Some(v) = self.sourcePort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE) {
            my_size += ::protobuf::rt::int32_size(5, self.protocol.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.targetNode.is_empty() {
            os.write_string(1, &self.targetNode)?;
        }
        if let Some(v) = self.targetPort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.sourceNode.is_empty() {
            os.write_string(3, &self.sourceNode)?;
        }
        if let Some(v) = self.sourcePort.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.protocol))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeConnection {
        NodeConnection::new()
    }

    fn clear(&mut self) {
        self.targetNode.clear();
        self.targetPort.clear();
        self.sourceNode.clear();
        self.sourcePort.clear();
        self.protocol = ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeConnection {
        static instance: NodeConnection = NodeConnection {
            targetNode: ::std::string::String::new(),
            targetPort: ::protobuf::MessageField::none(),
            sourceNode: ::std::string::String::new(),
            sourcePort: ::protobuf::MessageField::none(),
            protocol: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.Node)
pub struct Node {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.Node.type)
    pub type_: ::protobuf::EnumOrUnknown<node::NodeType>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.Node.inputs)
    pub inputs: ::std::vec::Vec<Port>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.outputs)
    pub outputs: ::std::vec::Vec<Port>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.designer)
    pub designer: ::protobuf::MessageField<NodeDesigner>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.preview)
    pub preview: ::protobuf::EnumOrUnknown<node::NodePreviewType>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.config)
    pub config: ::protobuf::MessageField<NodeConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.Node.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Node| { &m.type_ },
            |m: &mut Node| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &Node| { &m.path },
            |m: &mut Node| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &Node| { &m.inputs },
            |m: &mut Node| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &Node| { &m.outputs },
            |m: &mut Node| { &mut m.outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeDesigner>(
            "designer",
            |m: &Node| { &m.designer },
            |m: &mut Node| { &mut m.designer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preview",
            |m: &Node| { &m.preview },
            |m: &mut Node| { &mut m.preview },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeConfig>(
            "config",
            |m: &Node| { &m.config },
            |m: &mut Node| { &mut m.config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Node>(
            "Node",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Node {
    const NAME: &'static str = "Node";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                26 => {
                    self.inputs.push(is.read_message()?);
                },
                34 => {
                    self.outputs.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.designer)?;
                },
                48 => {
                    self.preview = is.read_enum_or_unknown()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::Fader) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.designer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.preview != ::protobuf::EnumOrUnknown::new(node::NodePreviewType::History) {
            my_size += ::protobuf::rt::int32_size(6, self.preview.value());
        }
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::Fader) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.designer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.preview != ::protobuf::EnumOrUnknown::new(node::NodePreviewType::History) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.preview))?;
        }
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Node {
        Node::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(node::NodeType::Fader);
        self.path.clear();
        self.inputs.clear();
        self.outputs.clear();
        self.designer.clear();
        self.preview = ::protobuf::EnumOrUnknown::new(node::NodePreviewType::History);
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Node {
        static instance: Node = Node {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            path: ::std::string::String::new(),
            inputs: ::std::vec::Vec::new(),
            outputs: ::std::vec::Vec::new(),
            designer: ::protobuf::MessageField::none(),
            preview: ::protobuf::EnumOrUnknown::from_i32(0),
            config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Node {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Node").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Node`
pub mod node {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.Node.NodeType)
    pub enum NodeType {
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Fader)
        Fader = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Button)
        Button = 1,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Oscillator)
        Oscillator = 2,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Clock)
        Clock = 3,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Script)
        Script = 4,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Envelope)
        Envelope = 5,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Sequence)
        Sequence = 6,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Select)
        Select = 7,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Merge)
        Merge = 8,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Threshold)
        Threshold = 9,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.DmxOutput)
        DmxOutput = 10,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.OscInput)
        OscInput = 11,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.OscOutput)
        OscOutput = 12,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MidiInput)
        MidiInput = 13,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MidiOutput)
        MidiOutput = 14,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Sequencer)
        Sequencer = 15,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Fixture)
        Fixture = 16,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Programmer)
        Programmer = 17,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Group)
        Group = 18,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Preset)
        Preset = 19,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VideoFile)
        VideoFile = 20,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VideoOutput)
        VideoOutput = 21,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VideoEffect)
        VideoEffect = 22,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VideoColorBalance)
        VideoColorBalance = 23,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VideoTransform)
        VideoTransform = 24,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.PixelToDmx)
        PixelToDmx = 30,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.PixelPattern)
        PixelPattern = 31,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.OpcOutput)
        OpcOutput = 32,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Laser)
        Laser = 40,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.IldaFile)
        IldaFile = 41,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Gamepad)
        Gamepad = 45,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.ColorRgb)
        ColorRgb = 50,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.ColorHsv)
        ColorHsv = 51,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Container)
        Container = 100,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Encoder)
        Encoder = 55,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Math)
        Math = 56,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.DataToNumber)
        DataToNumber = 57,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.NumberToData)
        NumberToData = 58,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Value)
        Value = 59,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MqttInput)
        MqttInput = 60,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MqttOutput)
        MqttOutput = 61,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.PlanScreen)
        PlanScreen = 62,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Delay)
        Delay = 63,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Ramp)
        Ramp = 64,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Noise)
        Noise = 65,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Label)
        Label = 66,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.Transport)
        Transport = 67,
    }

    impl ::protobuf::Enum for NodeType {
        const NAME: &'static str = "NodeType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NodeType> {
            match value {
                0 => ::std::option::Option::Some(NodeType::Fader),
                1 => ::std::option::Option::Some(NodeType::Button),
                2 => ::std::option::Option::Some(NodeType::Oscillator),
                3 => ::std::option::Option::Some(NodeType::Clock),
                4 => ::std::option::Option::Some(NodeType::Script),
                5 => ::std::option::Option::Some(NodeType::Envelope),
                6 => ::std::option::Option::Some(NodeType::Sequence),
                7 => ::std::option::Option::Some(NodeType::Select),
                8 => ::std::option::Option::Some(NodeType::Merge),
                9 => ::std::option::Option::Some(NodeType::Threshold),
                10 => ::std::option::Option::Some(NodeType::DmxOutput),
                11 => ::std::option::Option::Some(NodeType::OscInput),
                12 => ::std::option::Option::Some(NodeType::OscOutput),
                13 => ::std::option::Option::Some(NodeType::MidiInput),
                14 => ::std::option::Option::Some(NodeType::MidiOutput),
                15 => ::std::option::Option::Some(NodeType::Sequencer),
                16 => ::std::option::Option::Some(NodeType::Fixture),
                17 => ::std::option::Option::Some(NodeType::Programmer),
                18 => ::std::option::Option::Some(NodeType::Group),
                19 => ::std::option::Option::Some(NodeType::Preset),
                20 => ::std::option::Option::Some(NodeType::VideoFile),
                21 => ::std::option::Option::Some(NodeType::VideoOutput),
                22 => ::std::option::Option::Some(NodeType::VideoEffect),
                23 => ::std::option::Option::Some(NodeType::VideoColorBalance),
                24 => ::std::option::Option::Some(NodeType::VideoTransform),
                30 => ::std::option::Option::Some(NodeType::PixelToDmx),
                31 => ::std::option::Option::Some(NodeType::PixelPattern),
                32 => ::std::option::Option::Some(NodeType::OpcOutput),
                40 => ::std::option::Option::Some(NodeType::Laser),
                41 => ::std::option::Option::Some(NodeType::IldaFile),
                45 => ::std::option::Option::Some(NodeType::Gamepad),
                50 => ::std::option::Option::Some(NodeType::ColorRgb),
                51 => ::std::option::Option::Some(NodeType::ColorHsv),
                100 => ::std::option::Option::Some(NodeType::Container),
                55 => ::std::option::Option::Some(NodeType::Encoder),
                56 => ::std::option::Option::Some(NodeType::Math),
                57 => ::std::option::Option::Some(NodeType::DataToNumber),
                58 => ::std::option::Option::Some(NodeType::NumberToData),
                59 => ::std::option::Option::Some(NodeType::Value),
                60 => ::std::option::Option::Some(NodeType::MqttInput),
                61 => ::std::option::Option::Some(NodeType::MqttOutput),
                62 => ::std::option::Option::Some(NodeType::PlanScreen),
                63 => ::std::option::Option::Some(NodeType::Delay),
                64 => ::std::option::Option::Some(NodeType::Ramp),
                65 => ::std::option::Option::Some(NodeType::Noise),
                66 => ::std::option::Option::Some(NodeType::Label),
                67 => ::std::option::Option::Some(NodeType::Transport),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NodeType] = &[
            NodeType::Fader,
            NodeType::Button,
            NodeType::Oscillator,
            NodeType::Clock,
            NodeType::Script,
            NodeType::Envelope,
            NodeType::Sequence,
            NodeType::Select,
            NodeType::Merge,
            NodeType::Threshold,
            NodeType::DmxOutput,
            NodeType::OscInput,
            NodeType::OscOutput,
            NodeType::MidiInput,
            NodeType::MidiOutput,
            NodeType::Sequencer,
            NodeType::Fixture,
            NodeType::Programmer,
            NodeType::Group,
            NodeType::Preset,
            NodeType::VideoFile,
            NodeType::VideoOutput,
            NodeType::VideoEffect,
            NodeType::VideoColorBalance,
            NodeType::VideoTransform,
            NodeType::PixelToDmx,
            NodeType::PixelPattern,
            NodeType::OpcOutput,
            NodeType::Laser,
            NodeType::IldaFile,
            NodeType::Gamepad,
            NodeType::ColorRgb,
            NodeType::ColorHsv,
            NodeType::Container,
            NodeType::Encoder,
            NodeType::Math,
            NodeType::DataToNumber,
            NodeType::NumberToData,
            NodeType::Value,
            NodeType::MqttInput,
            NodeType::MqttOutput,
            NodeType::PlanScreen,
            NodeType::Delay,
            NodeType::Ramp,
            NodeType::Noise,
            NodeType::Label,
            NodeType::Transport,
        ];
    }

    impl ::protobuf::EnumFull for NodeType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Node.NodeType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                NodeType::Fader => 0,
                NodeType::Button => 1,
                NodeType::Oscillator => 2,
                NodeType::Clock => 3,
                NodeType::Script => 4,
                NodeType::Envelope => 5,
                NodeType::Sequence => 6,
                NodeType::Select => 7,
                NodeType::Merge => 8,
                NodeType::Threshold => 9,
                NodeType::DmxOutput => 10,
                NodeType::OscInput => 11,
                NodeType::OscOutput => 12,
                NodeType::MidiInput => 13,
                NodeType::MidiOutput => 14,
                NodeType::Sequencer => 15,
                NodeType::Fixture => 16,
                NodeType::Programmer => 17,
                NodeType::Group => 18,
                NodeType::Preset => 19,
                NodeType::VideoFile => 20,
                NodeType::VideoOutput => 21,
                NodeType::VideoEffect => 22,
                NodeType::VideoColorBalance => 23,
                NodeType::VideoTransform => 24,
                NodeType::PixelToDmx => 25,
                NodeType::PixelPattern => 26,
                NodeType::OpcOutput => 27,
                NodeType::Laser => 28,
                NodeType::IldaFile => 29,
                NodeType::Gamepad => 30,
                NodeType::ColorRgb => 31,
                NodeType::ColorHsv => 32,
                NodeType::Container => 33,
                NodeType::Encoder => 34,
                NodeType::Math => 35,
                NodeType::DataToNumber => 36,
                NodeType::NumberToData => 37,
                NodeType::Value => 38,
                NodeType::MqttInput => 39,
                NodeType::MqttOutput => 40,
                NodeType::PlanScreen => 41,
                NodeType::Delay => 42,
                NodeType::Ramp => 43,
                NodeType::Noise => 44,
                NodeType::Label => 45,
                NodeType::Transport => 46,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for NodeType {
        fn default() -> Self {
            NodeType::Fader
        }
    }

    impl NodeType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NodeType>("Node.NodeType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.Node.NodePreviewType)
    pub enum NodePreviewType {
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.History)
        History = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.Waveform)
        Waveform = 1,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.Multiple)
        Multiple = 2,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.Texture)
        Texture = 3,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.None)
        None = 4,
    }

    impl ::protobuf::Enum for NodePreviewType {
        const NAME: &'static str = "NodePreviewType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NodePreviewType> {
            match value {
                0 => ::std::option::Option::Some(NodePreviewType::History),
                1 => ::std::option::Option::Some(NodePreviewType::Waveform),
                2 => ::std::option::Option::Some(NodePreviewType::Multiple),
                3 => ::std::option::Option::Some(NodePreviewType::Texture),
                4 => ::std::option::Option::Some(NodePreviewType::None),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NodePreviewType] = &[
            NodePreviewType::History,
            NodePreviewType::Waveform,
            NodePreviewType::Multiple,
            NodePreviewType::Texture,
            NodePreviewType::None,
        ];
    }

    impl ::protobuf::EnumFull for NodePreviewType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Node.NodePreviewType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for NodePreviewType {
        fn default() -> Self {
            NodePreviewType::History
        }
    }

    impl NodePreviewType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NodePreviewType>("Node.NodePreviewType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodeConfig)
pub struct NodeConfig {
    // message oneof groups
    pub type_: ::std::option::Option<node_config::Type>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeConfig {
    fn default() -> &'a NodeConfig {
        <NodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl NodeConfig {
    pub fn new() -> NodeConfig {
        ::std::default::Default::default()
    }

    // .mizer.nodes.OscillatorNodeConfig oscillatorConfig = 10;

    pub fn oscillatorConfig(&self) -> &OscillatorNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OscillatorConfig(ref v)) => v,
            _ => <OscillatorNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_oscillatorConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_oscillatorConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OscillatorConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oscillatorConfig(&mut self, v: OscillatorNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::OscillatorConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oscillatorConfig(&mut self) -> &mut OscillatorNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::OscillatorConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::OscillatorConfig(OscillatorNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OscillatorConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oscillatorConfig(&mut self) -> OscillatorNodeConfig {
        if self.has_oscillatorConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::OscillatorConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            OscillatorNodeConfig::new()
        }
    }

    // .mizer.nodes.ScriptingNodeConfig scriptingConfig = 11;

    pub fn scriptingConfig(&self) -> &ScriptingNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ScriptingConfig(ref v)) => v,
            _ => <ScriptingNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_scriptingConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_scriptingConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ScriptingConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scriptingConfig(&mut self, v: ScriptingNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ScriptingConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_scriptingConfig(&mut self) -> &mut ScriptingNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ScriptingConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ScriptingConfig(ScriptingNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ScriptingConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_scriptingConfig(&mut self) -> ScriptingNodeConfig {
        if self.has_scriptingConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ScriptingConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptingNodeConfig::new()
        }
    }

    // .mizer.nodes.SequenceNodeConfig sequenceConfig = 12;

    pub fn sequenceConfig(&self) -> &SequenceNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::SequenceConfig(ref v)) => v,
            _ => <SequenceNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sequenceConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_sequenceConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::SequenceConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sequenceConfig(&mut self, v: SequenceNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::SequenceConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sequenceConfig(&mut self) -> &mut SequenceNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::SequenceConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::SequenceConfig(SequenceNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::SequenceConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sequenceConfig(&mut self) -> SequenceNodeConfig {
        if self.has_sequenceConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::SequenceConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            SequenceNodeConfig::new()
        }
    }

    // .mizer.nodes.ClockNodeConfig clockConfig = 13;

    pub fn clockConfig(&self) -> &ClockNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ClockConfig(ref v)) => v,
            _ => <ClockNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_clockConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_clockConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ClockConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clockConfig(&mut self, v: ClockNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ClockConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clockConfig(&mut self) -> &mut ClockNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ClockConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ClockConfig(ClockNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ClockConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clockConfig(&mut self) -> ClockNodeConfig {
        if self.has_clockConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ClockConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ClockNodeConfig::new()
        }
    }

    // .mizer.nodes.FixtureNodeConfig fixtureConfig = 14;

    pub fn fixtureConfig(&self) -> &FixtureNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::FixtureConfig(ref v)) => v,
            _ => <FixtureNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fixtureConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_fixtureConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::FixtureConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixtureConfig(&mut self, v: FixtureNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::FixtureConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fixtureConfig(&mut self) -> &mut FixtureNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::FixtureConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::FixtureConfig(FixtureNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::FixtureConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fixtureConfig(&mut self) -> FixtureNodeConfig {
        if self.has_fixtureConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::FixtureConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            FixtureNodeConfig::new()
        }
    }

    // .mizer.nodes.ButtonNodeConfig buttonConfig = 15;

    pub fn buttonConfig(&self) -> &ButtonNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ButtonConfig(ref v)) => v,
            _ => <ButtonNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_buttonConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_buttonConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ButtonConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_buttonConfig(&mut self, v: ButtonNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ButtonConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_buttonConfig(&mut self) -> &mut ButtonNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ButtonConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ButtonConfig(ButtonNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ButtonConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_buttonConfig(&mut self) -> ButtonNodeConfig {
        if self.has_buttonConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ButtonConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ButtonNodeConfig::new()
        }
    }

    // .mizer.nodes.FaderNodeConfig faderConfig = 16;

    pub fn faderConfig(&self) -> &FaderNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::FaderConfig(ref v)) => v,
            _ => <FaderNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_faderConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_faderConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::FaderConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_faderConfig(&mut self, v: FaderNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::FaderConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_faderConfig(&mut self) -> &mut FaderNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::FaderConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::FaderConfig(FaderNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::FaderConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_faderConfig(&mut self) -> FaderNodeConfig {
        if self.has_faderConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::FaderConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            FaderNodeConfig::new()
        }
    }

    // .mizer.nodes.IldaFileNodeConfig ildaFileConfig = 17;

    pub fn ildaFileConfig(&self) -> &IldaFileNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::IldaFileConfig(ref v)) => v,
            _ => <IldaFileNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ildaFileConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_ildaFileConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::IldaFileConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ildaFileConfig(&mut self, v: IldaFileNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::IldaFileConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ildaFileConfig(&mut self) -> &mut IldaFileNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::IldaFileConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::IldaFileConfig(IldaFileNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::IldaFileConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ildaFileConfig(&mut self) -> IldaFileNodeConfig {
        if self.has_ildaFileConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::IldaFileConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            IldaFileNodeConfig::new()
        }
    }

    // .mizer.nodes.LaserNodeConfig laserConfig = 18;

    pub fn laserConfig(&self) -> &LaserNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::LaserConfig(ref v)) => v,
            _ => <LaserNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_laserConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_laserConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::LaserConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_laserConfig(&mut self, v: LaserNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::LaserConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_laserConfig(&mut self) -> &mut LaserNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::LaserConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::LaserConfig(LaserNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::LaserConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_laserConfig(&mut self) -> LaserNodeConfig {
        if self.has_laserConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::LaserConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            LaserNodeConfig::new()
        }
    }

    // .mizer.nodes.PixelPatternNodeConfig pixelPatternConfig = 19;

    pub fn pixelPatternConfig(&self) -> &PixelPatternNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PixelPatternConfig(ref v)) => v,
            _ => <PixelPatternNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pixelPatternConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_pixelPatternConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PixelPatternConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pixelPatternConfig(&mut self, v: PixelPatternNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::PixelPatternConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pixelPatternConfig(&mut self) -> &mut PixelPatternNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::PixelPatternConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::PixelPatternConfig(PixelPatternNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PixelPatternConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pixelPatternConfig(&mut self) -> PixelPatternNodeConfig {
        if self.has_pixelPatternConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::PixelPatternConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            PixelPatternNodeConfig::new()
        }
    }

    // .mizer.nodes.PixelDmxNodeConfig pixelDmxConfig = 20;

    pub fn pixelDmxConfig(&self) -> &PixelDmxNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PixelDmxConfig(ref v)) => v,
            _ => <PixelDmxNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pixelDmxConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_pixelDmxConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PixelDmxConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pixelDmxConfig(&mut self, v: PixelDmxNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::PixelDmxConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pixelDmxConfig(&mut self) -> &mut PixelDmxNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::PixelDmxConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::PixelDmxConfig(PixelDmxNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PixelDmxConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pixelDmxConfig(&mut self) -> PixelDmxNodeConfig {
        if self.has_pixelDmxConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::PixelDmxConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            PixelDmxNodeConfig::new()
        }
    }

    // .mizer.nodes.DmxOutputNodeConfig dmxOutputConfig = 21;

    pub fn dmxOutputConfig(&self) -> &DmxOutputNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::DmxOutputConfig(ref v)) => v,
            _ => <DmxOutputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dmxOutputConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_dmxOutputConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::DmxOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dmxOutputConfig(&mut self, v: DmxOutputNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::DmxOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dmxOutputConfig(&mut self) -> &mut DmxOutputNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::DmxOutputConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::DmxOutputConfig(DmxOutputNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::DmxOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dmxOutputConfig(&mut self) -> DmxOutputNodeConfig {
        if self.has_dmxOutputConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::DmxOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            DmxOutputNodeConfig::new()
        }
    }

    // .mizer.nodes.MidiNodeConfig midiInputConfig = 22;

    pub fn midiInputConfig(&self) -> &MidiNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MidiInputConfig(ref v)) => v,
            _ => <MidiNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_midiInputConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_midiInputConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MidiInputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_midiInputConfig(&mut self, v: MidiNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::MidiInputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_midiInputConfig(&mut self) -> &mut MidiNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::MidiInputConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::MidiInputConfig(MidiNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MidiInputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_midiInputConfig(&mut self) -> MidiNodeConfig {
        if self.has_midiInputConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::MidiInputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            MidiNodeConfig::new()
        }
    }

    // .mizer.nodes.MidiNodeConfig midiOutputConfig = 23;

    pub fn midiOutputConfig(&self) -> &MidiNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MidiOutputConfig(ref v)) => v,
            _ => <MidiNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_midiOutputConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_midiOutputConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MidiOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_midiOutputConfig(&mut self, v: MidiNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::MidiOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_midiOutputConfig(&mut self) -> &mut MidiNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::MidiOutputConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::MidiOutputConfig(MidiNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MidiOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_midiOutputConfig(&mut self) -> MidiNodeConfig {
        if self.has_midiOutputConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::MidiOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            MidiNodeConfig::new()
        }
    }

    // .mizer.nodes.OpcOutputNodeConfig opcOutputConfig = 24;

    pub fn opcOutputConfig(&self) -> &OpcOutputNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OpcOutputConfig(ref v)) => v,
            _ => <OpcOutputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_opcOutputConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_opcOutputConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OpcOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_opcOutputConfig(&mut self, v: OpcOutputNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::OpcOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_opcOutputConfig(&mut self) -> &mut OpcOutputNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::OpcOutputConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::OpcOutputConfig(OpcOutputNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OpcOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_opcOutputConfig(&mut self) -> OpcOutputNodeConfig {
        if self.has_opcOutputConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::OpcOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            OpcOutputNodeConfig::new()
        }
    }

    // .mizer.nodes.OscNodeConfig oscInputConfig = 25;

    pub fn oscInputConfig(&self) -> &OscNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OscInputConfig(ref v)) => v,
            _ => <OscNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_oscInputConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_oscInputConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OscInputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oscInputConfig(&mut self, v: OscNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::OscInputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oscInputConfig(&mut self) -> &mut OscNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::OscInputConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::OscInputConfig(OscNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OscInputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oscInputConfig(&mut self) -> OscNodeConfig {
        if self.has_oscInputConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::OscInputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            OscNodeConfig::new()
        }
    }

    // .mizer.nodes.OscNodeConfig oscOutputConfig = 26;

    pub fn oscOutputConfig(&self) -> &OscNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OscOutputConfig(ref v)) => v,
            _ => <OscNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_oscOutputConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_oscOutputConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OscOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oscOutputConfig(&mut self, v: OscNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::OscOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oscOutputConfig(&mut self) -> &mut OscNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::OscOutputConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::OscOutputConfig(OscNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::OscOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oscOutputConfig(&mut self) -> OscNodeConfig {
        if self.has_oscOutputConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::OscOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            OscNodeConfig::new()
        }
    }

    // .mizer.nodes.VideoColorBalanceNodeConfig videoColorBalanceConfig = 27;

    pub fn videoColorBalanceConfig(&self) -> &VideoColorBalanceNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoColorBalanceConfig(ref v)) => v,
            _ => <VideoColorBalanceNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoColorBalanceConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_videoColorBalanceConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoColorBalanceConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoColorBalanceConfig(&mut self, v: VideoColorBalanceNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::VideoColorBalanceConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoColorBalanceConfig(&mut self) -> &mut VideoColorBalanceNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::VideoColorBalanceConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::VideoColorBalanceConfig(VideoColorBalanceNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoColorBalanceConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoColorBalanceConfig(&mut self) -> VideoColorBalanceNodeConfig {
        if self.has_videoColorBalanceConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::VideoColorBalanceConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoColorBalanceNodeConfig::new()
        }
    }

    // .mizer.nodes.VideoEffectNodeConfig videoEffectConfig = 28;

    pub fn videoEffectConfig(&self) -> &VideoEffectNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoEffectConfig(ref v)) => v,
            _ => <VideoEffectNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoEffectConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_videoEffectConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoEffectConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoEffectConfig(&mut self, v: VideoEffectNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::VideoEffectConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoEffectConfig(&mut self) -> &mut VideoEffectNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::VideoEffectConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::VideoEffectConfig(VideoEffectNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoEffectConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoEffectConfig(&mut self) -> VideoEffectNodeConfig {
        if self.has_videoEffectConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::VideoEffectConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoEffectNodeConfig::new()
        }
    }

    // .mizer.nodes.VideoFileNodeConfig videoFileConfig = 29;

    pub fn videoFileConfig(&self) -> &VideoFileNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoFileConfig(ref v)) => v,
            _ => <VideoFileNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoFileConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_videoFileConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoFileConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoFileConfig(&mut self, v: VideoFileNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::VideoFileConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoFileConfig(&mut self) -> &mut VideoFileNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::VideoFileConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::VideoFileConfig(VideoFileNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoFileConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoFileConfig(&mut self) -> VideoFileNodeConfig {
        if self.has_videoFileConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::VideoFileConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoFileNodeConfig::new()
        }
    }

    // .mizer.nodes.VideoOutputNodeConfig videoOutputConfig = 30;

    pub fn videoOutputConfig(&self) -> &VideoOutputNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoOutputConfig(ref v)) => v,
            _ => <VideoOutputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoOutputConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_videoOutputConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoOutputConfig(&mut self, v: VideoOutputNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::VideoOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoOutputConfig(&mut self) -> &mut VideoOutputNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::VideoOutputConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::VideoOutputConfig(VideoOutputNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoOutputConfig(&mut self) -> VideoOutputNodeConfig {
        if self.has_videoOutputConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::VideoOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoOutputNodeConfig::new()
        }
    }

    // .mizer.nodes.VideoTransformNodeConfig videoTransformConfig = 31;

    pub fn videoTransformConfig(&self) -> &VideoTransformNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoTransformConfig(ref v)) => v,
            _ => <VideoTransformNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoTransformConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_videoTransformConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoTransformConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoTransformConfig(&mut self, v: VideoTransformNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::VideoTransformConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoTransformConfig(&mut self) -> &mut VideoTransformNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::VideoTransformConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::VideoTransformConfig(VideoTransformNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::VideoTransformConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoTransformConfig(&mut self) -> VideoTransformNodeConfig {
        if self.has_videoTransformConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::VideoTransformConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoTransformNodeConfig::new()
        }
    }

    // .mizer.nodes.SelectNodeConfig selectConfig = 32;

    pub fn selectConfig(&self) -> &SelectNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::SelectConfig(ref v)) => v,
            _ => <SelectNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_selectConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_selectConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::SelectConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_selectConfig(&mut self, v: SelectNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::SelectConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_selectConfig(&mut self) -> &mut SelectNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::SelectConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::SelectConfig(SelectNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::SelectConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_selectConfig(&mut self) -> SelectNodeConfig {
        if self.has_selectConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::SelectConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            SelectNodeConfig::new()
        }
    }

    // .mizer.nodes.MergeNodeConfig mergeConfig = 33;

    pub fn mergeConfig(&self) -> &MergeNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MergeConfig(ref v)) => v,
            _ => <MergeNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mergeConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_mergeConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MergeConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mergeConfig(&mut self, v: MergeNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::MergeConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mergeConfig(&mut self) -> &mut MergeNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::MergeConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::MergeConfig(MergeNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MergeConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mergeConfig(&mut self) -> MergeNodeConfig {
        if self.has_mergeConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::MergeConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            MergeNodeConfig::new()
        }
    }

    // .mizer.nodes.EnvelopeNodeConfig envelopeConfig = 34;

    pub fn envelopeConfig(&self) -> &EnvelopeNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::EnvelopeConfig(ref v)) => v,
            _ => <EnvelopeNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_envelopeConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_envelopeConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::EnvelopeConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_envelopeConfig(&mut self, v: EnvelopeNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::EnvelopeConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_envelopeConfig(&mut self) -> &mut EnvelopeNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::EnvelopeConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::EnvelopeConfig(EnvelopeNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::EnvelopeConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_envelopeConfig(&mut self) -> EnvelopeNodeConfig {
        if self.has_envelopeConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::EnvelopeConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            EnvelopeNodeConfig::new()
        }
    }

    // .mizer.nodes.SequencerNodeConfig sequencerConfig = 35;

    pub fn sequencerConfig(&self) -> &SequencerNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::SequencerConfig(ref v)) => v,
            _ => <SequencerNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sequencerConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_sequencerConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::SequencerConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sequencerConfig(&mut self, v: SequencerNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::SequencerConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sequencerConfig(&mut self) -> &mut SequencerNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::SequencerConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::SequencerConfig(SequencerNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::SequencerConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sequencerConfig(&mut self) -> SequencerNodeConfig {
        if self.has_sequencerConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::SequencerConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            SequencerNodeConfig::new()
        }
    }

    // .mizer.nodes.ProgrammerNodeConfig programmerConfig = 36;

    pub fn programmerConfig(&self) -> &ProgrammerNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ProgrammerConfig(ref v)) => v,
            _ => <ProgrammerNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_programmerConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_programmerConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ProgrammerConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_programmerConfig(&mut self, v: ProgrammerNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ProgrammerConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_programmerConfig(&mut self) -> &mut ProgrammerNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ProgrammerConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ProgrammerConfig(ProgrammerNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ProgrammerConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_programmerConfig(&mut self) -> ProgrammerNodeConfig {
        if self.has_programmerConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ProgrammerConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ProgrammerNodeConfig::new()
        }
    }

    // .mizer.nodes.GroupNodeConfig groupConfig = 37;

    pub fn groupConfig(&self) -> &GroupNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::GroupConfig(ref v)) => v,
            _ => <GroupNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_groupConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_groupConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::GroupConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_groupConfig(&mut self, v: GroupNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::GroupConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_groupConfig(&mut self) -> &mut GroupNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::GroupConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::GroupConfig(GroupNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::GroupConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_groupConfig(&mut self) -> GroupNodeConfig {
        if self.has_groupConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::GroupConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            GroupNodeConfig::new()
        }
    }

    // .mizer.nodes.PresetNodeConfig presetConfig = 38;

    pub fn presetConfig(&self) -> &PresetNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PresetConfig(ref v)) => v,
            _ => <PresetNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_presetConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_presetConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PresetConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_presetConfig(&mut self, v: PresetNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::PresetConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_presetConfig(&mut self) -> &mut PresetNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::PresetConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::PresetConfig(PresetNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PresetConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_presetConfig(&mut self) -> PresetNodeConfig {
        if self.has_presetConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::PresetConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            PresetNodeConfig::new()
        }
    }

    // .mizer.nodes.ColorRgbNodeConfig colorRgbConfig = 40;

    pub fn colorRgbConfig(&self) -> &ColorRgbNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ColorRgbConfig(ref v)) => v,
            _ => <ColorRgbNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_colorRgbConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_colorRgbConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ColorRgbConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_colorRgbConfig(&mut self, v: ColorRgbNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ColorRgbConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_colorRgbConfig(&mut self) -> &mut ColorRgbNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ColorRgbConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ColorRgbConfig(ColorRgbNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ColorRgbConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_colorRgbConfig(&mut self) -> ColorRgbNodeConfig {
        if self.has_colorRgbConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ColorRgbConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ColorRgbNodeConfig::new()
        }
    }

    // .mizer.nodes.ColorHsvNodeConfig colorHsvConfig = 41;

    pub fn colorHsvConfig(&self) -> &ColorHsvNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ColorHsvConfig(ref v)) => v,
            _ => <ColorHsvNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_colorHsvConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_colorHsvConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ColorHsvConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_colorHsvConfig(&mut self, v: ColorHsvNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ColorHsvConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_colorHsvConfig(&mut self) -> &mut ColorHsvNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ColorHsvConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ColorHsvConfig(ColorHsvNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ColorHsvConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_colorHsvConfig(&mut self) -> ColorHsvNodeConfig {
        if self.has_colorHsvConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ColorHsvConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ColorHsvNodeConfig::new()
        }
    }

    // .mizer.nodes.GamepadNodeConfig gamepadNodeConfig = 42;

    pub fn gamepadNodeConfig(&self) -> &GamepadNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::GamepadNodeConfig(ref v)) => v,
            _ => <GamepadNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_gamepadNodeConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_gamepadNodeConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::GamepadNodeConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gamepadNodeConfig(&mut self, v: GamepadNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::GamepadNodeConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gamepadNodeConfig(&mut self) -> &mut GamepadNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::GamepadNodeConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::GamepadNodeConfig(GamepadNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::GamepadNodeConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gamepadNodeConfig(&mut self) -> GamepadNodeConfig {
        if self.has_gamepadNodeConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::GamepadNodeConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            GamepadNodeConfig::new()
        }
    }

    // .mizer.nodes.ThresholdNodeConfig thresholdConfig = 43;

    pub fn thresholdConfig(&self) -> &ThresholdNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ThresholdConfig(ref v)) => v,
            _ => <ThresholdNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_thresholdConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_thresholdConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ThresholdConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thresholdConfig(&mut self, v: ThresholdNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ThresholdConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thresholdConfig(&mut self) -> &mut ThresholdNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ThresholdConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ThresholdConfig(ThresholdNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ThresholdConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thresholdConfig(&mut self) -> ThresholdNodeConfig {
        if self.has_thresholdConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ThresholdConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ThresholdNodeConfig::new()
        }
    }

    // .mizer.nodes.EncoderNodeConfig encoderConfig = 44;

    pub fn encoderConfig(&self) -> &EncoderNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::EncoderConfig(ref v)) => v,
            _ => <EncoderNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_encoderConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_encoderConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::EncoderConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_encoderConfig(&mut self, v: EncoderNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::EncoderConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_encoderConfig(&mut self) -> &mut EncoderNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::EncoderConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::EncoderConfig(EncoderNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::EncoderConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_encoderConfig(&mut self) -> EncoderNodeConfig {
        if self.has_encoderConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::EncoderConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            EncoderNodeConfig::new()
        }
    }

    // .mizer.nodes.ContainerNodeConfig containerConfig = 45;

    pub fn containerConfig(&self) -> &ContainerNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ContainerConfig(ref v)) => v,
            _ => <ContainerNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_containerConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_containerConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ContainerConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_containerConfig(&mut self, v: ContainerNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ContainerConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_containerConfig(&mut self) -> &mut ContainerNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ContainerConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ContainerConfig(ContainerNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ContainerConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_containerConfig(&mut self) -> ContainerNodeConfig {
        if self.has_containerConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ContainerConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ContainerNodeConfig::new()
        }
    }

    // .mizer.nodes.MathNodeConfig mathConfig = 46;

    pub fn mathConfig(&self) -> &MathNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MathConfig(ref v)) => v,
            _ => <MathNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mathConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_mathConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MathConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mathConfig(&mut self, v: MathNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::MathConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mathConfig(&mut self) -> &mut MathNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::MathConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::MathConfig(MathNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MathConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mathConfig(&mut self) -> MathNodeConfig {
        if self.has_mathConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::MathConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            MathNodeConfig::new()
        }
    }

    // .mizer.nodes.MqttInputNodeConfig mqttInputConfig = 47;

    pub fn mqttInputConfig(&self) -> &MqttInputNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MqttInputConfig(ref v)) => v,
            _ => <MqttInputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mqttInputConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_mqttInputConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MqttInputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mqttInputConfig(&mut self, v: MqttInputNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::MqttInputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mqttInputConfig(&mut self) -> &mut MqttInputNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::MqttInputConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::MqttInputConfig(MqttInputNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MqttInputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mqttInputConfig(&mut self) -> MqttInputNodeConfig {
        if self.has_mqttInputConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::MqttInputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            MqttInputNodeConfig::new()
        }
    }

    // .mizer.nodes.MqttOutputNodeConfig mqttOutputConfig = 48;

    pub fn mqttOutputConfig(&self) -> &MqttOutputNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MqttOutputConfig(ref v)) => v,
            _ => <MqttOutputNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_mqttOutputConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_mqttOutputConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MqttOutputConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mqttOutputConfig(&mut self, v: MqttOutputNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::MqttOutputConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mqttOutputConfig(&mut self) -> &mut MqttOutputNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::MqttOutputConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::MqttOutputConfig(MqttOutputNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::MqttOutputConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mqttOutputConfig(&mut self) -> MqttOutputNodeConfig {
        if self.has_mqttOutputConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::MqttOutputConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            MqttOutputNodeConfig::new()
        }
    }

    // .mizer.nodes.NumberToDataNodeConfig numberToDataConfig = 49;

    pub fn numberToDataConfig(&self) -> &NumberToDataNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::NumberToDataConfig(ref v)) => v,
            _ => <NumberToDataNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_numberToDataConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_numberToDataConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::NumberToDataConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_numberToDataConfig(&mut self, v: NumberToDataNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::NumberToDataConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_numberToDataConfig(&mut self) -> &mut NumberToDataNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::NumberToDataConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::NumberToDataConfig(NumberToDataNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::NumberToDataConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_numberToDataConfig(&mut self) -> NumberToDataNodeConfig {
        if self.has_numberToDataConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::NumberToDataConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            NumberToDataNodeConfig::new()
        }
    }

    // .mizer.nodes.DataToNumberNodeConfig dataToNumberConfig = 50;

    pub fn dataToNumberConfig(&self) -> &DataToNumberNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::DataToNumberConfig(ref v)) => v,
            _ => <DataToNumberNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dataToNumberConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_dataToNumberConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::DataToNumberConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dataToNumberConfig(&mut self, v: DataToNumberNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::DataToNumberConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dataToNumberConfig(&mut self) -> &mut DataToNumberNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::DataToNumberConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::DataToNumberConfig(DataToNumberNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::DataToNumberConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dataToNumberConfig(&mut self) -> DataToNumberNodeConfig {
        if self.has_dataToNumberConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::DataToNumberConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            DataToNumberNodeConfig::new()
        }
    }

    // .mizer.nodes.ValueNodeConfig valueConfig = 51;

    pub fn valueConfig(&self) -> &ValueNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ValueConfig(ref v)) => v,
            _ => <ValueNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_valueConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_valueConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ValueConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_valueConfig(&mut self, v: ValueNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ValueConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_valueConfig(&mut self) -> &mut ValueNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ValueConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ValueConfig(ValueNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ValueConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_valueConfig(&mut self) -> ValueNodeConfig {
        if self.has_valueConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ValueConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ValueNodeConfig::new()
        }
    }

    // .mizer.nodes.PlanScreenNodeConfig planScreenConfig = 52;

    pub fn planScreenConfig(&self) -> &PlanScreenNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PlanScreenConfig(ref v)) => v,
            _ => <PlanScreenNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_planScreenConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_planScreenConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PlanScreenConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_planScreenConfig(&mut self, v: PlanScreenNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::PlanScreenConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_planScreenConfig(&mut self) -> &mut PlanScreenNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::PlanScreenConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::PlanScreenConfig(PlanScreenNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::PlanScreenConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_planScreenConfig(&mut self) -> PlanScreenNodeConfig {
        if self.has_planScreenConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::PlanScreenConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            PlanScreenNodeConfig::new()
        }
    }

    // .mizer.nodes.DelayNodeConfig delayConfig = 53;

    pub fn delayConfig(&self) -> &DelayNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::DelayConfig(ref v)) => v,
            _ => <DelayNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delayConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_delayConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::DelayConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delayConfig(&mut self, v: DelayNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::DelayConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delayConfig(&mut self) -> &mut DelayNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::DelayConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::DelayConfig(DelayNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::DelayConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delayConfig(&mut self) -> DelayNodeConfig {
        if self.has_delayConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::DelayConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            DelayNodeConfig::new()
        }
    }

    // .mizer.nodes.RampNodeConfig rampConfig = 54;

    pub fn rampConfig(&self) -> &RampNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::RampConfig(ref v)) => v,
            _ => <RampNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_rampConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_rampConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::RampConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rampConfig(&mut self, v: RampNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::RampConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rampConfig(&mut self) -> &mut RampNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::RampConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::RampConfig(RampNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::RampConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rampConfig(&mut self) -> RampNodeConfig {
        if self.has_rampConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::RampConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            RampNodeConfig::new()
        }
    }

    // .mizer.nodes.NoiseNodeConfig noiseConfig = 55;

    pub fn noiseConfig(&self) -> &NoiseNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::NoiseConfig(ref v)) => v,
            _ => <NoiseNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_noiseConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_noiseConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::NoiseConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_noiseConfig(&mut self, v: NoiseNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::NoiseConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_noiseConfig(&mut self) -> &mut NoiseNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::NoiseConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::NoiseConfig(NoiseNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::NoiseConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_noiseConfig(&mut self) -> NoiseNodeConfig {
        if self.has_noiseConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::NoiseConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            NoiseNodeConfig::new()
        }
    }

    // .mizer.nodes.LabelNodeConfig labelConfig = 56;

    pub fn labelConfig(&self) -> &LabelNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::LabelConfig(ref v)) => v,
            _ => <LabelNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_labelConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_labelConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::LabelConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_labelConfig(&mut self, v: LabelNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::LabelConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_labelConfig(&mut self) -> &mut LabelNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::LabelConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::LabelConfig(LabelNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::LabelConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_labelConfig(&mut self) -> LabelNodeConfig {
        if self.has_labelConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::LabelConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            LabelNodeConfig::new()
        }
    }

    // .mizer.nodes.TransportNodeConfig transportConfig = 57;

    pub fn transportConfig(&self) -> &TransportNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::TransportConfig(ref v)) => v,
            _ => <TransportNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_transportConfig(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_transportConfig(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::TransportConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transportConfig(&mut self, v: TransportNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::TransportConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transportConfig(&mut self) -> &mut TransportNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::TransportConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::TransportConfig(TransportNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::TransportConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transportConfig(&mut self) -> TransportNodeConfig {
        if self.has_transportConfig() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::TransportConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            TransportNodeConfig::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(47);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OscillatorNodeConfig>(
            "oscillatorConfig",
            NodeConfig::has_oscillatorConfig,
            NodeConfig::oscillatorConfig,
            NodeConfig::mut_oscillatorConfig,
            NodeConfig::set_oscillatorConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ScriptingNodeConfig>(
            "scriptingConfig",
            NodeConfig::has_scriptingConfig,
            NodeConfig::scriptingConfig,
            NodeConfig::mut_scriptingConfig,
            NodeConfig::set_scriptingConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SequenceNodeConfig>(
            "sequenceConfig",
            NodeConfig::has_sequenceConfig,
            NodeConfig::sequenceConfig,
            NodeConfig::mut_sequenceConfig,
            NodeConfig::set_sequenceConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ClockNodeConfig>(
            "clockConfig",
            NodeConfig::has_clockConfig,
            NodeConfig::clockConfig,
            NodeConfig::mut_clockConfig,
            NodeConfig::set_clockConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FixtureNodeConfig>(
            "fixtureConfig",
            NodeConfig::has_fixtureConfig,
            NodeConfig::fixtureConfig,
            NodeConfig::mut_fixtureConfig,
            NodeConfig::set_fixtureConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ButtonNodeConfig>(
            "buttonConfig",
            NodeConfig::has_buttonConfig,
            NodeConfig::buttonConfig,
            NodeConfig::mut_buttonConfig,
            NodeConfig::set_buttonConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FaderNodeConfig>(
            "faderConfig",
            NodeConfig::has_faderConfig,
            NodeConfig::faderConfig,
            NodeConfig::mut_faderConfig,
            NodeConfig::set_faderConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, IldaFileNodeConfig>(
            "ildaFileConfig",
            NodeConfig::has_ildaFileConfig,
            NodeConfig::ildaFileConfig,
            NodeConfig::mut_ildaFileConfig,
            NodeConfig::set_ildaFileConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LaserNodeConfig>(
            "laserConfig",
            NodeConfig::has_laserConfig,
            NodeConfig::laserConfig,
            NodeConfig::mut_laserConfig,
            NodeConfig::set_laserConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PixelPatternNodeConfig>(
            "pixelPatternConfig",
            NodeConfig::has_pixelPatternConfig,
            NodeConfig::pixelPatternConfig,
            NodeConfig::mut_pixelPatternConfig,
            NodeConfig::set_pixelPatternConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PixelDmxNodeConfig>(
            "pixelDmxConfig",
            NodeConfig::has_pixelDmxConfig,
            NodeConfig::pixelDmxConfig,
            NodeConfig::mut_pixelDmxConfig,
            NodeConfig::set_pixelDmxConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DmxOutputNodeConfig>(
            "dmxOutputConfig",
            NodeConfig::has_dmxOutputConfig,
            NodeConfig::dmxOutputConfig,
            NodeConfig::mut_dmxOutputConfig,
            NodeConfig::set_dmxOutputConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MidiNodeConfig>(
            "midiInputConfig",
            NodeConfig::has_midiInputConfig,
            NodeConfig::midiInputConfig,
            NodeConfig::mut_midiInputConfig,
            NodeConfig::set_midiInputConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MidiNodeConfig>(
            "midiOutputConfig",
            NodeConfig::has_midiOutputConfig,
            NodeConfig::midiOutputConfig,
            NodeConfig::mut_midiOutputConfig,
            NodeConfig::set_midiOutputConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OpcOutputNodeConfig>(
            "opcOutputConfig",
            NodeConfig::has_opcOutputConfig,
            NodeConfig::opcOutputConfig,
            NodeConfig::mut_opcOutputConfig,
            NodeConfig::set_opcOutputConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OscNodeConfig>(
            "oscInputConfig",
            NodeConfig::has_oscInputConfig,
            NodeConfig::oscInputConfig,
            NodeConfig::mut_oscInputConfig,
            NodeConfig::set_oscInputConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OscNodeConfig>(
            "oscOutputConfig",
            NodeConfig::has_oscOutputConfig,
            NodeConfig::oscOutputConfig,
            NodeConfig::mut_oscOutputConfig,
            NodeConfig::set_oscOutputConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoColorBalanceNodeConfig>(
            "videoColorBalanceConfig",
            NodeConfig::has_videoColorBalanceConfig,
            NodeConfig::videoColorBalanceConfig,
            NodeConfig::mut_videoColorBalanceConfig,
            NodeConfig::set_videoColorBalanceConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoEffectNodeConfig>(
            "videoEffectConfig",
            NodeConfig::has_videoEffectConfig,
            NodeConfig::videoEffectConfig,
            NodeConfig::mut_videoEffectConfig,
            NodeConfig::set_videoEffectConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoFileNodeConfig>(
            "videoFileConfig",
            NodeConfig::has_videoFileConfig,
            NodeConfig::videoFileConfig,
            NodeConfig::mut_videoFileConfig,
            NodeConfig::set_videoFileConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoOutputNodeConfig>(
            "videoOutputConfig",
            NodeConfig::has_videoOutputConfig,
            NodeConfig::videoOutputConfig,
            NodeConfig::mut_videoOutputConfig,
            NodeConfig::set_videoOutputConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoTransformNodeConfig>(
            "videoTransformConfig",
            NodeConfig::has_videoTransformConfig,
            NodeConfig::videoTransformConfig,
            NodeConfig::mut_videoTransformConfig,
            NodeConfig::set_videoTransformConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SelectNodeConfig>(
            "selectConfig",
            NodeConfig::has_selectConfig,
            NodeConfig::selectConfig,
            NodeConfig::mut_selectConfig,
            NodeConfig::set_selectConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MergeNodeConfig>(
            "mergeConfig",
            NodeConfig::has_mergeConfig,
            NodeConfig::mergeConfig,
            NodeConfig::mut_mergeConfig,
            NodeConfig::set_mergeConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EnvelopeNodeConfig>(
            "envelopeConfig",
            NodeConfig::has_envelopeConfig,
            NodeConfig::envelopeConfig,
            NodeConfig::mut_envelopeConfig,
            NodeConfig::set_envelopeConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SequencerNodeConfig>(
            "sequencerConfig",
            NodeConfig::has_sequencerConfig,
            NodeConfig::sequencerConfig,
            NodeConfig::mut_sequencerConfig,
            NodeConfig::set_sequencerConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProgrammerNodeConfig>(
            "programmerConfig",
            NodeConfig::has_programmerConfig,
            NodeConfig::programmerConfig,
            NodeConfig::mut_programmerConfig,
            NodeConfig::set_programmerConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GroupNodeConfig>(
            "groupConfig",
            NodeConfig::has_groupConfig,
            NodeConfig::groupConfig,
            NodeConfig::mut_groupConfig,
            NodeConfig::set_groupConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PresetNodeConfig>(
            "presetConfig",
            NodeConfig::has_presetConfig,
            NodeConfig::presetConfig,
            NodeConfig::mut_presetConfig,
            NodeConfig::set_presetConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ColorRgbNodeConfig>(
            "colorRgbConfig",
            NodeConfig::has_colorRgbConfig,
            NodeConfig::colorRgbConfig,
            NodeConfig::mut_colorRgbConfig,
            NodeConfig::set_colorRgbConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ColorHsvNodeConfig>(
            "colorHsvConfig",
            NodeConfig::has_colorHsvConfig,
            NodeConfig::colorHsvConfig,
            NodeConfig::mut_colorHsvConfig,
            NodeConfig::set_colorHsvConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GamepadNodeConfig>(
            "gamepadNodeConfig",
            NodeConfig::has_gamepadNodeConfig,
            NodeConfig::gamepadNodeConfig,
            NodeConfig::mut_gamepadNodeConfig,
            NodeConfig::set_gamepadNodeConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ThresholdNodeConfig>(
            "thresholdConfig",
            NodeConfig::has_thresholdConfig,
            NodeConfig::thresholdConfig,
            NodeConfig::mut_thresholdConfig,
            NodeConfig::set_thresholdConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, EncoderNodeConfig>(
            "encoderConfig",
            NodeConfig::has_encoderConfig,
            NodeConfig::encoderConfig,
            NodeConfig::mut_encoderConfig,
            NodeConfig::set_encoderConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ContainerNodeConfig>(
            "containerConfig",
            NodeConfig::has_containerConfig,
            NodeConfig::containerConfig,
            NodeConfig::mut_containerConfig,
            NodeConfig::set_containerConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MathNodeConfig>(
            "mathConfig",
            NodeConfig::has_mathConfig,
            NodeConfig::mathConfig,
            NodeConfig::mut_mathConfig,
            NodeConfig::set_mathConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MqttInputNodeConfig>(
            "mqttInputConfig",
            NodeConfig::has_mqttInputConfig,
            NodeConfig::mqttInputConfig,
            NodeConfig::mut_mqttInputConfig,
            NodeConfig::set_mqttInputConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MqttOutputNodeConfig>(
            "mqttOutputConfig",
            NodeConfig::has_mqttOutputConfig,
            NodeConfig::mqttOutputConfig,
            NodeConfig::mut_mqttOutputConfig,
            NodeConfig::set_mqttOutputConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NumberToDataNodeConfig>(
            "numberToDataConfig",
            NodeConfig::has_numberToDataConfig,
            NodeConfig::numberToDataConfig,
            NodeConfig::mut_numberToDataConfig,
            NodeConfig::set_numberToDataConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DataToNumberNodeConfig>(
            "dataToNumberConfig",
            NodeConfig::has_dataToNumberConfig,
            NodeConfig::dataToNumberConfig,
            NodeConfig::mut_dataToNumberConfig,
            NodeConfig::set_dataToNumberConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ValueNodeConfig>(
            "valueConfig",
            NodeConfig::has_valueConfig,
            NodeConfig::valueConfig,
            NodeConfig::mut_valueConfig,
            NodeConfig::set_valueConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PlanScreenNodeConfig>(
            "planScreenConfig",
            NodeConfig::has_planScreenConfig,
            NodeConfig::planScreenConfig,
            NodeConfig::mut_planScreenConfig,
            NodeConfig::set_planScreenConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DelayNodeConfig>(
            "delayConfig",
            NodeConfig::has_delayConfig,
            NodeConfig::delayConfig,
            NodeConfig::mut_delayConfig,
            NodeConfig::set_delayConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RampNodeConfig>(
            "rampConfig",
            NodeConfig::has_rampConfig,
            NodeConfig::rampConfig,
            NodeConfig::mut_rampConfig,
            NodeConfig::set_rampConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NoiseNodeConfig>(
            "noiseConfig",
            NodeConfig::has_noiseConfig,
            NodeConfig::noiseConfig,
            NodeConfig::mut_noiseConfig,
            NodeConfig::set_noiseConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LabelNodeConfig>(
            "labelConfig",
            NodeConfig::has_labelConfig,
            NodeConfig::labelConfig,
            NodeConfig::mut_labelConfig,
            NodeConfig::set_labelConfig,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TransportNodeConfig>(
            "transportConfig",
            NodeConfig::has_transportConfig,
            NodeConfig::transportConfig,
            NodeConfig::mut_transportConfig,
            NodeConfig::set_transportConfig,
        ));
        oneofs.push(node_config::Type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeConfig>(
            "NodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeConfig {
    const NAME: &'static str = "NodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                82 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::OscillatorConfig(is.read_message()?));
                },
                90 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ScriptingConfig(is.read_message()?));
                },
                98 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::SequenceConfig(is.read_message()?));
                },
                106 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ClockConfig(is.read_message()?));
                },
                114 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::FixtureConfig(is.read_message()?));
                },
                122 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ButtonConfig(is.read_message()?));
                },
                130 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::FaderConfig(is.read_message()?));
                },
                138 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::IldaFileConfig(is.read_message()?));
                },
                146 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::LaserConfig(is.read_message()?));
                },
                154 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::PixelPatternConfig(is.read_message()?));
                },
                162 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::PixelDmxConfig(is.read_message()?));
                },
                170 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::DmxOutputConfig(is.read_message()?));
                },
                178 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::MidiInputConfig(is.read_message()?));
                },
                186 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::MidiOutputConfig(is.read_message()?));
                },
                194 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::OpcOutputConfig(is.read_message()?));
                },
                202 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::OscInputConfig(is.read_message()?));
                },
                210 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::OscOutputConfig(is.read_message()?));
                },
                218 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::VideoColorBalanceConfig(is.read_message()?));
                },
                226 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::VideoEffectConfig(is.read_message()?));
                },
                234 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::VideoFileConfig(is.read_message()?));
                },
                242 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::VideoOutputConfig(is.read_message()?));
                },
                250 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::VideoTransformConfig(is.read_message()?));
                },
                258 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::SelectConfig(is.read_message()?));
                },
                266 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::MergeConfig(is.read_message()?));
                },
                274 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::EnvelopeConfig(is.read_message()?));
                },
                282 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::SequencerConfig(is.read_message()?));
                },
                290 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ProgrammerConfig(is.read_message()?));
                },
                298 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::GroupConfig(is.read_message()?));
                },
                306 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::PresetConfig(is.read_message()?));
                },
                322 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ColorRgbConfig(is.read_message()?));
                },
                330 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ColorHsvConfig(is.read_message()?));
                },
                338 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::GamepadNodeConfig(is.read_message()?));
                },
                346 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ThresholdConfig(is.read_message()?));
                },
                354 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::EncoderConfig(is.read_message()?));
                },
                362 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ContainerConfig(is.read_message()?));
                },
                370 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::MathConfig(is.read_message()?));
                },
                378 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::MqttInputConfig(is.read_message()?));
                },
                386 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::MqttOutputConfig(is.read_message()?));
                },
                394 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::NumberToDataConfig(is.read_message()?));
                },
                402 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::DataToNumberConfig(is.read_message()?));
                },
                410 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ValueConfig(is.read_message()?));
                },
                418 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::PlanScreenConfig(is.read_message()?));
                },
                426 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::DelayConfig(is.read_message()?));
                },
                434 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::RampConfig(is.read_message()?));
                },
                442 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::NoiseConfig(is.read_message()?));
                },
                450 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::LabelConfig(is.read_message()?));
                },
                458 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::TransportConfig(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.type_ {
            match v {
                &node_config::Type::OscillatorConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::ScriptingConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::SequenceConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::ClockConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::FixtureConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::ButtonConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::FaderConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::IldaFileConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::LaserConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::PixelPatternConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::PixelDmxConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::DmxOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::MidiInputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::MidiOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::OpcOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::OscInputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::OscOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::VideoColorBalanceConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::VideoEffectConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::VideoFileConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::VideoOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::VideoTransformConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::SelectConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::MergeConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::EnvelopeConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::SequencerConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::ProgrammerConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::GroupConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::PresetConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::ColorRgbConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::ColorHsvConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::GamepadNodeConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::ThresholdConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::EncoderConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::ContainerConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::MathConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::MqttInputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::MqttOutputConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::NumberToDataConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::DataToNumberConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::ValueConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::PlanScreenConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::DelayConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::RampConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::NoiseConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::LabelConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_config::Type::TransportConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.type_ {
            match v {
                &node_config::Type::OscillatorConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &node_config::Type::ScriptingConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &node_config::Type::SequenceConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &node_config::Type::ClockConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &node_config::Type::FixtureConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &node_config::Type::ButtonConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &node_config::Type::FaderConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &node_config::Type::IldaFileConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &node_config::Type::LaserConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &node_config::Type::PixelPatternConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &node_config::Type::PixelDmxConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
                &node_config::Type::DmxOutputConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                },
                &node_config::Type::MidiInputConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                },
                &node_config::Type::MidiOutputConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
                },
                &node_config::Type::OpcOutputConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
                },
                &node_config::Type::OscInputConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
                },
                &node_config::Type::OscOutputConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
                },
                &node_config::Type::VideoColorBalanceConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
                },
                &node_config::Type::VideoEffectConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
                },
                &node_config::Type::VideoFileConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
                },
                &node_config::Type::VideoOutputConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
                },
                &node_config::Type::VideoTransformConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
                },
                &node_config::Type::SelectConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
                },
                &node_config::Type::MergeConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
                },
                &node_config::Type::EnvelopeConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
                },
                &node_config::Type::SequencerConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
                },
                &node_config::Type::ProgrammerConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
                },
                &node_config::Type::GroupConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
                },
                &node_config::Type::PresetConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
                },
                &node_config::Type::ColorRgbConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
                },
                &node_config::Type::ColorHsvConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
                },
                &node_config::Type::GamepadNodeConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
                },
                &node_config::Type::ThresholdConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
                },
                &node_config::Type::EncoderConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
                },
                &node_config::Type::ContainerConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
                },
                &node_config::Type::MathConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
                },
                &node_config::Type::MqttInputConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
                },
                &node_config::Type::MqttOutputConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
                },
                &node_config::Type::NumberToDataConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
                },
                &node_config::Type::DataToNumberConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
                },
                &node_config::Type::ValueConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
                },
                &node_config::Type::PlanScreenConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(52, v, os)?;
                },
                &node_config::Type::DelayConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(53, v, os)?;
                },
                &node_config::Type::RampConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
                },
                &node_config::Type::NoiseConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(55, v, os)?;
                },
                &node_config::Type::LabelConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(56, v, os)?;
                },
                &node_config::Type::TransportConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(57, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeConfig {
        NodeConfig::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeConfig {
        static instance: NodeConfig = NodeConfig {
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NodeConfig`
pub mod node_config {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.nodes.NodeConfig.type)
    pub enum Type {
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.oscillatorConfig)
        OscillatorConfig(super::OscillatorNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.scriptingConfig)
        ScriptingConfig(super::ScriptingNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.sequenceConfig)
        SequenceConfig(super::SequenceNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.clockConfig)
        ClockConfig(super::ClockNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.fixtureConfig)
        FixtureConfig(super::FixtureNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.buttonConfig)
        ButtonConfig(super::ButtonNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.faderConfig)
        FaderConfig(super::FaderNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.ildaFileConfig)
        IldaFileConfig(super::IldaFileNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.laserConfig)
        LaserConfig(super::LaserNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.pixelPatternConfig)
        PixelPatternConfig(super::PixelPatternNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.pixelDmxConfig)
        PixelDmxConfig(super::PixelDmxNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.dmxOutputConfig)
        DmxOutputConfig(super::DmxOutputNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.midiInputConfig)
        MidiInputConfig(super::MidiNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.midiOutputConfig)
        MidiOutputConfig(super::MidiNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.opcOutputConfig)
        OpcOutputConfig(super::OpcOutputNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.oscInputConfig)
        OscInputConfig(super::OscNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.oscOutputConfig)
        OscOutputConfig(super::OscNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.videoColorBalanceConfig)
        VideoColorBalanceConfig(super::VideoColorBalanceNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.videoEffectConfig)
        VideoEffectConfig(super::VideoEffectNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.videoFileConfig)
        VideoFileConfig(super::VideoFileNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.videoOutputConfig)
        VideoOutputConfig(super::VideoOutputNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.videoTransformConfig)
        VideoTransformConfig(super::VideoTransformNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.selectConfig)
        SelectConfig(super::SelectNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.mergeConfig)
        MergeConfig(super::MergeNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.envelopeConfig)
        EnvelopeConfig(super::EnvelopeNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.sequencerConfig)
        SequencerConfig(super::SequencerNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.programmerConfig)
        ProgrammerConfig(super::ProgrammerNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.groupConfig)
        GroupConfig(super::GroupNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.presetConfig)
        PresetConfig(super::PresetNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.colorRgbConfig)
        ColorRgbConfig(super::ColorRgbNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.colorHsvConfig)
        ColorHsvConfig(super::ColorHsvNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.gamepadNodeConfig)
        GamepadNodeConfig(super::GamepadNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.thresholdConfig)
        ThresholdConfig(super::ThresholdNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.encoderConfig)
        EncoderConfig(super::EncoderNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.containerConfig)
        ContainerConfig(super::ContainerNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.mathConfig)
        MathConfig(super::MathNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.mqttInputConfig)
        MqttInputConfig(super::MqttInputNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.mqttOutputConfig)
        MqttOutputConfig(super::MqttOutputNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.numberToDataConfig)
        NumberToDataConfig(super::NumberToDataNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.dataToNumberConfig)
        DataToNumberConfig(super::DataToNumberNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.valueConfig)
        ValueConfig(super::ValueNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.planScreenConfig)
        PlanScreenConfig(super::PlanScreenNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.delayConfig)
        DelayConfig(super::DelayNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.rampConfig)
        RampConfig(super::RampNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.noiseConfig)
        NoiseConfig(super::NoiseNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.labelConfig)
        LabelConfig(super::LabelNodeConfig),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.transportConfig)
        TransportConfig(super::TransportNodeConfig),
    }

    impl ::protobuf::Oneof for Type {
    }

    impl ::protobuf::OneofFull for Type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::NodeConfig as ::protobuf::MessageFull>::descriptor().oneof_by_name("type").unwrap()).clone()
        }
    }

    impl Type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Type>("type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.OscillatorNodeConfig)
pub struct OscillatorNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.OscillatorNodeConfig.type)
    pub type_: ::protobuf::EnumOrUnknown<oscillator_node_config::OscillatorType>,
    // @@protoc_insertion_point(field:mizer.nodes.OscillatorNodeConfig.ratio)
    pub ratio: f64,
    // @@protoc_insertion_point(field:mizer.nodes.OscillatorNodeConfig.max)
    pub max: f64,
    // @@protoc_insertion_point(field:mizer.nodes.OscillatorNodeConfig.min)
    pub min: f64,
    // @@protoc_insertion_point(field:mizer.nodes.OscillatorNodeConfig.offset)
    pub offset: f64,
    // @@protoc_insertion_point(field:mizer.nodes.OscillatorNodeConfig.reverse)
    pub reverse: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.OscillatorNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OscillatorNodeConfig {
    fn default() -> &'a OscillatorNodeConfig {
        <OscillatorNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl OscillatorNodeConfig {
    pub fn new() -> OscillatorNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &OscillatorNodeConfig| { &m.type_ },
            |m: &mut OscillatorNodeConfig| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ratio",
            |m: &OscillatorNodeConfig| { &m.ratio },
            |m: &mut OscillatorNodeConfig| { &mut m.ratio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max",
            |m: &OscillatorNodeConfig| { &m.max },
            |m: &mut OscillatorNodeConfig| { &mut m.max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min",
            |m: &OscillatorNodeConfig| { &m.min },
            |m: &mut OscillatorNodeConfig| { &mut m.min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &OscillatorNodeConfig| { &m.offset },
            |m: &mut OscillatorNodeConfig| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reverse",
            |m: &OscillatorNodeConfig| { &m.reverse },
            |m: &mut OscillatorNodeConfig| { &mut m.reverse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OscillatorNodeConfig>(
            "OscillatorNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OscillatorNodeConfig {
    const NAME: &'static str = "OscillatorNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                17 => {
                    self.ratio = is.read_double()?;
                },
                25 => {
                    self.max = is.read_double()?;
                },
                33 => {
                    self.min = is.read_double()?;
                },
                41 => {
                    self.offset = is.read_double()?;
                },
                48 => {
                    self.reverse = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(oscillator_node_config::OscillatorType::Square) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.ratio != 0. {
            my_size += 1 + 8;
        }
        if self.max != 0. {
            my_size += 1 + 8;
        }
        if self.min != 0. {
            my_size += 1 + 8;
        }
        if self.offset != 0. {
            my_size += 1 + 8;
        }
        if self.reverse != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(oscillator_node_config::OscillatorType::Square) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.ratio != 0. {
            os.write_double(2, self.ratio)?;
        }
        if self.max != 0. {
            os.write_double(3, self.max)?;
        }
        if self.min != 0. {
            os.write_double(4, self.min)?;
        }
        if self.offset != 0. {
            os.write_double(5, self.offset)?;
        }
        if self.reverse != false {
            os.write_bool(6, self.reverse)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OscillatorNodeConfig {
        OscillatorNodeConfig::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(oscillator_node_config::OscillatorType::Square);
        self.ratio = 0.;
        self.max = 0.;
        self.min = 0.;
        self.offset = 0.;
        self.reverse = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OscillatorNodeConfig {
        static instance: OscillatorNodeConfig = OscillatorNodeConfig {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            ratio: 0.,
            max: 0.,
            min: 0.,
            offset: 0.,
            reverse: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OscillatorNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OscillatorNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OscillatorNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OscillatorNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OscillatorNodeConfig`
pub mod oscillator_node_config {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.OscillatorNodeConfig.OscillatorType)
    pub enum OscillatorType {
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscillatorNodeConfig.OscillatorType.Square)
        Square = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscillatorNodeConfig.OscillatorType.Sine)
        Sine = 1,
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscillatorNodeConfig.OscillatorType.Saw)
        Saw = 2,
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscillatorNodeConfig.OscillatorType.Triangle)
        Triangle = 3,
    }

    impl ::protobuf::Enum for OscillatorType {
        const NAME: &'static str = "OscillatorType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OscillatorType> {
            match value {
                0 => ::std::option::Option::Some(OscillatorType::Square),
                1 => ::std::option::Option::Some(OscillatorType::Sine),
                2 => ::std::option::Option::Some(OscillatorType::Saw),
                3 => ::std::option::Option::Some(OscillatorType::Triangle),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OscillatorType] = &[
            OscillatorType::Square,
            OscillatorType::Sine,
            OscillatorType::Saw,
            OscillatorType::Triangle,
        ];
    }

    impl ::protobuf::EnumFull for OscillatorType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OscillatorNodeConfig.OscillatorType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for OscillatorType {
        fn default() -> Self {
            OscillatorType::Square
        }
    }

    impl OscillatorType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OscillatorType>("OscillatorNodeConfig.OscillatorType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ScriptingNodeConfig)
pub struct ScriptingNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.ScriptingNodeConfig.script)
    pub script: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ScriptingNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptingNodeConfig {
    fn default() -> &'a ScriptingNodeConfig {
        <ScriptingNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ScriptingNodeConfig {
    pub fn new() -> ScriptingNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "script",
            |m: &ScriptingNodeConfig| { &m.script },
            |m: &mut ScriptingNodeConfig| { &mut m.script },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptingNodeConfig>(
            "ScriptingNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptingNodeConfig {
    const NAME: &'static str = "ScriptingNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.script = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.script.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.script);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.script.is_empty() {
            os.write_string(1, &self.script)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptingNodeConfig {
        ScriptingNodeConfig::new()
    }

    fn clear(&mut self) {
        self.script.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptingNodeConfig {
        static instance: ScriptingNodeConfig = ScriptingNodeConfig {
            script: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptingNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptingNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptingNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptingNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.SequenceNodeConfig)
pub struct SequenceNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.SequenceNodeConfig.steps)
    pub steps: ::std::vec::Vec<sequence_node_config::SequenceStep>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.SequenceNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SequenceNodeConfig {
    fn default() -> &'a SequenceNodeConfig {
        <SequenceNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl SequenceNodeConfig {
    pub fn new() -> SequenceNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &SequenceNodeConfig| { &m.steps },
            |m: &mut SequenceNodeConfig| { &mut m.steps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SequenceNodeConfig>(
            "SequenceNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SequenceNodeConfig {
    const NAME: &'static str = "SequenceNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.steps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SequenceNodeConfig {
        SequenceNodeConfig::new()
    }

    fn clear(&mut self) {
        self.steps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SequenceNodeConfig {
        static instance: SequenceNodeConfig = SequenceNodeConfig {
            steps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SequenceNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SequenceNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SequenceNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SequenceNodeConfig`
pub mod sequence_node_config {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.SequenceNodeConfig.SequenceStep)
    pub struct SequenceStep {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.SequenceNodeConfig.SequenceStep.tick)
        pub tick: f64,
        // @@protoc_insertion_point(field:mizer.nodes.SequenceNodeConfig.SequenceStep.value)
        pub value: f64,
        // @@protoc_insertion_point(field:mizer.nodes.SequenceNodeConfig.SequenceStep.hold)
        pub hold: bool,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.SequenceNodeConfig.SequenceStep.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SequenceStep {
        fn default() -> &'a SequenceStep {
            <SequenceStep as ::protobuf::Message>::default_instance()
        }
    }

    impl SequenceStep {
        pub fn new() -> SequenceStep {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "tick",
                |m: &SequenceStep| { &m.tick },
                |m: &mut SequenceStep| { &mut m.tick },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &SequenceStep| { &m.value },
                |m: &mut SequenceStep| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hold",
                |m: &SequenceStep| { &m.hold },
                |m: &mut SequenceStep| { &mut m.hold },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SequenceStep>(
                "SequenceNodeConfig.SequenceStep",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SequenceStep {
        const NAME: &'static str = "SequenceStep";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.tick = is.read_double()?;
                    },
                    17 => {
                        self.value = is.read_double()?;
                    },
                    24 => {
                        self.hold = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.tick != 0. {
                my_size += 1 + 8;
            }
            if self.value != 0. {
                my_size += 1 + 8;
            }
            if self.hold != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.tick != 0. {
                os.write_double(1, self.tick)?;
            }
            if self.value != 0. {
                os.write_double(2, self.value)?;
            }
            if self.hold != false {
                os.write_bool(3, self.hold)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SequenceStep {
            SequenceStep::new()
        }

        fn clear(&mut self) {
            self.tick = 0.;
            self.value = 0.;
            self.hold = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SequenceStep {
            static instance: SequenceStep = SequenceStep {
                tick: 0.,
                value: 0.,
                hold: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SequenceStep {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SequenceNodeConfig.SequenceStep").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SequenceStep {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SequenceStep {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ProgrammerNodeConfig)
pub struct ProgrammerNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ProgrammerNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProgrammerNodeConfig {
    fn default() -> &'a ProgrammerNodeConfig {
        <ProgrammerNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ProgrammerNodeConfig {
    pub fn new() -> ProgrammerNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProgrammerNodeConfig>(
            "ProgrammerNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProgrammerNodeConfig {
    const NAME: &'static str = "ProgrammerNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProgrammerNodeConfig {
        ProgrammerNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProgrammerNodeConfig {
        static instance: ProgrammerNodeConfig = ProgrammerNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProgrammerNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProgrammerNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProgrammerNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgrammerNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.GroupNodeConfig)
pub struct GroupNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.GroupNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupNodeConfig {
    fn default() -> &'a GroupNodeConfig {
        <GroupNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl GroupNodeConfig {
    pub fn new() -> GroupNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupNodeConfig>(
            "GroupNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupNodeConfig {
    const NAME: &'static str = "GroupNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupNodeConfig {
        GroupNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupNodeConfig {
        static instance: GroupNodeConfig = GroupNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.PresetNodeConfig)
pub struct PresetNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.PresetNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PresetNodeConfig {
    fn default() -> &'a PresetNodeConfig {
        <PresetNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl PresetNodeConfig {
    pub fn new() -> PresetNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PresetNodeConfig>(
            "PresetNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PresetNodeConfig {
    const NAME: &'static str = "PresetNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PresetNodeConfig {
        PresetNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PresetNodeConfig {
        static instance: PresetNodeConfig = PresetNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PresetNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PresetNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PresetNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PresetNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.EnvelopeNodeConfig)
pub struct EnvelopeNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.EnvelopeNodeConfig.attack)
    pub attack: f64,
    // @@protoc_insertion_point(field:mizer.nodes.EnvelopeNodeConfig.decay)
    pub decay: f64,
    // @@protoc_insertion_point(field:mizer.nodes.EnvelopeNodeConfig.sustain)
    pub sustain: f64,
    // @@protoc_insertion_point(field:mizer.nodes.EnvelopeNodeConfig.release)
    pub release: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.EnvelopeNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnvelopeNodeConfig {
    fn default() -> &'a EnvelopeNodeConfig {
        <EnvelopeNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl EnvelopeNodeConfig {
    pub fn new() -> EnvelopeNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attack",
            |m: &EnvelopeNodeConfig| { &m.attack },
            |m: &mut EnvelopeNodeConfig| { &mut m.attack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "decay",
            |m: &EnvelopeNodeConfig| { &m.decay },
            |m: &mut EnvelopeNodeConfig| { &mut m.decay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sustain",
            |m: &EnvelopeNodeConfig| { &m.sustain },
            |m: &mut EnvelopeNodeConfig| { &mut m.sustain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "release",
            |m: &EnvelopeNodeConfig| { &m.release },
            |m: &mut EnvelopeNodeConfig| { &mut m.release },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnvelopeNodeConfig>(
            "EnvelopeNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnvelopeNodeConfig {
    const NAME: &'static str = "EnvelopeNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.attack = is.read_double()?;
                },
                17 => {
                    self.decay = is.read_double()?;
                },
                25 => {
                    self.sustain = is.read_double()?;
                },
                33 => {
                    self.release = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.attack != 0. {
            my_size += 1 + 8;
        }
        if self.decay != 0. {
            my_size += 1 + 8;
        }
        if self.sustain != 0. {
            my_size += 1 + 8;
        }
        if self.release != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.attack != 0. {
            os.write_double(1, self.attack)?;
        }
        if self.decay != 0. {
            os.write_double(2, self.decay)?;
        }
        if self.sustain != 0. {
            os.write_double(3, self.sustain)?;
        }
        if self.release != 0. {
            os.write_double(4, self.release)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnvelopeNodeConfig {
        EnvelopeNodeConfig::new()
    }

    fn clear(&mut self) {
        self.attack = 0.;
        self.decay = 0.;
        self.sustain = 0.;
        self.release = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnvelopeNodeConfig {
        static instance: EnvelopeNodeConfig = EnvelopeNodeConfig {
            attack: 0.,
            decay: 0.,
            sustain: 0.,
            release: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnvelopeNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnvelopeNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnvelopeNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvelopeNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ClockNodeConfig)
pub struct ClockNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.ClockNodeConfig.speed)
    pub speed: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ClockNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClockNodeConfig {
    fn default() -> &'a ClockNodeConfig {
        <ClockNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ClockNodeConfig {
    pub fn new() -> ClockNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed",
            |m: &ClockNodeConfig| { &m.speed },
            |m: &mut ClockNodeConfig| { &mut m.speed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClockNodeConfig>(
            "ClockNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClockNodeConfig {
    const NAME: &'static str = "ClockNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.speed = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.speed != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.speed != 0. {
            os.write_double(1, self.speed)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClockNodeConfig {
        ClockNodeConfig::new()
    }

    fn clear(&mut self) {
        self.speed = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClockNodeConfig {
        static instance: ClockNodeConfig = ClockNodeConfig {
            speed: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClockNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClockNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClockNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClockNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.FixtureNodeConfig)
pub struct FixtureNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.FixtureNodeConfig.fixture_id)
    pub fixture_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.FixtureNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureNodeConfig {
    fn default() -> &'a FixtureNodeConfig {
        <FixtureNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl FixtureNodeConfig {
    pub fn new() -> FixtureNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fixture_id",
            |m: &FixtureNodeConfig| { &m.fixture_id },
            |m: &mut FixtureNodeConfig| { &mut m.fixture_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureNodeConfig>(
            "FixtureNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureNodeConfig {
    const NAME: &'static str = "FixtureNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fixture_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fixture_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.fixture_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fixture_id != 0 {
            os.write_uint32(1, self.fixture_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureNodeConfig {
        FixtureNodeConfig::new()
    }

    fn clear(&mut self) {
        self.fixture_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureNodeConfig {
        static instance: FixtureNodeConfig = FixtureNodeConfig {
            fixture_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.SequencerNodeConfig)
pub struct SequencerNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.SequencerNodeConfig.sequence_id)
    pub sequence_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.SequencerNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SequencerNodeConfig {
    fn default() -> &'a SequencerNodeConfig {
        <SequencerNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl SequencerNodeConfig {
    pub fn new() -> SequencerNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence_id",
            |m: &SequencerNodeConfig| { &m.sequence_id },
            |m: &mut SequencerNodeConfig| { &mut m.sequence_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SequencerNodeConfig>(
            "SequencerNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SequencerNodeConfig {
    const NAME: &'static str = "SequencerNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence_id != 0 {
            os.write_uint32(1, self.sequence_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SequencerNodeConfig {
        SequencerNodeConfig::new()
    }

    fn clear(&mut self) {
        self.sequence_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SequencerNodeConfig {
        static instance: SequencerNodeConfig = SequencerNodeConfig {
            sequence_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SequencerNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SequencerNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SequencerNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequencerNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ButtonNodeConfig)
pub struct ButtonNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.ButtonNodeConfig.toggle)
    pub toggle: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ButtonNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ButtonNodeConfig {
    fn default() -> &'a ButtonNodeConfig {
        <ButtonNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ButtonNodeConfig {
    pub fn new() -> ButtonNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toggle",
            |m: &ButtonNodeConfig| { &m.toggle },
            |m: &mut ButtonNodeConfig| { &mut m.toggle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonNodeConfig>(
            "ButtonNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonNodeConfig {
    const NAME: &'static str = "ButtonNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.toggle = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.toggle != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.toggle != false {
            os.write_bool(1, self.toggle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonNodeConfig {
        ButtonNodeConfig::new()
    }

    fn clear(&mut self) {
        self.toggle = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonNodeConfig {
        static instance: ButtonNodeConfig = ButtonNodeConfig {
            toggle: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ButtonNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.FaderNodeConfig)
pub struct FaderNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.FaderNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FaderNodeConfig {
    fn default() -> &'a FaderNodeConfig {
        <FaderNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl FaderNodeConfig {
    pub fn new() -> FaderNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FaderNodeConfig>(
            "FaderNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FaderNodeConfig {
    const NAME: &'static str = "FaderNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FaderNodeConfig {
        FaderNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FaderNodeConfig {
        static instance: FaderNodeConfig = FaderNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FaderNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FaderNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FaderNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FaderNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.IldaFileNodeConfig)
pub struct IldaFileNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.IldaFileNodeConfig.file)
    pub file: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.IldaFileNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IldaFileNodeConfig {
    fn default() -> &'a IldaFileNodeConfig {
        <IldaFileNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl IldaFileNodeConfig {
    pub fn new() -> IldaFileNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file",
            |m: &IldaFileNodeConfig| { &m.file },
            |m: &mut IldaFileNodeConfig| { &mut m.file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IldaFileNodeConfig>(
            "IldaFileNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IldaFileNodeConfig {
    const NAME: &'static str = "IldaFileNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IldaFileNodeConfig {
        IldaFileNodeConfig::new()
    }

    fn clear(&mut self) {
        self.file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IldaFileNodeConfig {
        static instance: IldaFileNodeConfig = IldaFileNodeConfig {
            file: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IldaFileNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IldaFileNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IldaFileNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IldaFileNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.LaserNodeConfig)
pub struct LaserNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.LaserNodeConfig.device_id)
    pub device_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.LaserNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LaserNodeConfig {
    fn default() -> &'a LaserNodeConfig {
        <LaserNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl LaserNodeConfig {
    pub fn new() -> LaserNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &LaserNodeConfig| { &m.device_id },
            |m: &mut LaserNodeConfig| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LaserNodeConfig>(
            "LaserNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LaserNodeConfig {
    const NAME: &'static str = "LaserNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.device_id.is_empty() {
            os.write_string(1, &self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LaserNodeConfig {
        LaserNodeConfig::new()
    }

    fn clear(&mut self) {
        self.device_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LaserNodeConfig {
        static instance: LaserNodeConfig = LaserNodeConfig {
            device_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LaserNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LaserNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LaserNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LaserNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.GamepadNodeConfig)
pub struct GamepadNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.GamepadNodeConfig.device_id)
    pub device_id: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.GamepadNodeConfig.control)
    pub control: ::protobuf::EnumOrUnknown<gamepad_node_config::Control>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.GamepadNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GamepadNodeConfig {
    fn default() -> &'a GamepadNodeConfig {
        <GamepadNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl GamepadNodeConfig {
    pub fn new() -> GamepadNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &GamepadNodeConfig| { &m.device_id },
            |m: &mut GamepadNodeConfig| { &mut m.device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "control",
            |m: &GamepadNodeConfig| { &m.control },
            |m: &mut GamepadNodeConfig| { &mut m.control },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GamepadNodeConfig>(
            "GamepadNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GamepadNodeConfig {
    const NAME: &'static str = "GamepadNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_id = is.read_string()?;
                },
                16 => {
                    self.control = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device_id);
        }
        if self.control != ::protobuf::EnumOrUnknown::new(gamepad_node_config::Control::LeftStickX) {
            my_size += ::protobuf::rt::int32_size(2, self.control.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.device_id.is_empty() {
            os.write_string(1, &self.device_id)?;
        }
        if self.control != ::protobuf::EnumOrUnknown::new(gamepad_node_config::Control::LeftStickX) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.control))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GamepadNodeConfig {
        GamepadNodeConfig::new()
    }

    fn clear(&mut self) {
        self.device_id.clear();
        self.control = ::protobuf::EnumOrUnknown::new(gamepad_node_config::Control::LeftStickX);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GamepadNodeConfig {
        static instance: GamepadNodeConfig = GamepadNodeConfig {
            device_id: ::std::string::String::new(),
            control: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GamepadNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GamepadNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GamepadNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GamepadNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GamepadNodeConfig`
pub mod gamepad_node_config {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.GamepadNodeConfig.Control)
    pub enum Control {
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.LeftStickX)
        LeftStickX = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.LeftStickY)
        LeftStickY = 1,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.RightStickX)
        RightStickX = 2,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.RightStickY)
        RightStickY = 3,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.LeftTrigger)
        LeftTrigger = 4,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.RightTrigger)
        RightTrigger = 5,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.LeftShoulder)
        LeftShoulder = 6,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.RightShoulder)
        RightShoulder = 7,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.South)
        South = 8,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.East)
        East = 9,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.North)
        North = 10,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.West)
        West = 11,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.Select)
        Select = 12,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.Start)
        Start = 13,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.DpadUp)
        DpadUp = 14,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.DpadDown)
        DpadDown = 15,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.DpadLeft)
        DpadLeft = 16,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.DpadRight)
        DpadRight = 17,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.LeftStick)
        LeftStick = 18,
        // @@protoc_insertion_point(enum_value:mizer.nodes.GamepadNodeConfig.Control.RightStick)
        RightStick = 19,
    }

    impl ::protobuf::Enum for Control {
        const NAME: &'static str = "Control";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Control> {
            match value {
                0 => ::std::option::Option::Some(Control::LeftStickX),
                1 => ::std::option::Option::Some(Control::LeftStickY),
                2 => ::std::option::Option::Some(Control::RightStickX),
                3 => ::std::option::Option::Some(Control::RightStickY),
                4 => ::std::option::Option::Some(Control::LeftTrigger),
                5 => ::std::option::Option::Some(Control::RightTrigger),
                6 => ::std::option::Option::Some(Control::LeftShoulder),
                7 => ::std::option::Option::Some(Control::RightShoulder),
                8 => ::std::option::Option::Some(Control::South),
                9 => ::std::option::Option::Some(Control::East),
                10 => ::std::option::Option::Some(Control::North),
                11 => ::std::option::Option::Some(Control::West),
                12 => ::std::option::Option::Some(Control::Select),
                13 => ::std::option::Option::Some(Control::Start),
                14 => ::std::option::Option::Some(Control::DpadUp),
                15 => ::std::option::Option::Some(Control::DpadDown),
                16 => ::std::option::Option::Some(Control::DpadLeft),
                17 => ::std::option::Option::Some(Control::DpadRight),
                18 => ::std::option::Option::Some(Control::LeftStick),
                19 => ::std::option::Option::Some(Control::RightStick),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Control] = &[
            Control::LeftStickX,
            Control::LeftStickY,
            Control::RightStickX,
            Control::RightStickY,
            Control::LeftTrigger,
            Control::RightTrigger,
            Control::LeftShoulder,
            Control::RightShoulder,
            Control::South,
            Control::East,
            Control::North,
            Control::West,
            Control::Select,
            Control::Start,
            Control::DpadUp,
            Control::DpadDown,
            Control::DpadLeft,
            Control::DpadRight,
            Control::LeftStick,
            Control::RightStick,
        ];
    }

    impl ::protobuf::EnumFull for Control {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GamepadNodeConfig.Control").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Control {
        fn default() -> Self {
            Control::LeftStickX
        }
    }

    impl Control {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Control>("GamepadNodeConfig.Control")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.PixelPatternNodeConfig)
pub struct PixelPatternNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.PixelPatternNodeConfig.pattern)
    pub pattern: ::protobuf::EnumOrUnknown<pixel_pattern_node_config::Pattern>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.PixelPatternNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PixelPatternNodeConfig {
    fn default() -> &'a PixelPatternNodeConfig {
        <PixelPatternNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl PixelPatternNodeConfig {
    pub fn new() -> PixelPatternNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pattern",
            |m: &PixelPatternNodeConfig| { &m.pattern },
            |m: &mut PixelPatternNodeConfig| { &mut m.pattern },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PixelPatternNodeConfig>(
            "PixelPatternNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PixelPatternNodeConfig {
    const NAME: &'static str = "PixelPatternNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pattern = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pattern != ::protobuf::EnumOrUnknown::new(pixel_pattern_node_config::Pattern::RgbIterate) {
            my_size += ::protobuf::rt::int32_size(1, self.pattern.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pattern != ::protobuf::EnumOrUnknown::new(pixel_pattern_node_config::Pattern::RgbIterate) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.pattern))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PixelPatternNodeConfig {
        PixelPatternNodeConfig::new()
    }

    fn clear(&mut self) {
        self.pattern = ::protobuf::EnumOrUnknown::new(pixel_pattern_node_config::Pattern::RgbIterate);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PixelPatternNodeConfig {
        static instance: PixelPatternNodeConfig = PixelPatternNodeConfig {
            pattern: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PixelPatternNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PixelPatternNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PixelPatternNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PixelPatternNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PixelPatternNodeConfig`
pub mod pixel_pattern_node_config {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.PixelPatternNodeConfig.Pattern)
    pub enum Pattern {
        // @@protoc_insertion_point(enum_value:mizer.nodes.PixelPatternNodeConfig.Pattern.RgbIterate)
        RgbIterate = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.PixelPatternNodeConfig.Pattern.RgbSnake)
        RgbSnake = 1,
    }

    impl ::protobuf::Enum for Pattern {
        const NAME: &'static str = "Pattern";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Pattern> {
            match value {
                0 => ::std::option::Option::Some(Pattern::RgbIterate),
                1 => ::std::option::Option::Some(Pattern::RgbSnake),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Pattern] = &[
            Pattern::RgbIterate,
            Pattern::RgbSnake,
        ];
    }

    impl ::protobuf::EnumFull for Pattern {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PixelPatternNodeConfig.Pattern").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Pattern {
        fn default() -> Self {
            Pattern::RgbIterate
        }
    }

    impl Pattern {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Pattern>("PixelPatternNodeConfig.Pattern")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.PixelDmxNodeConfig)
pub struct PixelDmxNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.PixelDmxNodeConfig.width)
    pub width: u64,
    // @@protoc_insertion_point(field:mizer.nodes.PixelDmxNodeConfig.height)
    pub height: u64,
    // @@protoc_insertion_point(field:mizer.nodes.PixelDmxNodeConfig.start_universe)
    pub start_universe: u32,
    // @@protoc_insertion_point(field:mizer.nodes.PixelDmxNodeConfig.output)
    pub output: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.PixelDmxNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PixelDmxNodeConfig {
    fn default() -> &'a PixelDmxNodeConfig {
        <PixelDmxNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl PixelDmxNodeConfig {
    pub fn new() -> PixelDmxNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &PixelDmxNodeConfig| { &m.width },
            |m: &mut PixelDmxNodeConfig| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &PixelDmxNodeConfig| { &m.height },
            |m: &mut PixelDmxNodeConfig| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_universe",
            |m: &PixelDmxNodeConfig| { &m.start_universe },
            |m: &mut PixelDmxNodeConfig| { &mut m.start_universe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "output",
            |m: &PixelDmxNodeConfig| { &m.output },
            |m: &mut PixelDmxNodeConfig| { &mut m.output },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PixelDmxNodeConfig>(
            "PixelDmxNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PixelDmxNodeConfig {
    const NAME: &'static str = "PixelDmxNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = is.read_uint64()?;
                },
                16 => {
                    self.height = is.read_uint64()?;
                },
                24 => {
                    self.start_universe = is.read_uint32()?;
                },
                34 => {
                    self.output = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.width != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.height);
        }
        if self.start_universe != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.start_universe);
        }
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.output);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.width != 0 {
            os.write_uint64(1, self.width)?;
        }
        if self.height != 0 {
            os.write_uint64(2, self.height)?;
        }
        if self.start_universe != 0 {
            os.write_uint32(3, self.start_universe)?;
        }
        if !self.output.is_empty() {
            os.write_string(4, &self.output)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PixelDmxNodeConfig {
        PixelDmxNodeConfig::new()
    }

    fn clear(&mut self) {
        self.width = 0;
        self.height = 0;
        self.start_universe = 0;
        self.output.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PixelDmxNodeConfig {
        static instance: PixelDmxNodeConfig = PixelDmxNodeConfig {
            width: 0,
            height: 0,
            start_universe: 0,
            output: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PixelDmxNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PixelDmxNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PixelDmxNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PixelDmxNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.DmxOutputNodeConfig)
pub struct DmxOutputNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.DmxOutputNodeConfig.output)
    pub output: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:mizer.nodes.DmxOutputNodeConfig.universe)
    pub universe: u32,
    // @@protoc_insertion_point(field:mizer.nodes.DmxOutputNodeConfig.channel)
    pub channel: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.DmxOutputNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DmxOutputNodeConfig {
    fn default() -> &'a DmxOutputNodeConfig {
        <DmxOutputNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl DmxOutputNodeConfig {
    pub fn new() -> DmxOutputNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "output",
            |m: &DmxOutputNodeConfig| { &m.output },
            |m: &mut DmxOutputNodeConfig| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "universe",
            |m: &DmxOutputNodeConfig| { &m.universe },
            |m: &mut DmxOutputNodeConfig| { &mut m.universe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channel",
            |m: &DmxOutputNodeConfig| { &m.channel },
            |m: &mut DmxOutputNodeConfig| { &mut m.channel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DmxOutputNodeConfig>(
            "DmxOutputNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DmxOutputNodeConfig {
    const NAME: &'static str = "DmxOutputNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.output = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.universe = is.read_uint32()?;
                },
                24 => {
                    self.channel = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.output.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if self.universe != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.universe);
        }
        if self.channel != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.channel);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.output.as_ref() {
            os.write_string(1, v)?;
        }
        if self.universe != 0 {
            os.write_uint32(2, self.universe)?;
        }
        if self.channel != 0 {
            os.write_uint32(3, self.channel)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DmxOutputNodeConfig {
        DmxOutputNodeConfig::new()
    }

    fn clear(&mut self) {
        self.output = ::std::option::Option::None;
        self.universe = 0;
        self.channel = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DmxOutputNodeConfig {
        static instance: DmxOutputNodeConfig = DmxOutputNodeConfig {
            output: ::std::option::Option::None,
            universe: 0,
            channel: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DmxOutputNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DmxOutputNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DmxOutputNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DmxOutputNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MidiNodeConfig)
pub struct MidiNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.device)
    pub device: ::std::string::String,
    // message oneof groups
    pub binding: ::std::option::Option<midi_node_config::Binding>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MidiNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MidiNodeConfig {
    fn default() -> &'a MidiNodeConfig {
        <MidiNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl MidiNodeConfig {
    pub fn new() -> MidiNodeConfig {
        ::std::default::Default::default()
    }

    // .mizer.nodes.MidiNodeConfig.NoteBinding noteBinding = 2;

    pub fn noteBinding(&self) -> &midi_node_config::NoteBinding {
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(ref v)) => v,
            _ => <midi_node_config::NoteBinding as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_noteBinding(&mut self) {
        self.binding = ::std::option::Option::None;
    }

    pub fn has_noteBinding(&self) -> bool {
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_noteBinding(&mut self, v: midi_node_config::NoteBinding) {
        self.binding = ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_noteBinding(&mut self) -> &mut midi_node_config::NoteBinding {
        if let ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(_)) = self.binding {
        } else {
            self.binding = ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(midi_node_config::NoteBinding::new()));
        }
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_noteBinding(&mut self) -> midi_node_config::NoteBinding {
        if self.has_noteBinding() {
            match self.binding.take() {
                ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(v)) => v,
                _ => panic!(),
            }
        } else {
            midi_node_config::NoteBinding::new()
        }
    }

    // .mizer.nodes.MidiNodeConfig.ControlBinding controlBinding = 3;

    pub fn controlBinding(&self) -> &midi_node_config::ControlBinding {
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(ref v)) => v,
            _ => <midi_node_config::ControlBinding as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_controlBinding(&mut self) {
        self.binding = ::std::option::Option::None;
    }

    pub fn has_controlBinding(&self) -> bool {
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_controlBinding(&mut self, v: midi_node_config::ControlBinding) {
        self.binding = ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_controlBinding(&mut self) -> &mut midi_node_config::ControlBinding {
        if let ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(_)) = self.binding {
        } else {
            self.binding = ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(midi_node_config::ControlBinding::new()));
        }
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_controlBinding(&mut self) -> midi_node_config::ControlBinding {
        if self.has_controlBinding() {
            match self.binding.take() {
                ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(v)) => v,
                _ => panic!(),
            }
        } else {
            midi_node_config::ControlBinding::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device",
            |m: &MidiNodeConfig| { &m.device },
            |m: &mut MidiNodeConfig| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, midi_node_config::NoteBinding>(
            "noteBinding",
            MidiNodeConfig::has_noteBinding,
            MidiNodeConfig::noteBinding,
            MidiNodeConfig::mut_noteBinding,
            MidiNodeConfig::set_noteBinding,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, midi_node_config::ControlBinding>(
            "controlBinding",
            MidiNodeConfig::has_controlBinding,
            MidiNodeConfig::controlBinding,
            MidiNodeConfig::mut_controlBinding,
            MidiNodeConfig::set_controlBinding,
        ));
        oneofs.push(midi_node_config::Binding::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MidiNodeConfig>(
            "MidiNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MidiNodeConfig {
    const NAME: &'static str = "MidiNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device = is.read_string()?;
                },
                18 => {
                    self.binding = ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(is.read_message()?));
                },
                26 => {
                    self.binding = ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        if let ::std::option::Option::Some(ref v) = self.binding {
            match v {
                &midi_node_config::Binding::NoteBinding(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &midi_node_config::Binding::ControlBinding(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        if let ::std::option::Option::Some(ref v) = self.binding {
            match v {
                &midi_node_config::Binding::NoteBinding(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &midi_node_config::Binding::ControlBinding(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MidiNodeConfig {
        MidiNodeConfig::new()
    }

    fn clear(&mut self) {
        self.device.clear();
        self.binding = ::std::option::Option::None;
        self.binding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MidiNodeConfig {
        static instance: MidiNodeConfig = MidiNodeConfig {
            device: ::std::string::String::new(),
            binding: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MidiNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MidiNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MidiNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MidiNodeConfig`
pub mod midi_node_config {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.nodes.MidiNodeConfig.binding)
    pub enum Binding {
        // @@protoc_insertion_point(oneof_field:mizer.nodes.MidiNodeConfig.noteBinding)
        NoteBinding(NoteBinding),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.MidiNodeConfig.controlBinding)
        ControlBinding(ControlBinding),
    }

    impl ::protobuf::Oneof for Binding {
    }

    impl ::protobuf::OneofFull for Binding {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::MidiNodeConfig as ::protobuf::MessageFull>::descriptor().oneof_by_name("binding").unwrap()).clone()
        }
    }

    impl Binding {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Binding>("binding")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.MidiNodeConfig.NoteBinding)
    pub struct NoteBinding {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.channel)
        pub channel: u32,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.type)
        pub type_: ::protobuf::EnumOrUnknown<note_binding::MidiType>,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.port)
        pub port: u32,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.rangeFrom)
        pub rangeFrom: u32,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.rangeTo)
        pub rangeTo: u32,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.MidiNodeConfig.NoteBinding.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NoteBinding {
        fn default() -> &'a NoteBinding {
            <NoteBinding as ::protobuf::Message>::default_instance()
        }
    }

    impl NoteBinding {
        pub fn new() -> NoteBinding {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "channel",
                |m: &NoteBinding| { &m.channel },
                |m: &mut NoteBinding| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type",
                |m: &NoteBinding| { &m.type_ },
                |m: &mut NoteBinding| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "port",
                |m: &NoteBinding| { &m.port },
                |m: &mut NoteBinding| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rangeFrom",
                |m: &NoteBinding| { &m.rangeFrom },
                |m: &mut NoteBinding| { &mut m.rangeFrom },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rangeTo",
                |m: &NoteBinding| { &m.rangeTo },
                |m: &mut NoteBinding| { &mut m.rangeTo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoteBinding>(
                "MidiNodeConfig.NoteBinding",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NoteBinding {
        const NAME: &'static str = "NoteBinding";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.channel = is.read_uint32()?;
                    },
                    16 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    24 => {
                        self.port = is.read_uint32()?;
                    },
                    32 => {
                        self.rangeFrom = is.read_uint32()?;
                    },
                    40 => {
                        self.rangeTo = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.channel != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.channel);
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(note_binding::MidiType::CC) {
                my_size += ::protobuf::rt::int32_size(2, self.type_.value());
            }
            if self.port != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.port);
            }
            if self.rangeFrom != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.rangeFrom);
            }
            if self.rangeTo != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.rangeTo);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.channel != 0 {
                os.write_uint32(1, self.channel)?;
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(note_binding::MidiType::CC) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if self.port != 0 {
                os.write_uint32(3, self.port)?;
            }
            if self.rangeFrom != 0 {
                os.write_uint32(4, self.rangeFrom)?;
            }
            if self.rangeTo != 0 {
                os.write_uint32(5, self.rangeTo)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NoteBinding {
            NoteBinding::new()
        }

        fn clear(&mut self) {
            self.channel = 0;
            self.type_ = ::protobuf::EnumOrUnknown::new(note_binding::MidiType::CC);
            self.port = 0;
            self.rangeFrom = 0;
            self.rangeTo = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NoteBinding {
            static instance: NoteBinding = NoteBinding {
                channel: 0,
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                port: 0,
                rangeFrom: 0,
                rangeTo: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NoteBinding {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MidiNodeConfig.NoteBinding").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NoteBinding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NoteBinding {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `NoteBinding`
    pub mod note_binding {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:mizer.nodes.MidiNodeConfig.NoteBinding.MidiType)
        pub enum MidiType {
            // @@protoc_insertion_point(enum_value:mizer.nodes.MidiNodeConfig.NoteBinding.MidiType.CC)
            CC = 0,
            // @@protoc_insertion_point(enum_value:mizer.nodes.MidiNodeConfig.NoteBinding.MidiType.Note)
            Note = 1,
        }

        impl ::protobuf::Enum for MidiType {
            const NAME: &'static str = "MidiType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<MidiType> {
                match value {
                    0 => ::std::option::Option::Some(MidiType::CC),
                    1 => ::std::option::Option::Some(MidiType::Note),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [MidiType] = &[
                MidiType::CC,
                MidiType::Note,
            ];
        }

        impl ::protobuf::EnumFull for MidiType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("MidiNodeConfig.NoteBinding.MidiType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for MidiType {
            fn default() -> Self {
                MidiType::CC
            }
        }

        impl MidiType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MidiType>("MidiNodeConfig.NoteBinding.MidiType")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.MidiNodeConfig.ControlBinding)
    pub struct ControlBinding {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.ControlBinding.page)
        pub page: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.ControlBinding.control)
        pub control: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.MidiNodeConfig.ControlBinding.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControlBinding {
        fn default() -> &'a ControlBinding {
            <ControlBinding as ::protobuf::Message>::default_instance()
        }
    }

    impl ControlBinding {
        pub fn new() -> ControlBinding {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "page",
                |m: &ControlBinding| { &m.page },
                |m: &mut ControlBinding| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "control",
                |m: &ControlBinding| { &m.control },
                |m: &mut ControlBinding| { &mut m.control },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControlBinding>(
                "MidiNodeConfig.ControlBinding",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ControlBinding {
        const NAME: &'static str = "ControlBinding";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.page = is.read_string()?;
                    },
                    18 => {
                        self.control = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.page.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.page);
            }
            if !self.control.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.control);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.page.is_empty() {
                os.write_string(1, &self.page)?;
            }
            if !self.control.is_empty() {
                os.write_string(2, &self.control)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControlBinding {
            ControlBinding::new()
        }

        fn clear(&mut self) {
            self.page.clear();
            self.control.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControlBinding {
            static instance: ControlBinding = ControlBinding {
                page: ::std::string::String::new(),
                control: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ControlBinding {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MidiNodeConfig.ControlBinding").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ControlBinding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ControlBinding {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.OpcOutputNodeConfig)
pub struct OpcOutputNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.OpcOutputNodeConfig.host)
    pub host: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.OpcOutputNodeConfig.port)
    pub port: u32,
    // @@protoc_insertion_point(field:mizer.nodes.OpcOutputNodeConfig.width)
    pub width: u64,
    // @@protoc_insertion_point(field:mizer.nodes.OpcOutputNodeConfig.height)
    pub height: u64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.OpcOutputNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpcOutputNodeConfig {
    fn default() -> &'a OpcOutputNodeConfig {
        <OpcOutputNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl OpcOutputNodeConfig {
    pub fn new() -> OpcOutputNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &OpcOutputNodeConfig| { &m.host },
            |m: &mut OpcOutputNodeConfig| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &OpcOutputNodeConfig| { &m.port },
            |m: &mut OpcOutputNodeConfig| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &OpcOutputNodeConfig| { &m.width },
            |m: &mut OpcOutputNodeConfig| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &OpcOutputNodeConfig| { &m.height },
            |m: &mut OpcOutputNodeConfig| { &mut m.height },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpcOutputNodeConfig>(
            "OpcOutputNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpcOutputNodeConfig {
    const NAME: &'static str = "OpcOutputNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = is.read_string()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                24 => {
                    self.width = is.read_uint64()?;
                },
                32 => {
                    self.height = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.width);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.height);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if self.width != 0 {
            os.write_uint64(3, self.width)?;
        }
        if self.height != 0 {
            os.write_uint64(4, self.height)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpcOutputNodeConfig {
        OpcOutputNodeConfig::new()
    }

    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.width = 0;
        self.height = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpcOutputNodeConfig {
        static instance: OpcOutputNodeConfig = OpcOutputNodeConfig {
            host: ::std::string::String::new(),
            port: 0,
            width: 0,
            height: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpcOutputNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpcOutputNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpcOutputNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpcOutputNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.OscNodeConfig)
pub struct OscNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.OscNodeConfig.host)
    pub host: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.OscNodeConfig.port)
    pub port: u32,
    // @@protoc_insertion_point(field:mizer.nodes.OscNodeConfig.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.OscNodeConfig.argumentType)
    pub argumentType: ::protobuf::EnumOrUnknown<osc_node_config::ArgumentType>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.OscNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OscNodeConfig {
    fn default() -> &'a OscNodeConfig {
        <OscNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl OscNodeConfig {
    pub fn new() -> OscNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &OscNodeConfig| { &m.host },
            |m: &mut OscNodeConfig| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &OscNodeConfig| { &m.port },
            |m: &mut OscNodeConfig| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &OscNodeConfig| { &m.path },
            |m: &mut OscNodeConfig| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "argumentType",
            |m: &OscNodeConfig| { &m.argumentType },
            |m: &mut OscNodeConfig| { &mut m.argumentType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OscNodeConfig>(
            "OscNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OscNodeConfig {
    const NAME: &'static str = "OscNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.host = is.read_string()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                26 => {
                    self.path = is.read_string()?;
                },
                32 => {
                    self.argumentType = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        if self.argumentType != ::protobuf::EnumOrUnknown::new(osc_node_config::ArgumentType::Int) {
            my_size += ::protobuf::rt::int32_size(4, self.argumentType.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        if self.argumentType != ::protobuf::EnumOrUnknown::new(osc_node_config::ArgumentType::Int) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.argumentType))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OscNodeConfig {
        OscNodeConfig::new()
    }

    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.path.clear();
        self.argumentType = ::protobuf::EnumOrUnknown::new(osc_node_config::ArgumentType::Int);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OscNodeConfig {
        static instance: OscNodeConfig = OscNodeConfig {
            host: ::std::string::String::new(),
            port: 0,
            path: ::std::string::String::new(),
            argumentType: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OscNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OscNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OscNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OscNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OscNodeConfig`
pub mod osc_node_config {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.OscNodeConfig.ArgumentType)
    pub enum ArgumentType {
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscNodeConfig.ArgumentType.Int)
        Int = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscNodeConfig.ArgumentType.Float)
        Float = 1,
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscNodeConfig.ArgumentType.Long)
        Long = 2,
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscNodeConfig.ArgumentType.Double)
        Double = 3,
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscNodeConfig.ArgumentType.Bool)
        Bool = 4,
        // @@protoc_insertion_point(enum_value:mizer.nodes.OscNodeConfig.ArgumentType.Color)
        Color = 5,
    }

    impl ::protobuf::Enum for ArgumentType {
        const NAME: &'static str = "ArgumentType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ArgumentType> {
            match value {
                0 => ::std::option::Option::Some(ArgumentType::Int),
                1 => ::std::option::Option::Some(ArgumentType::Float),
                2 => ::std::option::Option::Some(ArgumentType::Long),
                3 => ::std::option::Option::Some(ArgumentType::Double),
                4 => ::std::option::Option::Some(ArgumentType::Bool),
                5 => ::std::option::Option::Some(ArgumentType::Color),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ArgumentType] = &[
            ArgumentType::Int,
            ArgumentType::Float,
            ArgumentType::Long,
            ArgumentType::Double,
            ArgumentType::Bool,
            ArgumentType::Color,
        ];
    }

    impl ::protobuf::EnumFull for ArgumentType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OscNodeConfig.ArgumentType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ArgumentType {
        fn default() -> Self {
            ArgumentType::Int
        }
    }

    impl ArgumentType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ArgumentType>("OscNodeConfig.ArgumentType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.VideoColorBalanceNodeConfig)
pub struct VideoColorBalanceNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.VideoColorBalanceNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoColorBalanceNodeConfig {
    fn default() -> &'a VideoColorBalanceNodeConfig {
        <VideoColorBalanceNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoColorBalanceNodeConfig {
    pub fn new() -> VideoColorBalanceNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoColorBalanceNodeConfig>(
            "VideoColorBalanceNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoColorBalanceNodeConfig {
    const NAME: &'static str = "VideoColorBalanceNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoColorBalanceNodeConfig {
        VideoColorBalanceNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoColorBalanceNodeConfig {
        static instance: VideoColorBalanceNodeConfig = VideoColorBalanceNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoColorBalanceNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoColorBalanceNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoColorBalanceNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoColorBalanceNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.VideoEffectNodeConfig)
pub struct VideoEffectNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.VideoEffectNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoEffectNodeConfig {
    fn default() -> &'a VideoEffectNodeConfig {
        <VideoEffectNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoEffectNodeConfig {
    pub fn new() -> VideoEffectNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoEffectNodeConfig>(
            "VideoEffectNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoEffectNodeConfig {
    const NAME: &'static str = "VideoEffectNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoEffectNodeConfig {
        VideoEffectNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoEffectNodeConfig {
        static instance: VideoEffectNodeConfig = VideoEffectNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoEffectNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoEffectNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoEffectNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoEffectNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.VideoFileNodeConfig)
pub struct VideoFileNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.VideoFileNodeConfig.file)
    pub file: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.VideoFileNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoFileNodeConfig {
    fn default() -> &'a VideoFileNodeConfig {
        <VideoFileNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoFileNodeConfig {
    pub fn new() -> VideoFileNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file",
            |m: &VideoFileNodeConfig| { &m.file },
            |m: &mut VideoFileNodeConfig| { &mut m.file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoFileNodeConfig>(
            "VideoFileNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoFileNodeConfig {
    const NAME: &'static str = "VideoFileNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoFileNodeConfig {
        VideoFileNodeConfig::new()
    }

    fn clear(&mut self) {
        self.file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoFileNodeConfig {
        static instance: VideoFileNodeConfig = VideoFileNodeConfig {
            file: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoFileNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoFileNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoFileNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoFileNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.VideoOutputNodeConfig)
pub struct VideoOutputNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.VideoOutputNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoOutputNodeConfig {
    fn default() -> &'a VideoOutputNodeConfig {
        <VideoOutputNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoOutputNodeConfig {
    pub fn new() -> VideoOutputNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoOutputNodeConfig>(
            "VideoOutputNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoOutputNodeConfig {
    const NAME: &'static str = "VideoOutputNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoOutputNodeConfig {
        VideoOutputNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoOutputNodeConfig {
        static instance: VideoOutputNodeConfig = VideoOutputNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoOutputNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoOutputNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoOutputNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoOutputNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.VideoTransformNodeConfig)
pub struct VideoTransformNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.VideoTransformNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoTransformNodeConfig {
    fn default() -> &'a VideoTransformNodeConfig {
        <VideoTransformNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl VideoTransformNodeConfig {
    pub fn new() -> VideoTransformNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoTransformNodeConfig>(
            "VideoTransformNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoTransformNodeConfig {
    const NAME: &'static str = "VideoTransformNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoTransformNodeConfig {
        VideoTransformNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoTransformNodeConfig {
        static instance: VideoTransformNodeConfig = VideoTransformNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoTransformNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoTransformNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoTransformNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoTransformNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.SelectNodeConfig)
pub struct SelectNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.SelectNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectNodeConfig {
    fn default() -> &'a SelectNodeConfig {
        <SelectNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl SelectNodeConfig {
    pub fn new() -> SelectNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectNodeConfig>(
            "SelectNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectNodeConfig {
    const NAME: &'static str = "SelectNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectNodeConfig {
        SelectNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectNodeConfig {
        static instance: SelectNodeConfig = SelectNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MergeNodeConfig)
pub struct MergeNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.MergeNodeConfig.mode)
    pub mode: ::protobuf::EnumOrUnknown<merge_node_config::MergeMode>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MergeNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MergeNodeConfig {
    fn default() -> &'a MergeNodeConfig {
        <MergeNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl MergeNodeConfig {
    pub fn new() -> MergeNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &MergeNodeConfig| { &m.mode },
            |m: &mut MergeNodeConfig| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MergeNodeConfig>(
            "MergeNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MergeNodeConfig {
    const NAME: &'static str = "MergeNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mode != ::protobuf::EnumOrUnknown::new(merge_node_config::MergeMode::Latest) {
            my_size += ::protobuf::rt::int32_size(1, self.mode.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mode != ::protobuf::EnumOrUnknown::new(merge_node_config::MergeMode::Latest) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MergeNodeConfig {
        MergeNodeConfig::new()
    }

    fn clear(&mut self) {
        self.mode = ::protobuf::EnumOrUnknown::new(merge_node_config::MergeMode::Latest);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MergeNodeConfig {
        static instance: MergeNodeConfig = MergeNodeConfig {
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MergeNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MergeNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MergeNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MergeNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MergeNodeConfig`
pub mod merge_node_config {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.MergeNodeConfig.MergeMode)
    pub enum MergeMode {
        // @@protoc_insertion_point(enum_value:mizer.nodes.MergeNodeConfig.MergeMode.Latest)
        Latest = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.MergeNodeConfig.MergeMode.Highest)
        Highest = 1,
        // @@protoc_insertion_point(enum_value:mizer.nodes.MergeNodeConfig.MergeMode.Lowest)
        Lowest = 2,
    }

    impl ::protobuf::Enum for MergeMode {
        const NAME: &'static str = "MergeMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MergeMode> {
            match value {
                0 => ::std::option::Option::Some(MergeMode::Latest),
                1 => ::std::option::Option::Some(MergeMode::Highest),
                2 => ::std::option::Option::Some(MergeMode::Lowest),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MergeMode] = &[
            MergeMode::Latest,
            MergeMode::Highest,
            MergeMode::Lowest,
        ];
    }

    impl ::protobuf::EnumFull for MergeMode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MergeNodeConfig.MergeMode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MergeMode {
        fn default() -> Self {
            MergeMode::Latest
        }
    }

    impl MergeMode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MergeMode>("MergeNodeConfig.MergeMode")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ThresholdNodeConfig)
pub struct ThresholdNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.ThresholdNodeConfig.lower_threshold)
    pub lower_threshold: f64,
    // @@protoc_insertion_point(field:mizer.nodes.ThresholdNodeConfig.upper_threshold)
    pub upper_threshold: f64,
    // @@protoc_insertion_point(field:mizer.nodes.ThresholdNodeConfig.active_value)
    pub active_value: f64,
    // @@protoc_insertion_point(field:mizer.nodes.ThresholdNodeConfig.inactive_value)
    pub inactive_value: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ThresholdNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ThresholdNodeConfig {
    fn default() -> &'a ThresholdNodeConfig {
        <ThresholdNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ThresholdNodeConfig {
    pub fn new() -> ThresholdNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lower_threshold",
            |m: &ThresholdNodeConfig| { &m.lower_threshold },
            |m: &mut ThresholdNodeConfig| { &mut m.lower_threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upper_threshold",
            |m: &ThresholdNodeConfig| { &m.upper_threshold },
            |m: &mut ThresholdNodeConfig| { &mut m.upper_threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_value",
            |m: &ThresholdNodeConfig| { &m.active_value },
            |m: &mut ThresholdNodeConfig| { &mut m.active_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inactive_value",
            |m: &ThresholdNodeConfig| { &m.inactive_value },
            |m: &mut ThresholdNodeConfig| { &mut m.inactive_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ThresholdNodeConfig>(
            "ThresholdNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ThresholdNodeConfig {
    const NAME: &'static str = "ThresholdNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lower_threshold = is.read_double()?;
                },
                17 => {
                    self.upper_threshold = is.read_double()?;
                },
                25 => {
                    self.active_value = is.read_double()?;
                },
                33 => {
                    self.inactive_value = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.lower_threshold != 0. {
            my_size += 1 + 8;
        }
        if self.upper_threshold != 0. {
            my_size += 1 + 8;
        }
        if self.active_value != 0. {
            my_size += 1 + 8;
        }
        if self.inactive_value != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.lower_threshold != 0. {
            os.write_double(1, self.lower_threshold)?;
        }
        if self.upper_threshold != 0. {
            os.write_double(2, self.upper_threshold)?;
        }
        if self.active_value != 0. {
            os.write_double(3, self.active_value)?;
        }
        if self.inactive_value != 0. {
            os.write_double(4, self.inactive_value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ThresholdNodeConfig {
        ThresholdNodeConfig::new()
    }

    fn clear(&mut self) {
        self.lower_threshold = 0.;
        self.upper_threshold = 0.;
        self.active_value = 0.;
        self.inactive_value = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ThresholdNodeConfig {
        static instance: ThresholdNodeConfig = ThresholdNodeConfig {
            lower_threshold: 0.,
            upper_threshold: 0.,
            active_value: 0.,
            inactive_value: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ThresholdNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ThresholdNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ThresholdNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThresholdNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.EncoderNodeConfig)
pub struct EncoderNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.EncoderNodeConfig.hold_rate)
    pub hold_rate: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.EncoderNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EncoderNodeConfig {
    fn default() -> &'a EncoderNodeConfig {
        <EncoderNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl EncoderNodeConfig {
    pub fn new() -> EncoderNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hold_rate",
            |m: &EncoderNodeConfig| { &m.hold_rate },
            |m: &mut EncoderNodeConfig| { &mut m.hold_rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EncoderNodeConfig>(
            "EncoderNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EncoderNodeConfig {
    const NAME: &'static str = "EncoderNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.hold_rate = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.hold_rate != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.hold_rate != 0. {
            os.write_double(1, self.hold_rate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EncoderNodeConfig {
        EncoderNodeConfig::new()
    }

    fn clear(&mut self) {
        self.hold_rate = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EncoderNodeConfig {
        static instance: EncoderNodeConfig = EncoderNodeConfig {
            hold_rate: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EncoderNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EncoderNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EncoderNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncoderNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ColorRgbNodeConfig)
pub struct ColorRgbNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ColorRgbNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorRgbNodeConfig {
    fn default() -> &'a ColorRgbNodeConfig {
        <ColorRgbNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ColorRgbNodeConfig {
    pub fn new() -> ColorRgbNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorRgbNodeConfig>(
            "ColorRgbNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorRgbNodeConfig {
    const NAME: &'static str = "ColorRgbNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorRgbNodeConfig {
        ColorRgbNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorRgbNodeConfig {
        static instance: ColorRgbNodeConfig = ColorRgbNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorRgbNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorRgbNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorRgbNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorRgbNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ColorHsvNodeConfig)
pub struct ColorHsvNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ColorHsvNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ColorHsvNodeConfig {
    fn default() -> &'a ColorHsvNodeConfig {
        <ColorHsvNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ColorHsvNodeConfig {
    pub fn new() -> ColorHsvNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ColorHsvNodeConfig>(
            "ColorHsvNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ColorHsvNodeConfig {
    const NAME: &'static str = "ColorHsvNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ColorHsvNodeConfig {
        ColorHsvNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ColorHsvNodeConfig {
        static instance: ColorHsvNodeConfig = ColorHsvNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ColorHsvNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ColorHsvNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ColorHsvNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorHsvNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ContainerNodeConfig)
pub struct ContainerNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.ContainerNodeConfig.nodes)
    pub nodes: ::std::vec::Vec<Node>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ContainerNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerNodeConfig {
    fn default() -> &'a ContainerNodeConfig {
        <ContainerNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ContainerNodeConfig {
    pub fn new() -> ContainerNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &ContainerNodeConfig| { &m.nodes },
            |m: &mut ContainerNodeConfig| { &mut m.nodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerNodeConfig>(
            "ContainerNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerNodeConfig {
    const NAME: &'static str = "ContainerNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nodes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerNodeConfig {
        ContainerNodeConfig::new()
    }

    fn clear(&mut self) {
        self.nodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerNodeConfig {
        static instance: ContainerNodeConfig = ContainerNodeConfig {
            nodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainerNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MathNodeConfig)
pub struct MathNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.MathNodeConfig.mode)
    pub mode: ::protobuf::EnumOrUnknown<math_node_config::Mode>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MathNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MathNodeConfig {
    fn default() -> &'a MathNodeConfig {
        <MathNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl MathNodeConfig {
    pub fn new() -> MathNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &MathNodeConfig| { &m.mode },
            |m: &mut MathNodeConfig| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MathNodeConfig>(
            "MathNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MathNodeConfig {
    const NAME: &'static str = "MathNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mode != ::protobuf::EnumOrUnknown::new(math_node_config::Mode::Addition) {
            my_size += ::protobuf::rt::int32_size(1, self.mode.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mode != ::protobuf::EnumOrUnknown::new(math_node_config::Mode::Addition) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MathNodeConfig {
        MathNodeConfig::new()
    }

    fn clear(&mut self) {
        self.mode = ::protobuf::EnumOrUnknown::new(math_node_config::Mode::Addition);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MathNodeConfig {
        static instance: MathNodeConfig = MathNodeConfig {
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MathNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MathNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MathNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MathNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MathNodeConfig`
pub mod math_node_config {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.MathNodeConfig.Mode)
    pub enum Mode {
        // @@protoc_insertion_point(enum_value:mizer.nodes.MathNodeConfig.Mode.Addition)
        Addition = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.MathNodeConfig.Mode.Subtraction)
        Subtraction = 1,
        // @@protoc_insertion_point(enum_value:mizer.nodes.MathNodeConfig.Mode.Multiplication)
        Multiplication = 2,
        // @@protoc_insertion_point(enum_value:mizer.nodes.MathNodeConfig.Mode.Division)
        Division = 3,
        // @@protoc_insertion_point(enum_value:mizer.nodes.MathNodeConfig.Mode.Invert)
        Invert = 4,
        // @@protoc_insertion_point(enum_value:mizer.nodes.MathNodeConfig.Mode.Sine)
        Sine = 5,
        // @@protoc_insertion_point(enum_value:mizer.nodes.MathNodeConfig.Mode.Cosine)
        Cosine = 6,
        // @@protoc_insertion_point(enum_value:mizer.nodes.MathNodeConfig.Mode.Tangent)
        Tangent = 7,
    }

    impl ::protobuf::Enum for Mode {
        const NAME: &'static str = "Mode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Mode> {
            match value {
                0 => ::std::option::Option::Some(Mode::Addition),
                1 => ::std::option::Option::Some(Mode::Subtraction),
                2 => ::std::option::Option::Some(Mode::Multiplication),
                3 => ::std::option::Option::Some(Mode::Division),
                4 => ::std::option::Option::Some(Mode::Invert),
                5 => ::std::option::Option::Some(Mode::Sine),
                6 => ::std::option::Option::Some(Mode::Cosine),
                7 => ::std::option::Option::Some(Mode::Tangent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Mode] = &[
            Mode::Addition,
            Mode::Subtraction,
            Mode::Multiplication,
            Mode::Division,
            Mode::Invert,
            Mode::Sine,
            Mode::Cosine,
            Mode::Tangent,
        ];
    }

    impl ::protobuf::EnumFull for Mode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MathNodeConfig.Mode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Mode {
        fn default() -> Self {
            Mode::Addition
        }
    }

    impl Mode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Mode>("MathNodeConfig.Mode")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MqttInputNodeConfig)
pub struct MqttInputNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.MqttInputNodeConfig.connection)
    pub connection: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.MqttInputNodeConfig.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MqttInputNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MqttInputNodeConfig {
    fn default() -> &'a MqttInputNodeConfig {
        <MqttInputNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl MqttInputNodeConfig {
    pub fn new() -> MqttInputNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connection",
            |m: &MqttInputNodeConfig| { &m.connection },
            |m: &mut MqttInputNodeConfig| { &mut m.connection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &MqttInputNodeConfig| { &m.path },
            |m: &mut MqttInputNodeConfig| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MqttInputNodeConfig>(
            "MqttInputNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MqttInputNodeConfig {
    const NAME: &'static str = "MqttInputNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection = is.read_string()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.connection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.connection);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.connection.is_empty() {
            os.write_string(1, &self.connection)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MqttInputNodeConfig {
        MqttInputNodeConfig::new()
    }

    fn clear(&mut self) {
        self.connection.clear();
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MqttInputNodeConfig {
        static instance: MqttInputNodeConfig = MqttInputNodeConfig {
            connection: ::std::string::String::new(),
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MqttInputNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MqttInputNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MqttInputNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MqttInputNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MqttOutputNodeConfig)
pub struct MqttOutputNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.MqttOutputNodeConfig.connection)
    pub connection: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.MqttOutputNodeConfig.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MqttOutputNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MqttOutputNodeConfig {
    fn default() -> &'a MqttOutputNodeConfig {
        <MqttOutputNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl MqttOutputNodeConfig {
    pub fn new() -> MqttOutputNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connection",
            |m: &MqttOutputNodeConfig| { &m.connection },
            |m: &mut MqttOutputNodeConfig| { &mut m.connection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &MqttOutputNodeConfig| { &m.path },
            |m: &mut MqttOutputNodeConfig| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MqttOutputNodeConfig>(
            "MqttOutputNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MqttOutputNodeConfig {
    const NAME: &'static str = "MqttOutputNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection = is.read_string()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.connection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.connection);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.connection.is_empty() {
            os.write_string(1, &self.connection)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MqttOutputNodeConfig {
        MqttOutputNodeConfig::new()
    }

    fn clear(&mut self) {
        self.connection.clear();
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MqttOutputNodeConfig {
        static instance: MqttOutputNodeConfig = MqttOutputNodeConfig {
            connection: ::std::string::String::new(),
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MqttOutputNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MqttOutputNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MqttOutputNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MqttOutputNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NumberToDataNodeConfig)
pub struct NumberToDataNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NumberToDataNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NumberToDataNodeConfig {
    fn default() -> &'a NumberToDataNodeConfig {
        <NumberToDataNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl NumberToDataNodeConfig {
    pub fn new() -> NumberToDataNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NumberToDataNodeConfig>(
            "NumberToDataNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NumberToDataNodeConfig {
    const NAME: &'static str = "NumberToDataNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NumberToDataNodeConfig {
        NumberToDataNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NumberToDataNodeConfig {
        static instance: NumberToDataNodeConfig = NumberToDataNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NumberToDataNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NumberToDataNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NumberToDataNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberToDataNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.DataToNumberNodeConfig)
pub struct DataToNumberNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.DataToNumberNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataToNumberNodeConfig {
    fn default() -> &'a DataToNumberNodeConfig {
        <DataToNumberNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl DataToNumberNodeConfig {
    pub fn new() -> DataToNumberNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataToNumberNodeConfig>(
            "DataToNumberNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataToNumberNodeConfig {
    const NAME: &'static str = "DataToNumberNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataToNumberNodeConfig {
        DataToNumberNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataToNumberNodeConfig {
        static instance: DataToNumberNodeConfig = DataToNumberNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DataToNumberNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataToNumberNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataToNumberNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataToNumberNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ValueNodeConfig)
pub struct ValueNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.ValueNodeConfig.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ValueNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValueNodeConfig {
    fn default() -> &'a ValueNodeConfig {
        <ValueNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ValueNodeConfig {
    pub fn new() -> ValueNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &ValueNodeConfig| { &m.value },
            |m: &mut ValueNodeConfig| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValueNodeConfig>(
            "ValueNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValueNodeConfig {
    const NAME: &'static str = "ValueNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValueNodeConfig {
        ValueNodeConfig::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValueNodeConfig {
        static instance: ValueNodeConfig = ValueNodeConfig {
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValueNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValueNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValueNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.PlanScreenNodeConfig)
pub struct PlanScreenNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.PlanScreenNodeConfig.plan_id)
    pub plan_id: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.PlanScreenNodeConfig.screen_id)
    pub screen_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.PlanScreenNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlanScreenNodeConfig {
    fn default() -> &'a PlanScreenNodeConfig {
        <PlanScreenNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl PlanScreenNodeConfig {
    pub fn new() -> PlanScreenNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "plan_id",
            |m: &PlanScreenNodeConfig| { &m.plan_id },
            |m: &mut PlanScreenNodeConfig| { &mut m.plan_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "screen_id",
            |m: &PlanScreenNodeConfig| { &m.screen_id },
            |m: &mut PlanScreenNodeConfig| { &mut m.screen_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlanScreenNodeConfig>(
            "PlanScreenNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlanScreenNodeConfig {
    const NAME: &'static str = "PlanScreenNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.plan_id = is.read_string()?;
                },
                16 => {
                    self.screen_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.plan_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.plan_id);
        }
        if self.screen_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.screen_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.plan_id.is_empty() {
            os.write_string(1, &self.plan_id)?;
        }
        if self.screen_id != 0 {
            os.write_uint32(2, self.screen_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlanScreenNodeConfig {
        PlanScreenNodeConfig::new()
    }

    fn clear(&mut self) {
        self.plan_id.clear();
        self.screen_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlanScreenNodeConfig {
        static instance: PlanScreenNodeConfig = PlanScreenNodeConfig {
            plan_id: ::std::string::String::new(),
            screen_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlanScreenNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlanScreenNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlanScreenNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlanScreenNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.DelayNodeConfig)
pub struct DelayNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.DelayNodeConfig.buffer_size)
    pub buffer_size: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.DelayNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DelayNodeConfig {
    fn default() -> &'a DelayNodeConfig {
        <DelayNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl DelayNodeConfig {
    pub fn new() -> DelayNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buffer_size",
            |m: &DelayNodeConfig| { &m.buffer_size },
            |m: &mut DelayNodeConfig| { &mut m.buffer_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DelayNodeConfig>(
            "DelayNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DelayNodeConfig {
    const NAME: &'static str = "DelayNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.buffer_size = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.buffer_size != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.buffer_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.buffer_size != 0 {
            os.write_uint32(1, self.buffer_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DelayNodeConfig {
        DelayNodeConfig::new()
    }

    fn clear(&mut self) {
        self.buffer_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DelayNodeConfig {
        static instance: DelayNodeConfig = DelayNodeConfig {
            buffer_size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DelayNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DelayNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DelayNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelayNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.RampNodeConfig)
pub struct RampNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.RampNodeConfig.steps)
    pub steps: ::std::vec::Vec<ramp_node_config::RampStep>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.RampNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RampNodeConfig {
    fn default() -> &'a RampNodeConfig {
        <RampNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl RampNodeConfig {
    pub fn new() -> RampNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &RampNodeConfig| { &m.steps },
            |m: &mut RampNodeConfig| { &mut m.steps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RampNodeConfig>(
            "RampNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RampNodeConfig {
    const NAME: &'static str = "RampNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.steps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RampNodeConfig {
        RampNodeConfig::new()
    }

    fn clear(&mut self) {
        self.steps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RampNodeConfig {
        static instance: RampNodeConfig = RampNodeConfig {
            steps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RampNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RampNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RampNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RampNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RampNodeConfig`
pub mod ramp_node_config {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.RampNodeConfig.RampStep)
    pub struct RampStep {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.RampNodeConfig.RampStep.x)
        pub x: f64,
        // @@protoc_insertion_point(field:mizer.nodes.RampNodeConfig.RampStep.y)
        pub y: f64,
        // @@protoc_insertion_point(field:mizer.nodes.RampNodeConfig.RampStep.c0a)
        pub c0a: f64,
        // @@protoc_insertion_point(field:mizer.nodes.RampNodeConfig.RampStep.c0b)
        pub c0b: f64,
        // @@protoc_insertion_point(field:mizer.nodes.RampNodeConfig.RampStep.c1a)
        pub c1a: f64,
        // @@protoc_insertion_point(field:mizer.nodes.RampNodeConfig.RampStep.c1b)
        pub c1b: f64,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.RampNodeConfig.RampStep.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RampStep {
        fn default() -> &'a RampStep {
            <RampStep as ::protobuf::Message>::default_instance()
        }
    }

    impl RampStep {
        pub fn new() -> RampStep {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "x",
                |m: &RampStep| { &m.x },
                |m: &mut RampStep| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "y",
                |m: &RampStep| { &m.y },
                |m: &mut RampStep| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "c0a",
                |m: &RampStep| { &m.c0a },
                |m: &mut RampStep| { &mut m.c0a },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "c0b",
                |m: &RampStep| { &m.c0b },
                |m: &mut RampStep| { &mut m.c0b },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "c1a",
                |m: &RampStep| { &m.c1a },
                |m: &mut RampStep| { &mut m.c1a },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "c1b",
                |m: &RampStep| { &m.c1b },
                |m: &mut RampStep| { &mut m.c1b },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RampStep>(
                "RampNodeConfig.RampStep",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RampStep {
        const NAME: &'static str = "RampStep";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.x = is.read_double()?;
                    },
                    17 => {
                        self.y = is.read_double()?;
                    },
                    25 => {
                        self.c0a = is.read_double()?;
                    },
                    33 => {
                        self.c0b = is.read_double()?;
                    },
                    41 => {
                        self.c1a = is.read_double()?;
                    },
                    49 => {
                        self.c1b = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.x != 0. {
                my_size += 1 + 8;
            }
            if self.y != 0. {
                my_size += 1 + 8;
            }
            if self.c0a != 0. {
                my_size += 1 + 8;
            }
            if self.c0b != 0. {
                my_size += 1 + 8;
            }
            if self.c1a != 0. {
                my_size += 1 + 8;
            }
            if self.c1b != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.x != 0. {
                os.write_double(1, self.x)?;
            }
            if self.y != 0. {
                os.write_double(2, self.y)?;
            }
            if self.c0a != 0. {
                os.write_double(3, self.c0a)?;
            }
            if self.c0b != 0. {
                os.write_double(4, self.c0b)?;
            }
            if self.c1a != 0. {
                os.write_double(5, self.c1a)?;
            }
            if self.c1b != 0. {
                os.write_double(6, self.c1b)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RampStep {
            RampStep::new()
        }

        fn clear(&mut self) {
            self.x = 0.;
            self.y = 0.;
            self.c0a = 0.;
            self.c0b = 0.;
            self.c1a = 0.;
            self.c1b = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RampStep {
            static instance: RampStep = RampStep {
                x: 0.,
                y: 0.,
                c0a: 0.,
                c0b: 0.,
                c1a: 0.,
                c1b: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RampStep {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("RampNodeConfig.RampStep").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RampStep {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RampStep {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NoiseNodeConfig)
pub struct NoiseNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.NoiseNodeConfig.tick_rate)
    pub tick_rate: u64,
    // @@protoc_insertion_point(field:mizer.nodes.NoiseNodeConfig.fade)
    pub fade: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NoiseNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NoiseNodeConfig {
    fn default() -> &'a NoiseNodeConfig {
        <NoiseNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl NoiseNodeConfig {
    pub fn new() -> NoiseNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tick_rate",
            |m: &NoiseNodeConfig| { &m.tick_rate },
            |m: &mut NoiseNodeConfig| { &mut m.tick_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fade",
            |m: &NoiseNodeConfig| { &m.fade },
            |m: &mut NoiseNodeConfig| { &mut m.fade },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoiseNodeConfig>(
            "NoiseNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NoiseNodeConfig {
    const NAME: &'static str = "NoiseNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick_rate = is.read_uint64()?;
                },
                16 => {
                    self.fade = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.tick_rate != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.tick_rate);
        }
        if self.fade != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.tick_rate != 0 {
            os.write_uint64(1, self.tick_rate)?;
        }
        if self.fade != false {
            os.write_bool(2, self.fade)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NoiseNodeConfig {
        NoiseNodeConfig::new()
    }

    fn clear(&mut self) {
        self.tick_rate = 0;
        self.fade = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NoiseNodeConfig {
        static instance: NoiseNodeConfig = NoiseNodeConfig {
            tick_rate: 0,
            fade: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NoiseNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NoiseNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NoiseNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoiseNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.LabelNodeConfig)
pub struct LabelNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.LabelNodeConfig.text)
    pub text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.LabelNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelNodeConfig {
    fn default() -> &'a LabelNodeConfig {
        <LabelNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl LabelNodeConfig {
    pub fn new() -> LabelNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &LabelNodeConfig| { &m.text },
            |m: &mut LabelNodeConfig| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelNodeConfig>(
            "LabelNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelNodeConfig {
    const NAME: &'static str = "LabelNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelNodeConfig {
        LabelNodeConfig::new()
    }

    fn clear(&mut self) {
        self.text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelNodeConfig {
        static instance: LabelNodeConfig = LabelNodeConfig {
            text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.TransportNodeConfig)
pub struct TransportNodeConfig {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.TransportNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransportNodeConfig {
    fn default() -> &'a TransportNodeConfig {
        <TransportNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl TransportNodeConfig {
    pub fn new() -> TransportNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransportNodeConfig>(
            "TransportNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransportNodeConfig {
    const NAME: &'static str = "TransportNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransportNodeConfig {
        TransportNodeConfig::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransportNodeConfig {
        static instance: TransportNodeConfig = TransportNodeConfig {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransportNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransportNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransportNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransportNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodePosition)
pub struct NodePosition {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.NodePosition.x)
    pub x: f64,
    // @@protoc_insertion_point(field:mizer.nodes.NodePosition.y)
    pub y: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodePosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodePosition {
    fn default() -> &'a NodePosition {
        <NodePosition as ::protobuf::Message>::default_instance()
    }
}

impl NodePosition {
    pub fn new() -> NodePosition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &NodePosition| { &m.x },
            |m: &mut NodePosition| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &NodePosition| { &m.y },
            |m: &mut NodePosition| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodePosition>(
            "NodePosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodePosition {
    const NAME: &'static str = "NodePosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = is.read_double()?;
                },
                17 => {
                    self.y = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 1 + 8;
        }
        if self.y != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0. {
            os.write_double(1, self.x)?;
        }
        if self.y != 0. {
            os.write_double(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodePosition {
        NodePosition::new()
    }

    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodePosition {
        static instance: NodePosition = NodePosition {
            x: 0.,
            y: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodePosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodePosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodePosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodeDesigner)
pub struct NodeDesigner {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.NodeDesigner.position)
    pub position: ::protobuf::MessageField<NodePosition>,
    // @@protoc_insertion_point(field:mizer.nodes.NodeDesigner.scale)
    pub scale: f64,
    // @@protoc_insertion_point(field:mizer.nodes.NodeDesigner.hidden)
    pub hidden: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodeDesigner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeDesigner {
    fn default() -> &'a NodeDesigner {
        <NodeDesigner as ::protobuf::Message>::default_instance()
    }
}

impl NodeDesigner {
    pub fn new() -> NodeDesigner {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodePosition>(
            "position",
            |m: &NodeDesigner| { &m.position },
            |m: &mut NodeDesigner| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scale",
            |m: &NodeDesigner| { &m.scale },
            |m: &mut NodeDesigner| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hidden",
            |m: &NodeDesigner| { &m.hidden },
            |m: &mut NodeDesigner| { &mut m.hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeDesigner>(
            "NodeDesigner",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeDesigner {
    const NAME: &'static str = "NodeDesigner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                17 => {
                    self.scale = is.read_double()?;
                },
                24 => {
                    self.hidden = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.scale != 0. {
            my_size += 1 + 8;
        }
        if self.hidden != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.scale != 0. {
            os.write_double(2, self.scale)?;
        }
        if self.hidden != false {
            os.write_bool(3, self.hidden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeDesigner {
        NodeDesigner::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.scale = 0.;
        self.hidden = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeDesigner {
        static instance: NodeDesigner = NodeDesigner {
            position: ::protobuf::MessageField::none(),
            scale: 0.,
            hidden: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeDesigner {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeDesigner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeDesigner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeDesigner {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.Port)
pub struct Port {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.Port.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.Port.protocol)
    pub protocol: ::protobuf::EnumOrUnknown<ChannelProtocol>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.Port.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Port {
    fn default() -> &'a Port {
        <Port as ::protobuf::Message>::default_instance()
    }
}

impl Port {
    pub fn new() -> Port {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Port| { &m.name },
            |m: &mut Port| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol",
            |m: &Port| { &m.protocol },
            |m: &mut Port| { &mut m.protocol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Port>(
            "Port",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Port {
    const NAME: &'static str = "Port";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.protocol = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE) {
            my_size += ::protobuf::rt::int32_size(2, self.protocol.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.protocol))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Port {
        Port::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.protocol = ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Port {
        static instance: Port = Port {
            name: ::std::string::String::new(),
            protocol: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Port {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Port").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Port {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Port {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:mizer.nodes.ChannelProtocol)
pub enum ChannelProtocol {
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.SINGLE)
    SINGLE = 0,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.MULTI)
    MULTI = 1,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.COLOR)
    COLOR = 9,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.TEXTURE)
    TEXTURE = 2,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.VECTOR)
    VECTOR = 3,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.LASER)
    LASER = 4,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.POLY)
    POLY = 5,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.DATA)
    DATA = 6,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.MATERIAL)
    MATERIAL = 7,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.GST)
    GST = 8,
}

impl ::protobuf::Enum for ChannelProtocol {
    const NAME: &'static str = "ChannelProtocol";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelProtocol> {
        match value {
            0 => ::std::option::Option::Some(ChannelProtocol::SINGLE),
            1 => ::std::option::Option::Some(ChannelProtocol::MULTI),
            9 => ::std::option::Option::Some(ChannelProtocol::COLOR),
            2 => ::std::option::Option::Some(ChannelProtocol::TEXTURE),
            3 => ::std::option::Option::Some(ChannelProtocol::VECTOR),
            4 => ::std::option::Option::Some(ChannelProtocol::LASER),
            5 => ::std::option::Option::Some(ChannelProtocol::POLY),
            6 => ::std::option::Option::Some(ChannelProtocol::DATA),
            7 => ::std::option::Option::Some(ChannelProtocol::MATERIAL),
            8 => ::std::option::Option::Some(ChannelProtocol::GST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ChannelProtocol] = &[
        ChannelProtocol::SINGLE,
        ChannelProtocol::MULTI,
        ChannelProtocol::COLOR,
        ChannelProtocol::TEXTURE,
        ChannelProtocol::VECTOR,
        ChannelProtocol::LASER,
        ChannelProtocol::POLY,
        ChannelProtocol::DATA,
        ChannelProtocol::MATERIAL,
        ChannelProtocol::GST,
    ];
}

impl ::protobuf::EnumFull for ChannelProtocol {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ChannelProtocol").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ChannelProtocol::SINGLE => 0,
            ChannelProtocol::MULTI => 1,
            ChannelProtocol::COLOR => 2,
            ChannelProtocol::TEXTURE => 3,
            ChannelProtocol::VECTOR => 4,
            ChannelProtocol::LASER => 5,
            ChannelProtocol::POLY => 6,
            ChannelProtocol::DATA => 7,
            ChannelProtocol::MATERIAL => 8,
            ChannelProtocol::GST => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ChannelProtocol {
    fn default() -> Self {
        ChannelProtocol::SINGLE
    }
}

impl ChannelProtocol {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ChannelProtocol>("ChannelProtocol")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bnodes.proto\x12\x0bmizer.nodes\"\x9f\x01\n\x0eAddNodeRequest\x12.\
    \n\x04type\x18\x01\x20\x01(\x0e2\x1a.mizer.nodes.Node.NodeTypeR\x04type\
    \x125\n\x08position\x18\x02\x20\x01(\x0b2\x19.mizer.nodes.NodePositionR\
    \x08position\x12\x1b\n\x06parent\x18\x03\x20\x01(\tH\0R\x06parent\x88\
    \x01\x01B\t\n\x07_parent\"R\n\x14DuplicateNodeRequest\x12\x12\n\x04path\
    \x18\x01\x20\x01(\tR\x04path\x12\x1b\n\x06parent\x18\x02\x20\x01(\tH\0R\
    \x06parent\x88\x01\x01B\t\n\x07_parent\"\x0e\n\x0cNodesRequest\"L\n\x0cW\
    riteControl\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x12\n\x04p\
    ort\x18\x02\x20\x01(\tR\x04port\x12\x14\n\x05value\x18\x03\x20\x01(\x01R\
    \x05value\"\x0f\n\rWriteResponse\"^\n\x17UpdateNodeConfigRequest\x12\x12\
    \n\x04path\x18\x01\x20\x01(\tR\x04path\x12/\n\x06config\x18\x02\x20\x01(\
    \x0b2\x17.mizer.nodes.NodeConfigR\x06config\"\x1a\n\x18UpdateNodeConfigR\
    esponse\"\\\n\x0fMoveNodeRequest\x12\x12\n\x04path\x18\x01\x20\x01(\tR\
    \x04path\x125\n\x08position\x18\x02\x20\x01(\x0b2\x19.mizer.nodes.NodePo\
    sitionR\x08position\"\x12\n\x10MoveNodeResponse\"\x84\x01\n\x0fShowNodeR\
    equest\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x125\n\x08position\
    \x18\x02\x20\x01(\x0b2\x19.mizer.nodes.NodePositionR\x08position\x12\x1b\
    \n\x06parent\x18\x03\x20\x01(\tH\0R\x06parent\x88\x01\x01B\t\n\x07_paren\
    t\"\x12\n\x10ShowNodeResponse\"'\n\x11DeleteNodeRequest\x12\x12\n\x04pat\
    h\x18\x01\x20\x01(\tR\x04path\"\x14\n\x12DeleteNodeResponse\"%\n\x0fHide\
    NodeRequest\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\"\x12\n\x10Hid\
    eNodeResponse\"\x99\x01\n\x05Nodes\x12'\n\x05nodes\x18\x01\x20\x03(\x0b2\
    \x11.mizer.nodes.NodeR\x05nodes\x127\n\x08channels\x18\x02\x20\x03(\x0b2\
    \x1b.mizer.nodes.NodeConnectionR\x08channels\x12.\n\tall_nodes\x18\x03\
    \x20\x03(\x0b2\x11.mizer.nodes.NodeR\x08allNodes\"\xf0\x01\n\x0eNodeConn\
    ection\x12\x1e\n\ntargetNode\x18\x01\x20\x01(\tR\ntargetNode\x121\n\ntar\
    getPort\x18\x02\x20\x01(\x0b2\x11.mizer.nodes.PortR\ntargetPort\x12\x1e\
    \n\nsourceNode\x18\x03\x20\x01(\tR\nsourceNode\x121\n\nsourcePort\x18\
    \x04\x20\x01(\x0b2\x11.mizer.nodes.PortR\nsourcePort\x128\n\x08protocol\
    \x18\x05\x20\x01(\x0e2\x1c.mizer.nodes.ChannelProtocolR\x08protocol\"\
    \xc2\x08\n\x04Node\x12.\n\x04type\x18\x01\x20\x01(\x0e2\x1a.mizer.nodes.\
    Node.NodeTypeR\x04type\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\
    )\n\x06inputs\x18\x03\x20\x03(\x0b2\x11.mizer.nodes.PortR\x06inputs\x12+\
    \n\x07outputs\x18\x04\x20\x03(\x0b2\x11.mizer.nodes.PortR\x07outputs\x12\
    5\n\x08designer\x18\x05\x20\x01(\x0b2\x19.mizer.nodes.NodeDesignerR\x08d\
    esigner\x12;\n\x07preview\x18\x06\x20\x01(\x0e2!.mizer.nodes.Node.NodePr\
    eviewTypeR\x07preview\x12/\n\x06config\x18\x07\x20\x01(\x0b2\x17.mizer.n\
    odes.NodeConfigR\x06config\"\xa5\x05\n\x08NodeType\x12\t\n\x05Fader\x10\
    \0\x12\n\n\x06Button\x10\x01\x12\x0e\n\nOscillator\x10\x02\x12\t\n\x05Cl\
    ock\x10\x03\x12\n\n\x06Script\x10\x04\x12\x0c\n\x08Envelope\x10\x05\x12\
    \x0c\n\x08Sequence\x10\x06\x12\n\n\x06Select\x10\x07\x12\t\n\x05Merge\
    \x10\x08\x12\r\n\tThreshold\x10\t\x12\r\n\tDmxOutput\x10\n\x12\x0c\n\x08\
    OscInput\x10\x0b\x12\r\n\tOscOutput\x10\x0c\x12\r\n\tMidiInput\x10\r\x12\
    \x0e\n\nMidiOutput\x10\x0e\x12\r\n\tSequencer\x10\x0f\x12\x0b\n\x07Fixtu\
    re\x10\x10\x12\x0e\n\nProgrammer\x10\x11\x12\t\n\x05Group\x10\x12\x12\n\
    \n\x06Preset\x10\x13\x12\r\n\tVideoFile\x10\x14\x12\x0f\n\x0bVideoOutput\
    \x10\x15\x12\x0f\n\x0bVideoEffect\x10\x16\x12\x15\n\x11VideoColorBalance\
    \x10\x17\x12\x12\n\x0eVideoTransform\x10\x18\x12\x0e\n\nPixelToDmx\x10\
    \x1e\x12\x10\n\x0cPixelPattern\x10\x1f\x12\r\n\tOpcOutput\x10\x20\x12\t\
    \n\x05Laser\x10(\x12\x0c\n\x08IldaFile\x10)\x12\x0b\n\x07Gamepad\x10-\
    \x12\x0c\n\x08ColorRgb\x102\x12\x0c\n\x08ColorHsv\x103\x12\r\n\tContaine\
    r\x10d\x12\x0b\n\x07Encoder\x107\x12\x08\n\x04Math\x108\x12\x10\n\x0cDat\
    aToNumber\x109\x12\x10\n\x0cNumberToData\x10:\x12\t\n\x05Value\x10;\x12\
    \r\n\tMqttInput\x10<\x12\x0e\n\nMqttOutput\x10=\x12\x0e\n\nPlanScreen\
    \x10>\x12\t\n\x05Delay\x10?\x12\x08\n\x04Ramp\x10@\x12\t\n\x05Noise\x10A\
    \x12\t\n\x05Label\x10B\x12\r\n\tTransport\x10C\"Q\n\x0fNodePreviewType\
    \x12\x0b\n\x07History\x10\0\x12\x0c\n\x08Waveform\x10\x01\x12\x0c\n\x08M\
    ultiple\x10\x02\x12\x0b\n\x07Texture\x10\x03\x12\x08\n\x04None\x10\x04\"\
    \xe9\x1b\n\nNodeConfig\x12O\n\x10oscillatorConfig\x18\n\x20\x01(\x0b2!.m\
    izer.nodes.OscillatorNodeConfigH\0R\x10oscillatorConfig\x12L\n\x0fscript\
    ingConfig\x18\x0b\x20\x01(\x0b2\x20.mizer.nodes.ScriptingNodeConfigH\0R\
    \x0fscriptingConfig\x12I\n\x0esequenceConfig\x18\x0c\x20\x01(\x0b2\x1f.m\
    izer.nodes.SequenceNodeConfigH\0R\x0esequenceConfig\x12@\n\x0bclockConfi\
    g\x18\r\x20\x01(\x0b2\x1c.mizer.nodes.ClockNodeConfigH\0R\x0bclockConfig\
    \x12F\n\rfixtureConfig\x18\x0e\x20\x01(\x0b2\x1e.mizer.nodes.FixtureNode\
    ConfigH\0R\rfixtureConfig\x12C\n\x0cbuttonConfig\x18\x0f\x20\x01(\x0b2\
    \x1d.mizer.nodes.ButtonNodeConfigH\0R\x0cbuttonConfig\x12@\n\x0bfaderCon\
    fig\x18\x10\x20\x01(\x0b2\x1c.mizer.nodes.FaderNodeConfigH\0R\x0bfaderCo\
    nfig\x12I\n\x0eildaFileConfig\x18\x11\x20\x01(\x0b2\x1f.mizer.nodes.Ilda\
    FileNodeConfigH\0R\x0eildaFileConfig\x12@\n\x0blaserConfig\x18\x12\x20\
    \x01(\x0b2\x1c.mizer.nodes.LaserNodeConfigH\0R\x0blaserConfig\x12U\n\x12\
    pixelPatternConfig\x18\x13\x20\x01(\x0b2#.mizer.nodes.PixelPatternNodeCo\
    nfigH\0R\x12pixelPatternConfig\x12I\n\x0epixelDmxConfig\x18\x14\x20\x01(\
    \x0b2\x1f.mizer.nodes.PixelDmxNodeConfigH\0R\x0epixelDmxConfig\x12L\n\
    \x0fdmxOutputConfig\x18\x15\x20\x01(\x0b2\x20.mizer.nodes.DmxOutputNodeC\
    onfigH\0R\x0fdmxOutputConfig\x12G\n\x0fmidiInputConfig\x18\x16\x20\x01(\
    \x0b2\x1b.mizer.nodes.MidiNodeConfigH\0R\x0fmidiInputConfig\x12I\n\x10mi\
    diOutputConfig\x18\x17\x20\x01(\x0b2\x1b.mizer.nodes.MidiNodeConfigH\0R\
    \x10midiOutputConfig\x12L\n\x0fopcOutputConfig\x18\x18\x20\x01(\x0b2\x20\
    .mizer.nodes.OpcOutputNodeConfigH\0R\x0fopcOutputConfig\x12D\n\x0eoscInp\
    utConfig\x18\x19\x20\x01(\x0b2\x1a.mizer.nodes.OscNodeConfigH\0R\x0eoscI\
    nputConfig\x12F\n\x0foscOutputConfig\x18\x1a\x20\x01(\x0b2\x1a.mizer.nod\
    es.OscNodeConfigH\0R\x0foscOutputConfig\x12d\n\x17videoColorBalanceConfi\
    g\x18\x1b\x20\x01(\x0b2(.mizer.nodes.VideoColorBalanceNodeConfigH\0R\x17\
    videoColorBalanceConfig\x12R\n\x11videoEffectConfig\x18\x1c\x20\x01(\x0b\
    2\".mizer.nodes.VideoEffectNodeConfigH\0R\x11videoEffectConfig\x12L\n\
    \x0fvideoFileConfig\x18\x1d\x20\x01(\x0b2\x20.mizer.nodes.VideoFileNodeC\
    onfigH\0R\x0fvideoFileConfig\x12R\n\x11videoOutputConfig\x18\x1e\x20\x01\
    (\x0b2\".mizer.nodes.VideoOutputNodeConfigH\0R\x11videoOutputConfig\x12[\
    \n\x14videoTransformConfig\x18\x1f\x20\x01(\x0b2%.mizer.nodes.VideoTrans\
    formNodeConfigH\0R\x14videoTransformConfig\x12C\n\x0cselectConfig\x18\
    \x20\x20\x01(\x0b2\x1d.mizer.nodes.SelectNodeConfigH\0R\x0cselectConfig\
    \x12@\n\x0bmergeConfig\x18!\x20\x01(\x0b2\x1c.mizer.nodes.MergeNodeConfi\
    gH\0R\x0bmergeConfig\x12I\n\x0eenvelopeConfig\x18\"\x20\x01(\x0b2\x1f.mi\
    zer.nodes.EnvelopeNodeConfigH\0R\x0eenvelopeConfig\x12L\n\x0fsequencerCo\
    nfig\x18#\x20\x01(\x0b2\x20.mizer.nodes.SequencerNodeConfigH\0R\x0fseque\
    ncerConfig\x12O\n\x10programmerConfig\x18$\x20\x01(\x0b2!.mizer.nodes.Pr\
    ogrammerNodeConfigH\0R\x10programmerConfig\x12@\n\x0bgroupConfig\x18%\
    \x20\x01(\x0b2\x1c.mizer.nodes.GroupNodeConfigH\0R\x0bgroupConfig\x12C\n\
    \x0cpresetConfig\x18&\x20\x01(\x0b2\x1d.mizer.nodes.PresetNodeConfigH\0R\
    \x0cpresetConfig\x12I\n\x0ecolorRgbConfig\x18(\x20\x01(\x0b2\x1f.mizer.n\
    odes.ColorRgbNodeConfigH\0R\x0ecolorRgbConfig\x12I\n\x0ecolorHsvConfig\
    \x18)\x20\x01(\x0b2\x1f.mizer.nodes.ColorHsvNodeConfigH\0R\x0ecolorHsvCo\
    nfig\x12N\n\x11gamepadNodeConfig\x18*\x20\x01(\x0b2\x1e.mizer.nodes.Game\
    padNodeConfigH\0R\x11gamepadNodeConfig\x12L\n\x0fthresholdConfig\x18+\
    \x20\x01(\x0b2\x20.mizer.nodes.ThresholdNodeConfigH\0R\x0fthresholdConfi\
    g\x12F\n\rencoderConfig\x18,\x20\x01(\x0b2\x1e.mizer.nodes.EncoderNodeCo\
    nfigH\0R\rencoderConfig\x12L\n\x0fcontainerConfig\x18-\x20\x01(\x0b2\x20\
    .mizer.nodes.ContainerNodeConfigH\0R\x0fcontainerConfig\x12=\n\nmathConf\
    ig\x18.\x20\x01(\x0b2\x1b.mizer.nodes.MathNodeConfigH\0R\nmathConfig\x12\
    L\n\x0fmqttInputConfig\x18/\x20\x01(\x0b2\x20.mizer.nodes.MqttInputNodeC\
    onfigH\0R\x0fmqttInputConfig\x12O\n\x10mqttOutputConfig\x180\x20\x01(\
    \x0b2!.mizer.nodes.MqttOutputNodeConfigH\0R\x10mqttOutputConfig\x12U\n\
    \x12numberToDataConfig\x181\x20\x01(\x0b2#.mizer.nodes.NumberToDataNodeC\
    onfigH\0R\x12numberToDataConfig\x12U\n\x12dataToNumberConfig\x182\x20\
    \x01(\x0b2#.mizer.nodes.DataToNumberNodeConfigH\0R\x12dataToNumberConfig\
    \x12@\n\x0bvalueConfig\x183\x20\x01(\x0b2\x1c.mizer.nodes.ValueNodeConfi\
    gH\0R\x0bvalueConfig\x12O\n\x10planScreenConfig\x184\x20\x01(\x0b2!.mize\
    r.nodes.PlanScreenNodeConfigH\0R\x10planScreenConfig\x12@\n\x0bdelayConf\
    ig\x185\x20\x01(\x0b2\x1c.mizer.nodes.DelayNodeConfigH\0R\x0bdelayConfig\
    \x12=\n\nrampConfig\x186\x20\x01(\x0b2\x1b.mizer.nodes.RampNodeConfigH\0\
    R\nrampConfig\x12@\n\x0bnoiseConfig\x187\x20\x01(\x0b2\x1c.mizer.nodes.N\
    oiseNodeConfigH\0R\x0bnoiseConfig\x12@\n\x0blabelConfig\x188\x20\x01(\
    \x0b2\x1c.mizer.nodes.LabelNodeConfigH\0R\x0blabelConfig\x12L\n\x0ftrans\
    portConfig\x189\x20\x01(\x0b2\x20.mizer.nodes.TransportNodeConfigH\0R\
    \x0ftransportConfigB\x06\n\x04type\"\x87\x02\n\x14OscillatorNodeConfig\
    \x12D\n\x04type\x18\x01\x20\x01(\x0e20.mizer.nodes.OscillatorNodeConfig.\
    OscillatorTypeR\x04type\x12\x14\n\x05ratio\x18\x02\x20\x01(\x01R\x05rati\
    o\x12\x10\n\x03max\x18\x03\x20\x01(\x01R\x03max\x12\x10\n\x03min\x18\x04\
    \x20\x01(\x01R\x03min\x12\x16\n\x06offset\x18\x05\x20\x01(\x01R\x06offse\
    t\x12\x18\n\x07reverse\x18\x06\x20\x01(\x08R\x07reverse\"=\n\x0eOscillat\
    orType\x12\n\n\x06Square\x10\0\x12\x08\n\x04Sine\x10\x01\x12\x07\n\x03Sa\
    w\x10\x02\x12\x0c\n\x08Triangle\x10\x03\"-\n\x13ScriptingNodeConfig\x12\
    \x16\n\x06script\x18\x01\x20\x01(\tR\x06script\"\xa6\x01\n\x12SequenceNo\
    deConfig\x12B\n\x05steps\x18\x01\x20\x03(\x0b2,.mizer.nodes.SequenceNode\
    Config.SequenceStepR\x05steps\x1aL\n\x0cSequenceStep\x12\x12\n\x04tick\
    \x18\x01\x20\x01(\x01R\x04tick\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\
    \x05value\x12\x12\n\x04hold\x18\x03\x20\x01(\x08R\x04hold\"\x16\n\x14Pro\
    grammerNodeConfig\"\x11\n\x0fGroupNodeConfig\"\x12\n\x10PresetNodeConfig\
    \"v\n\x12EnvelopeNodeConfig\x12\x16\n\x06attack\x18\x01\x20\x01(\x01R\
    \x06attack\x12\x14\n\x05decay\x18\x02\x20\x01(\x01R\x05decay\x12\x18\n\
    \x07sustain\x18\x03\x20\x01(\x01R\x07sustain\x12\x18\n\x07release\x18\
    \x04\x20\x01(\x01R\x07release\"'\n\x0fClockNodeConfig\x12\x14\n\x05speed\
    \x18\x01\x20\x01(\x01R\x05speed\"2\n\x11FixtureNodeConfig\x12\x1d\n\nfix\
    ture_id\x18\x01\x20\x01(\rR\tfixtureId\"6\n\x13SequencerNodeConfig\x12\
    \x1f\n\x0bsequence_id\x18\x01\x20\x01(\rR\nsequenceId\"*\n\x10ButtonNode\
    Config\x12\x16\n\x06toggle\x18\x01\x20\x01(\x08R\x06toggle\"\x11\n\x0fFa\
    derNodeConfig\"(\n\x12IldaFileNodeConfig\x12\x12\n\x04file\x18\x01\x20\
    \x01(\tR\x04file\".\n\x0fLaserNodeConfig\x12\x1b\n\tdevice_id\x18\x01\
    \x20\x01(\tR\x08deviceId\"\x9f\x03\n\x11GamepadNodeConfig\x12\x1b\n\tdev\
    ice_id\x18\x01\x20\x01(\tR\x08deviceId\x12@\n\x07control\x18\x02\x20\x01\
    (\x0e2&.mizer.nodes.GamepadNodeConfig.ControlR\x07control\"\xaa\x02\n\
    \x07Control\x12\x0e\n\nLeftStickX\x10\0\x12\x0e\n\nLeftStickY\x10\x01\
    \x12\x0f\n\x0bRightStickX\x10\x02\x12\x0f\n\x0bRightStickY\x10\x03\x12\
    \x0f\n\x0bLeftTrigger\x10\x04\x12\x10\n\x0cRightTrigger\x10\x05\x12\x10\
    \n\x0cLeftShoulder\x10\x06\x12\x11\n\rRightShoulder\x10\x07\x12\t\n\x05S\
    outh\x10\x08\x12\x08\n\x04East\x10\t\x12\t\n\x05North\x10\n\x12\x08\n\
    \x04West\x10\x0b\x12\n\n\x06Select\x10\x0c\x12\t\n\x05Start\x10\r\x12\n\
    \n\x06DpadUp\x10\x0e\x12\x0c\n\x08DpadDown\x10\x0f\x12\x0c\n\x08DpadLeft\
    \x10\x10\x12\r\n\tDpadRight\x10\x11\x12\r\n\tLeftStick\x10\x12\x12\x0e\n\
    \nRightStick\x10\x13\"\x88\x01\n\x16PixelPatternNodeConfig\x12E\n\x07pat\
    tern\x18\x01\x20\x01(\x0e2+.mizer.nodes.PixelPatternNodeConfig.PatternR\
    \x07pattern\"'\n\x07Pattern\x12\x0e\n\nRgbIterate\x10\0\x12\x0c\n\x08Rgb\
    Snake\x10\x01\"\x81\x01\n\x12PixelDmxNodeConfig\x12\x14\n\x05width\x18\
    \x01\x20\x01(\x04R\x05width\x12\x16\n\x06height\x18\x02\x20\x01(\x04R\
    \x06height\x12%\n\x0estart_universe\x18\x03\x20\x01(\rR\rstartUniverse\
    \x12\x16\n\x06output\x18\x04\x20\x01(\tR\x06output\"s\n\x13DmxOutputNode\
    Config\x12\x1b\n\x06output\x18\x01\x20\x01(\tH\0R\x06output\x88\x01\x01\
    \x12\x1a\n\x08universe\x18\x02\x20\x01(\rR\x08universe\x12\x18\n\x07chan\
    nel\x18\x03\x20\x01(\rR\x07channelB\t\n\x07_output\"\xf0\x03\n\x0eMidiNo\
    deConfig\x12\x16\n\x06device\x18\x01\x20\x01(\tR\x06device\x12K\n\x0bnot\
    eBinding\x18\x02\x20\x01(\x0b2'.mizer.nodes.MidiNodeConfig.NoteBindingH\
    \0R\x0bnoteBinding\x12T\n\x0econtrolBinding\x18\x03\x20\x01(\x0b2*.mizer\
    .nodes.MidiNodeConfig.ControlBindingH\0R\x0econtrolBinding\x1a\xd7\x01\n\
    \x0bNoteBinding\x12\x18\n\x07channel\x18\x01\x20\x01(\rR\x07channel\x12D\
    \n\x04type\x18\x02\x20\x01(\x0e20.mizer.nodes.MidiNodeConfig.NoteBinding\
    .MidiTypeR\x04type\x12\x12\n\x04port\x18\x03\x20\x01(\rR\x04port\x12\x1c\
    \n\trangeFrom\x18\x04\x20\x01(\rR\trangeFrom\x12\x18\n\x07rangeTo\x18\
    \x05\x20\x01(\rR\x07rangeTo\"\x1c\n\x08MidiType\x12\x06\n\x02CC\x10\0\
    \x12\x08\n\x04Note\x10\x01\x1a>\n\x0eControlBinding\x12\x12\n\x04page\
    \x18\x01\x20\x01(\tR\x04page\x12\x18\n\x07control\x18\x02\x20\x01(\tR\
    \x07controlB\t\n\x07binding\"k\n\x13OpcOutputNodeConfig\x12\x12\n\x04hos\
    t\x18\x01\x20\x01(\tR\x04host\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04p\
    ort\x12\x14\n\x05width\x18\x03\x20\x01(\x04R\x05width\x12\x16\n\x06heigh\
    t\x18\x04\x20\x01(\x04R\x06height\"\xe7\x01\n\rOscNodeConfig\x12\x12\n\
    \x04host\x18\x01\x20\x01(\tR\x04host\x12\x12\n\x04port\x18\x02\x20\x01(\
    \rR\x04port\x12\x12\n\x04path\x18\x03\x20\x01(\tR\x04path\x12K\n\x0cargu\
    mentType\x18\x04\x20\x01(\x0e2'.mizer.nodes.OscNodeConfig.ArgumentTypeR\
    \x0cargumentType\"M\n\x0cArgumentType\x12\x07\n\x03Int\x10\0\x12\t\n\x05\
    Float\x10\x01\x12\x08\n\x04Long\x10\x02\x12\n\n\x06Double\x10\x03\x12\
    \x08\n\x04Bool\x10\x04\x12\t\n\x05Color\x10\x05\"\x1d\n\x1bVideoColorBal\
    anceNodeConfig\"\x17\n\x15VideoEffectNodeConfig\")\n\x13VideoFileNodeCon\
    fig\x12\x12\n\x04file\x18\x01\x20\x01(\tR\x04file\"\x17\n\x15VideoOutput\
    NodeConfig\"\x1a\n\x18VideoTransformNodeConfig\"\x12\n\x10SelectNodeConf\
    ig\"\x7f\n\x0fMergeNodeConfig\x12:\n\x04mode\x18\x01\x20\x01(\x0e2&.mize\
    r.nodes.MergeNodeConfig.MergeModeR\x04mode\"0\n\tMergeMode\x12\n\n\x06La\
    test\x10\0\x12\x0b\n\x07Highest\x10\x01\x12\n\n\x06Lowest\x10\x02\"\xb1\
    \x01\n\x13ThresholdNodeConfig\x12'\n\x0flower_threshold\x18\x01\x20\x01(\
    \x01R\x0elowerThreshold\x12'\n\x0fupper_threshold\x18\x02\x20\x01(\x01R\
    \x0eupperThreshold\x12!\n\x0cactive_value\x18\x03\x20\x01(\x01R\x0bactiv\
    eValue\x12%\n\x0einactive_value\x18\x04\x20\x01(\x01R\rinactiveValue\"0\
    \n\x11EncoderNodeConfig\x12\x1b\n\thold_rate\x18\x01\x20\x01(\x01R\x08ho\
    ldRate\"\x14\n\x12ColorRgbNodeConfig\"\x14\n\x12ColorHsvNodeConfig\">\n\
    \x13ContainerNodeConfig\x12'\n\x05nodes\x18\x01\x20\x03(\x0b2\x11.mizer.\
    nodes.NodeR\x05nodes\"\xbe\x01\n\x0eMathNodeConfig\x124\n\x04mode\x18\
    \x01\x20\x01(\x0e2\x20.mizer.nodes.MathNodeConfig.ModeR\x04mode\"v\n\x04\
    Mode\x12\x0c\n\x08Addition\x10\0\x12\x0f\n\x0bSubtraction\x10\x01\x12\
    \x12\n\x0eMultiplication\x10\x02\x12\x0c\n\x08Division\x10\x03\x12\n\n\
    \x06Invert\x10\x04\x12\x08\n\x04Sine\x10\x05\x12\n\n\x06Cosine\x10\x06\
    \x12\x0b\n\x07Tangent\x10\x07\"I\n\x13MqttInputNodeConfig\x12\x1e\n\ncon\
    nection\x18\x01\x20\x01(\tR\nconnection\x12\x12\n\x04path\x18\x02\x20\
    \x01(\tR\x04path\"J\n\x14MqttOutputNodeConfig\x12\x1e\n\nconnection\x18\
    \x01\x20\x01(\tR\nconnection\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04pa\
    th\"\x18\n\x16NumberToDataNodeConfig\"\x18\n\x16DataToNumberNodeConfig\"\
    '\n\x0fValueNodeConfig\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\"\
    L\n\x14PlanScreenNodeConfig\x12\x17\n\x07plan_id\x18\x01\x20\x01(\tR\x06\
    planId\x12\x1b\n\tscreen_id\x18\x02\x20\x01(\rR\x08screenId\"2\n\x0fDela\
    yNodeConfig\x12\x1f\n\x0bbuffer_size\x18\x01\x20\x01(\rR\nbufferSize\"\
    \xbc\x01\n\x0eRampNodeConfig\x12:\n\x05steps\x18\x01\x20\x03(\x0b2$.mize\
    r.nodes.RampNodeConfig.RampStepR\x05steps\x1an\n\x08RampStep\x12\x0c\n\
    \x01x\x18\x01\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x01R\
    \x01y\x12\x10\n\x03c0a\x18\x03\x20\x01(\x01R\x03c0a\x12\x10\n\x03c0b\x18\
    \x04\x20\x01(\x01R\x03c0b\x12\x10\n\x03c1a\x18\x05\x20\x01(\x01R\x03c1a\
    \x12\x10\n\x03c1b\x18\x06\x20\x01(\x01R\x03c1b\"B\n\x0fNoiseNodeConfig\
    \x12\x1b\n\ttick_rate\x18\x01\x20\x01(\x04R\x08tickRate\x12\x12\n\x04fad\
    e\x18\x02\x20\x01(\x08R\x04fade\"%\n\x0fLabelNodeConfig\x12\x12\n\x04tex\
    t\x18\x01\x20\x01(\tR\x04text\"\x15\n\x13TransportNodeConfig\"*\n\x0cNod\
    ePosition\x12\x0c\n\x01x\x18\x01\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\
    \x02\x20\x01(\x01R\x01y\"s\n\x0cNodeDesigner\x125\n\x08position\x18\x01\
    \x20\x01(\x0b2\x19.mizer.nodes.NodePositionR\x08position\x12\x14\n\x05sc\
    ale\x18\x02\x20\x01(\x01R\x05scale\x12\x16\n\x06hidden\x18\x03\x20\x01(\
    \x08R\x06hidden\"T\n\x04Port\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\x128\n\x08protocol\x18\x02\x20\x01(\x0e2\x1c.mizer.nodes.ChannelProto\
    colR\x08protocol*\x82\x01\n\x0fChannelProtocol\x12\n\n\x06SINGLE\x10\0\
    \x12\t\n\x05MULTI\x10\x01\x12\t\n\x05COLOR\x10\t\x12\x0b\n\x07TEXTURE\
    \x10\x02\x12\n\n\x06VECTOR\x10\x03\x12\t\n\x05LASER\x10\x04\x12\x08\n\
    \x04POLY\x10\x05\x12\x08\n\x04DATA\x10\x06\x12\x0c\n\x08MATERIAL\x10\x07\
    \x12\x07\n\x03GST\x10\x082\xe5\x05\n\x08NodesApi\x129\n\x08GetNodes\x12\
    \x19.mizer.nodes.NodesRequest\x1a\x12.mizer.nodes.Nodes\x129\n\x07AddNod\
    e\x12\x1b.mizer.nodes.AddNodeRequest\x1a\x11.mizer.nodes.Node\x12C\n\x07\
    AddLink\x12\x1b.mizer.nodes.NodeConnection\x1a\x1b.mizer.nodes.NodeConne\
    ction\x12J\n\x11WriteControlValue\x12\x19.mizer.nodes.WriteControl\x1a\
    \x1a.mizer.nodes.WriteResponse\x12a\n\x12UpdateNodeProperty\x12$.mizer.n\
    odes.UpdateNodeConfigRequest\x1a%.mizer.nodes.UpdateNodeConfigResponse\
    \x12G\n\x08MoveNode\x12\x1c.mizer.nodes.MoveNodeRequest\x1a\x1d.mizer.no\
    des.MoveNodeResponse\x12M\n\nDeleteNode\x12\x1e.mizer.nodes.DeleteNodeRe\
    quest\x1a\x1f.mizer.nodes.DeleteNodeResponse\x12G\n\x08HideNode\x12\x1c.\
    mizer.nodes.HideNodeRequest\x1a\x1d.mizer.nodes.HideNodeResponse\x12G\n\
    \x08ShowNode\x12\x1c.mizer.nodes.ShowNodeRequest\x1a\x1d.mizer.nodes.Sho\
    wNodeResponse\x12E\n\rDuplicateNode\x12!.mizer.nodes.DuplicateNodeReques\
    t\x1a\x11.mizer.nodes.Nodeb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(71);
            messages.push(AddNodeRequest::generated_message_descriptor_data());
            messages.push(DuplicateNodeRequest::generated_message_descriptor_data());
            messages.push(NodesRequest::generated_message_descriptor_data());
            messages.push(WriteControl::generated_message_descriptor_data());
            messages.push(WriteResponse::generated_message_descriptor_data());
            messages.push(UpdateNodeConfigRequest::generated_message_descriptor_data());
            messages.push(UpdateNodeConfigResponse::generated_message_descriptor_data());
            messages.push(MoveNodeRequest::generated_message_descriptor_data());
            messages.push(MoveNodeResponse::generated_message_descriptor_data());
            messages.push(ShowNodeRequest::generated_message_descriptor_data());
            messages.push(ShowNodeResponse::generated_message_descriptor_data());
            messages.push(DeleteNodeRequest::generated_message_descriptor_data());
            messages.push(DeleteNodeResponse::generated_message_descriptor_data());
            messages.push(HideNodeRequest::generated_message_descriptor_data());
            messages.push(HideNodeResponse::generated_message_descriptor_data());
            messages.push(Nodes::generated_message_descriptor_data());
            messages.push(NodeConnection::generated_message_descriptor_data());
            messages.push(Node::generated_message_descriptor_data());
            messages.push(NodeConfig::generated_message_descriptor_data());
            messages.push(OscillatorNodeConfig::generated_message_descriptor_data());
            messages.push(ScriptingNodeConfig::generated_message_descriptor_data());
            messages.push(SequenceNodeConfig::generated_message_descriptor_data());
            messages.push(ProgrammerNodeConfig::generated_message_descriptor_data());
            messages.push(GroupNodeConfig::generated_message_descriptor_data());
            messages.push(PresetNodeConfig::generated_message_descriptor_data());
            messages.push(EnvelopeNodeConfig::generated_message_descriptor_data());
            messages.push(ClockNodeConfig::generated_message_descriptor_data());
            messages.push(FixtureNodeConfig::generated_message_descriptor_data());
            messages.push(SequencerNodeConfig::generated_message_descriptor_data());
            messages.push(ButtonNodeConfig::generated_message_descriptor_data());
            messages.push(FaderNodeConfig::generated_message_descriptor_data());
            messages.push(IldaFileNodeConfig::generated_message_descriptor_data());
            messages.push(LaserNodeConfig::generated_message_descriptor_data());
            messages.push(GamepadNodeConfig::generated_message_descriptor_data());
            messages.push(PixelPatternNodeConfig::generated_message_descriptor_data());
            messages.push(PixelDmxNodeConfig::generated_message_descriptor_data());
            messages.push(DmxOutputNodeConfig::generated_message_descriptor_data());
            messages.push(MidiNodeConfig::generated_message_descriptor_data());
            messages.push(OpcOutputNodeConfig::generated_message_descriptor_data());
            messages.push(OscNodeConfig::generated_message_descriptor_data());
            messages.push(VideoColorBalanceNodeConfig::generated_message_descriptor_data());
            messages.push(VideoEffectNodeConfig::generated_message_descriptor_data());
            messages.push(VideoFileNodeConfig::generated_message_descriptor_data());
            messages.push(VideoOutputNodeConfig::generated_message_descriptor_data());
            messages.push(VideoTransformNodeConfig::generated_message_descriptor_data());
            messages.push(SelectNodeConfig::generated_message_descriptor_data());
            messages.push(MergeNodeConfig::generated_message_descriptor_data());
            messages.push(ThresholdNodeConfig::generated_message_descriptor_data());
            messages.push(EncoderNodeConfig::generated_message_descriptor_data());
            messages.push(ColorRgbNodeConfig::generated_message_descriptor_data());
            messages.push(ColorHsvNodeConfig::generated_message_descriptor_data());
            messages.push(ContainerNodeConfig::generated_message_descriptor_data());
            messages.push(MathNodeConfig::generated_message_descriptor_data());
            messages.push(MqttInputNodeConfig::generated_message_descriptor_data());
            messages.push(MqttOutputNodeConfig::generated_message_descriptor_data());
            messages.push(NumberToDataNodeConfig::generated_message_descriptor_data());
            messages.push(DataToNumberNodeConfig::generated_message_descriptor_data());
            messages.push(ValueNodeConfig::generated_message_descriptor_data());
            messages.push(PlanScreenNodeConfig::generated_message_descriptor_data());
            messages.push(DelayNodeConfig::generated_message_descriptor_data());
            messages.push(RampNodeConfig::generated_message_descriptor_data());
            messages.push(NoiseNodeConfig::generated_message_descriptor_data());
            messages.push(LabelNodeConfig::generated_message_descriptor_data());
            messages.push(TransportNodeConfig::generated_message_descriptor_data());
            messages.push(NodePosition::generated_message_descriptor_data());
            messages.push(NodeDesigner::generated_message_descriptor_data());
            messages.push(Port::generated_message_descriptor_data());
            messages.push(sequence_node_config::SequenceStep::generated_message_descriptor_data());
            messages.push(midi_node_config::NoteBinding::generated_message_descriptor_data());
            messages.push(midi_node_config::ControlBinding::generated_message_descriptor_data());
            messages.push(ramp_node_config::RampStep::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(10);
            enums.push(ChannelProtocol::generated_enum_descriptor_data());
            enums.push(node::NodeType::generated_enum_descriptor_data());
            enums.push(node::NodePreviewType::generated_enum_descriptor_data());
            enums.push(oscillator_node_config::OscillatorType::generated_enum_descriptor_data());
            enums.push(gamepad_node_config::Control::generated_enum_descriptor_data());
            enums.push(pixel_pattern_node_config::Pattern::generated_enum_descriptor_data());
            enums.push(midi_node_config::note_binding::MidiType::generated_enum_descriptor_data());
            enums.push(osc_node_config::ArgumentType::generated_enum_descriptor_data());
            enums.push(merge_node_config::MergeMode::generated_enum_descriptor_data());
            enums.push(math_node_config::Mode::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
