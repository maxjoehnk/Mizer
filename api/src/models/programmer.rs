// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `programmer.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.SubscribeProgrammerRequest)
pub struct SubscribeProgrammerRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.SubscribeProgrammerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeProgrammerRequest {
    fn default() -> &'a SubscribeProgrammerRequest {
        <SubscribeProgrammerRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeProgrammerRequest {
    pub fn new() -> SubscribeProgrammerRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeProgrammerRequest>(
            "SubscribeProgrammerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeProgrammerRequest {
    const NAME: &'static str = "SubscribeProgrammerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeProgrammerRequest {
        SubscribeProgrammerRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeProgrammerRequest {
        static instance: SubscribeProgrammerRequest = SubscribeProgrammerRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeProgrammerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeProgrammerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeProgrammerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeProgrammerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.ProgrammerState)
pub struct ProgrammerState {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.fixtures)
    pub fixtures: ::std::vec::Vec<super::fixtures::FixtureId>,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.active_fixtures)
    pub active_fixtures: ::std::vec::Vec<super::fixtures::FixtureId>,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.active_groups)
    pub active_groups: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.selection)
    pub selection: ::protobuf::MessageField<FixtureSelection>,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.controls)
    pub controls: ::std::vec::Vec<ProgrammerChannel>,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.highlight)
    pub highlight: bool,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.block_size)
    pub block_size: u32,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.groups)
    pub groups: u32,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.wings)
    pub wings: u32,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerState.effects)
    pub effects: ::std::vec::Vec<EffectProgrammerState>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.ProgrammerState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProgrammerState {
    fn default() -> &'a ProgrammerState {
        <ProgrammerState as ::protobuf::Message>::default_instance()
    }
}

impl ProgrammerState {
    pub fn new() -> ProgrammerState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixtures",
            |m: &ProgrammerState| { &m.fixtures },
            |m: &mut ProgrammerState| { &mut m.fixtures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "active_fixtures",
            |m: &ProgrammerState| { &m.active_fixtures },
            |m: &mut ProgrammerState| { &mut m.active_fixtures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "active_groups",
            |m: &ProgrammerState| { &m.active_groups },
            |m: &mut ProgrammerState| { &mut m.active_groups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FixtureSelection>(
            "selection",
            |m: &ProgrammerState| { &m.selection },
            |m: &mut ProgrammerState| { &mut m.selection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "controls",
            |m: &ProgrammerState| { &m.controls },
            |m: &mut ProgrammerState| { &mut m.controls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "highlight",
            |m: &ProgrammerState| { &m.highlight },
            |m: &mut ProgrammerState| { &mut m.highlight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_size",
            |m: &ProgrammerState| { &m.block_size },
            |m: &mut ProgrammerState| { &mut m.block_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "groups",
            |m: &ProgrammerState| { &m.groups },
            |m: &mut ProgrammerState| { &mut m.groups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wings",
            |m: &ProgrammerState| { &m.wings },
            |m: &mut ProgrammerState| { &mut m.wings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "effects",
            |m: &ProgrammerState| { &m.effects },
            |m: &mut ProgrammerState| { &mut m.effects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProgrammerState>(
            "ProgrammerState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProgrammerState {
    const NAME: &'static str = "ProgrammerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fixtures.push(is.read_message()?);
                },
                18 => {
                    self.active_fixtures.push(is.read_message()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.active_groups)?;
                },
                24 => {
                    self.active_groups.push(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selection)?;
                },
                42 => {
                    self.controls.push(is.read_message()?);
                },
                48 => {
                    self.highlight = is.read_bool()?;
                },
                56 => {
                    self.block_size = is.read_uint32()?;
                },
                64 => {
                    self.groups = is.read_uint32()?;
                },
                72 => {
                    self.wings = is.read_uint32()?;
                },
                82 => {
                    self.effects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.active_fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.active_groups {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.selection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.controls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.highlight != false {
            my_size += 1 + 1;
        }
        if self.block_size != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.block_size);
        }
        if self.groups != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.groups);
        }
        if self.wings != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.wings);
        }
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.active_fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.active_groups {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.selection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.controls {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.highlight != false {
            os.write_bool(6, self.highlight)?;
        }
        if self.block_size != 0 {
            os.write_uint32(7, self.block_size)?;
        }
        if self.groups != 0 {
            os.write_uint32(8, self.groups)?;
        }
        if self.wings != 0 {
            os.write_uint32(9, self.wings)?;
        }
        for v in &self.effects {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProgrammerState {
        ProgrammerState::new()
    }

    fn clear(&mut self) {
        self.fixtures.clear();
        self.active_fixtures.clear();
        self.active_groups.clear();
        self.selection.clear();
        self.controls.clear();
        self.highlight = false;
        self.block_size = 0;
        self.groups = 0;
        self.wings = 0;
        self.effects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProgrammerState {
        static instance: ProgrammerState = ProgrammerState {
            fixtures: ::std::vec::Vec::new(),
            active_fixtures: ::std::vec::Vec::new(),
            active_groups: ::std::vec::Vec::new(),
            selection: ::protobuf::MessageField::none(),
            controls: ::std::vec::Vec::new(),
            highlight: false,
            block_size: 0,
            groups: 0,
            wings: 0,
            effects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProgrammerState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProgrammerState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProgrammerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgrammerState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.FixtureSelection)
pub struct FixtureSelection {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.FixtureSelection.fixtures)
    pub fixtures: ::std::vec::Vec<fixture_selection::GroupedFixtureList>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.FixtureSelection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FixtureSelection {
    fn default() -> &'a FixtureSelection {
        <FixtureSelection as ::protobuf::Message>::default_instance()
    }
}

impl FixtureSelection {
    pub fn new() -> FixtureSelection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixtures",
            |m: &FixtureSelection| { &m.fixtures },
            |m: &mut FixtureSelection| { &mut m.fixtures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FixtureSelection>(
            "FixtureSelection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FixtureSelection {
    const NAME: &'static str = "FixtureSelection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fixtures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FixtureSelection {
        FixtureSelection::new()
    }

    fn clear(&mut self) {
        self.fixtures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FixtureSelection {
        static instance: FixtureSelection = FixtureSelection {
            fixtures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FixtureSelection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FixtureSelection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FixtureSelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FixtureSelection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FixtureSelection`
pub mod fixture_selection {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.programmer.FixtureSelection.GroupedFixtureList)
    pub struct GroupedFixtureList {
        // message fields
        // @@protoc_insertion_point(field:mizer.programmer.FixtureSelection.GroupedFixtureList.fixtures)
        pub fixtures: ::std::vec::Vec<super::super::fixtures::FixtureId>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.programmer.FixtureSelection.GroupedFixtureList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GroupedFixtureList {
        fn default() -> &'a GroupedFixtureList {
            <GroupedFixtureList as ::protobuf::Message>::default_instance()
        }
    }

    impl GroupedFixtureList {
        pub fn new() -> GroupedFixtureList {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "fixtures",
                |m: &GroupedFixtureList| { &m.fixtures },
                |m: &mut GroupedFixtureList| { &mut m.fixtures },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupedFixtureList>(
                "FixtureSelection.GroupedFixtureList",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GroupedFixtureList {
        const NAME: &'static str = "GroupedFixtureList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.fixtures.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.fixtures {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.fixtures {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GroupedFixtureList {
            GroupedFixtureList::new()
        }

        fn clear(&mut self) {
            self.fixtures.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GroupedFixtureList {
            static instance: GroupedFixtureList = GroupedFixtureList {
                fixtures: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GroupedFixtureList {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FixtureSelection.GroupedFixtureList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GroupedFixtureList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GroupedFixtureList {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.ProgrammerChannel)
pub struct ProgrammerChannel {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerChannel.fixtures)
    pub fixtures: ::std::vec::Vec<super::fixtures::FixtureId>,
    // @@protoc_insertion_point(field:mizer.programmer.ProgrammerChannel.control)
    pub control: ::protobuf::EnumOrUnknown<super::fixtures::FixtureControl>,
    // message oneof groups
    pub value: ::std::option::Option<programmer_channel::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.ProgrammerChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProgrammerChannel {
    fn default() -> &'a ProgrammerChannel {
        <ProgrammerChannel as ::protobuf::Message>::default_instance()
    }
}

impl ProgrammerChannel {
    pub fn new() -> ProgrammerChannel {
        ::std::default::Default::default()
    }

    // double fader = 3;

    pub fn fader(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(programmer_channel::Value::Fader(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_fader(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_fader(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(programmer_channel::Value::Fader(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fader(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(programmer_channel::Value::Fader(v))
    }

    // .mizer.fixtures.ColorMixerChannel color = 4;

    pub fn color(&self) -> &super::fixtures::ColorMixerChannel {
        match self.value {
            ::std::option::Option::Some(programmer_channel::Value::Color(ref v)) => v,
            _ => <super::fixtures::ColorMixerChannel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_color(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(programmer_channel::Value::Color(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: super::fixtures::ColorMixerChannel) {
        self.value = ::std::option::Option::Some(programmer_channel::Value::Color(v))
    }

    // Mutable pointer to the field.
    pub fn mut_color(&mut self) -> &mut super::fixtures::ColorMixerChannel {
        if let ::std::option::Option::Some(programmer_channel::Value::Color(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(programmer_channel::Value::Color(super::fixtures::ColorMixerChannel::new()));
        }
        match self.value {
            ::std::option::Option::Some(programmer_channel::Value::Color(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_color(&mut self) -> super::fixtures::ColorMixerChannel {
        if self.has_color() {
            match self.value.take() {
                ::std::option::Option::Some(programmer_channel::Value::Color(v)) => v,
                _ => panic!(),
            }
        } else {
            super::fixtures::ColorMixerChannel::new()
        }
    }

    // .mizer.programmer.ProgrammerChannel.GenericValue generic = 5;

    pub fn generic(&self) -> &programmer_channel::GenericValue {
        match self.value {
            ::std::option::Option::Some(programmer_channel::Value::Generic(ref v)) => v,
            _ => <programmer_channel::GenericValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_generic(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_generic(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(programmer_channel::Value::Generic(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_generic(&mut self, v: programmer_channel::GenericValue) {
        self.value = ::std::option::Option::Some(programmer_channel::Value::Generic(v))
    }

    // Mutable pointer to the field.
    pub fn mut_generic(&mut self) -> &mut programmer_channel::GenericValue {
        if let ::std::option::Option::Some(programmer_channel::Value::Generic(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(programmer_channel::Value::Generic(programmer_channel::GenericValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(programmer_channel::Value::Generic(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_generic(&mut self) -> programmer_channel::GenericValue {
        if self.has_generic() {
            match self.value.take() {
                ::std::option::Option::Some(programmer_channel::Value::Generic(v)) => v,
                _ => panic!(),
            }
        } else {
            programmer_channel::GenericValue::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixtures",
            |m: &ProgrammerChannel| { &m.fixtures },
            |m: &mut ProgrammerChannel| { &mut m.fixtures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "control",
            |m: &ProgrammerChannel| { &m.control },
            |m: &mut ProgrammerChannel| { &mut m.control },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "fader",
            ProgrammerChannel::has_fader,
            ProgrammerChannel::fader,
            ProgrammerChannel::set_fader,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::fixtures::ColorMixerChannel>(
            "color",
            ProgrammerChannel::has_color,
            ProgrammerChannel::color,
            ProgrammerChannel::mut_color,
            ProgrammerChannel::set_color,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, programmer_channel::GenericValue>(
            "generic",
            ProgrammerChannel::has_generic,
            ProgrammerChannel::generic,
            ProgrammerChannel::mut_generic,
            ProgrammerChannel::set_generic,
        ));
        oneofs.push(programmer_channel::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProgrammerChannel>(
            "ProgrammerChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProgrammerChannel {
    const NAME: &'static str = "ProgrammerChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fixtures.push(is.read_message()?);
                },
                16 => {
                    self.control = is.read_enum_or_unknown()?;
                },
                25 => {
                    self.value = ::std::option::Option::Some(programmer_channel::Value::Fader(is.read_double()?));
                },
                34 => {
                    self.value = ::std::option::Option::Some(programmer_channel::Value::Color(is.read_message()?));
                },
                42 => {
                    self.value = ::std::option::Option::Some(programmer_channel::Value::Generic(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.control != ::protobuf::EnumOrUnknown::new(super::fixtures::FixtureControl::INTENSITY) {
            my_size += ::protobuf::rt::int32_size(2, self.control.value());
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &programmer_channel::Value::Fader(v) => {
                    my_size += 1 + 8;
                },
                &programmer_channel::Value::Color(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &programmer_channel::Value::Generic(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.control != ::protobuf::EnumOrUnknown::new(super::fixtures::FixtureControl::INTENSITY) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.control))?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &programmer_channel::Value::Fader(v) => {
                    os.write_double(3, v)?;
                },
                &programmer_channel::Value::Color(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &programmer_channel::Value::Generic(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProgrammerChannel {
        ProgrammerChannel::new()
    }

    fn clear(&mut self) {
        self.fixtures.clear();
        self.control = ::protobuf::EnumOrUnknown::new(super::fixtures::FixtureControl::INTENSITY);
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProgrammerChannel {
        static instance: ProgrammerChannel = ProgrammerChannel {
            fixtures: ::std::vec::Vec::new(),
            control: ::protobuf::EnumOrUnknown::from_i32(0),
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProgrammerChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProgrammerChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProgrammerChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgrammerChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProgrammerChannel`
pub mod programmer_channel {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.programmer.ProgrammerChannel.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:mizer.programmer.ProgrammerChannel.fader)
        Fader(f64),
        // @@protoc_insertion_point(oneof_field:mizer.programmer.ProgrammerChannel.color)
        Color(super::super::fixtures::ColorMixerChannel),
        // @@protoc_insertion_point(oneof_field:mizer.programmer.ProgrammerChannel.generic)
        Generic(GenericValue),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ProgrammerChannel as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.programmer.ProgrammerChannel.GenericValue)
    pub struct GenericValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.programmer.ProgrammerChannel.GenericValue.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.programmer.ProgrammerChannel.GenericValue.value)
        pub value: f64,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.programmer.ProgrammerChannel.GenericValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GenericValue {
        fn default() -> &'a GenericValue {
            <GenericValue as ::protobuf::Message>::default_instance()
        }
    }

    impl GenericValue {
        pub fn new() -> GenericValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &GenericValue| { &m.name },
                |m: &mut GenericValue| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &GenericValue| { &m.value },
                |m: &mut GenericValue| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericValue>(
                "ProgrammerChannel.GenericValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GenericValue {
        const NAME: &'static str = "GenericValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    17 => {
                        self.value = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if self.value != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if self.value != 0. {
                os.write_double(2, self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GenericValue {
            GenericValue::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.value = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GenericValue {
            static instance: GenericValue = GenericValue {
                name: ::std::string::String::new(),
                value: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GenericValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ProgrammerChannel.GenericValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GenericValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GenericValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.programmer.ProgrammerChannel.ColorChannel)
    pub enum ColorChannel {
        // @@protoc_insertion_point(enum_value:mizer.programmer.ProgrammerChannel.ColorChannel.RED)
        RED = 0,
        // @@protoc_insertion_point(enum_value:mizer.programmer.ProgrammerChannel.ColorChannel.GREEN)
        GREEN = 1,
        // @@protoc_insertion_point(enum_value:mizer.programmer.ProgrammerChannel.ColorChannel.BLUE)
        BLUE = 2,
    }

    impl ::protobuf::Enum for ColorChannel {
        const NAME: &'static str = "ColorChannel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ColorChannel> {
            match value {
                0 => ::std::option::Option::Some(ColorChannel::RED),
                1 => ::std::option::Option::Some(ColorChannel::GREEN),
                2 => ::std::option::Option::Some(ColorChannel::BLUE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ColorChannel] = &[
            ColorChannel::RED,
            ColorChannel::GREEN,
            ColorChannel::BLUE,
        ];
    }

    impl ::protobuf::EnumFull for ColorChannel {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ProgrammerChannel.ColorChannel").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ColorChannel {
        fn default() -> Self {
            ColorChannel::RED
        }
    }

    impl ColorChannel {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ColorChannel>("ProgrammerChannel.ColorChannel")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.EffectProgrammerState)
pub struct EffectProgrammerState {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.EffectProgrammerState.effect_id)
    pub effect_id: u32,
    // @@protoc_insertion_point(field:mizer.programmer.EffectProgrammerState.effect_rate)
    pub effect_rate: f64,
    // @@protoc_insertion_point(field:mizer.programmer.EffectProgrammerState.effect_offset)
    pub effect_offset: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.EffectProgrammerState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EffectProgrammerState {
    fn default() -> &'a EffectProgrammerState {
        <EffectProgrammerState as ::protobuf::Message>::default_instance()
    }
}

impl EffectProgrammerState {
    pub fn new() -> EffectProgrammerState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_id",
            |m: &EffectProgrammerState| { &m.effect_id },
            |m: &mut EffectProgrammerState| { &mut m.effect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_rate",
            |m: &EffectProgrammerState| { &m.effect_rate },
            |m: &mut EffectProgrammerState| { &mut m.effect_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_offset",
            |m: &EffectProgrammerState| { &m.effect_offset },
            |m: &mut EffectProgrammerState| { &mut m.effect_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EffectProgrammerState>(
            "EffectProgrammerState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EffectProgrammerState {
    const NAME: &'static str = "EffectProgrammerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.effect_id = is.read_uint32()?;
                },
                17 => {
                    self.effect_rate = is.read_double()?;
                },
                25 => {
                    self.effect_offset = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.effect_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.effect_id);
        }
        if self.effect_rate != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.effect_offset {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.effect_id != 0 {
            os.write_uint32(1, self.effect_id)?;
        }
        if self.effect_rate != 0. {
            os.write_double(2, self.effect_rate)?;
        }
        if let Some(v) = self.effect_offset {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EffectProgrammerState {
        EffectProgrammerState::new()
    }

    fn clear(&mut self) {
        self.effect_id = 0;
        self.effect_rate = 0.;
        self.effect_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EffectProgrammerState {
        static instance: EffectProgrammerState = EffectProgrammerState {
            effect_id: 0,
            effect_rate: 0.,
            effect_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EffectProgrammerState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EffectProgrammerState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EffectProgrammerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EffectProgrammerState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.WriteEffectRateRequest)
pub struct WriteEffectRateRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.WriteEffectRateRequest.effect_id)
    pub effect_id: u32,
    // @@protoc_insertion_point(field:mizer.programmer.WriteEffectRateRequest.effect_rate)
    pub effect_rate: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.WriteEffectRateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteEffectRateRequest {
    fn default() -> &'a WriteEffectRateRequest {
        <WriteEffectRateRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteEffectRateRequest {
    pub fn new() -> WriteEffectRateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_id",
            |m: &WriteEffectRateRequest| { &m.effect_id },
            |m: &mut WriteEffectRateRequest| { &mut m.effect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_rate",
            |m: &WriteEffectRateRequest| { &m.effect_rate },
            |m: &mut WriteEffectRateRequest| { &mut m.effect_rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteEffectRateRequest>(
            "WriteEffectRateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteEffectRateRequest {
    const NAME: &'static str = "WriteEffectRateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.effect_id = is.read_uint32()?;
                },
                17 => {
                    self.effect_rate = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.effect_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.effect_id);
        }
        if self.effect_rate != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.effect_id != 0 {
            os.write_uint32(1, self.effect_id)?;
        }
        if self.effect_rate != 0. {
            os.write_double(2, self.effect_rate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteEffectRateRequest {
        WriteEffectRateRequest::new()
    }

    fn clear(&mut self) {
        self.effect_id = 0;
        self.effect_rate = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteEffectRateRequest {
        static instance: WriteEffectRateRequest = WriteEffectRateRequest {
            effect_id: 0,
            effect_rate: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteEffectRateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteEffectRateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteEffectRateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteEffectRateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.WriteEffectRateResponse)
pub struct WriteEffectRateResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.WriteEffectRateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteEffectRateResponse {
    fn default() -> &'a WriteEffectRateResponse {
        <WriteEffectRateResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteEffectRateResponse {
    pub fn new() -> WriteEffectRateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteEffectRateResponse>(
            "WriteEffectRateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteEffectRateResponse {
    const NAME: &'static str = "WriteEffectRateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteEffectRateResponse {
        WriteEffectRateResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteEffectRateResponse {
        static instance: WriteEffectRateResponse = WriteEffectRateResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteEffectRateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteEffectRateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteEffectRateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteEffectRateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.WriteEffectOffsetRequest)
pub struct WriteEffectOffsetRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.WriteEffectOffsetRequest.effect_id)
    pub effect_id: u32,
    // @@protoc_insertion_point(field:mizer.programmer.WriteEffectOffsetRequest.effect_offset)
    pub effect_offset: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.WriteEffectOffsetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteEffectOffsetRequest {
    fn default() -> &'a WriteEffectOffsetRequest {
        <WriteEffectOffsetRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteEffectOffsetRequest {
    pub fn new() -> WriteEffectOffsetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect_id",
            |m: &WriteEffectOffsetRequest| { &m.effect_id },
            |m: &mut WriteEffectOffsetRequest| { &mut m.effect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_offset",
            |m: &WriteEffectOffsetRequest| { &m.effect_offset },
            |m: &mut WriteEffectOffsetRequest| { &mut m.effect_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteEffectOffsetRequest>(
            "WriteEffectOffsetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteEffectOffsetRequest {
    const NAME: &'static str = "WriteEffectOffsetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.effect_id = is.read_uint32()?;
                },
                17 => {
                    self.effect_offset = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.effect_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.effect_id);
        }
        if let Some(v) = self.effect_offset {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.effect_id != 0 {
            os.write_uint32(1, self.effect_id)?;
        }
        if let Some(v) = self.effect_offset {
            os.write_double(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteEffectOffsetRequest {
        WriteEffectOffsetRequest::new()
    }

    fn clear(&mut self) {
        self.effect_id = 0;
        self.effect_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteEffectOffsetRequest {
        static instance: WriteEffectOffsetRequest = WriteEffectOffsetRequest {
            effect_id: 0,
            effect_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteEffectOffsetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteEffectOffsetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteEffectOffsetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteEffectOffsetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.WriteEffectOffsetResponse)
pub struct WriteEffectOffsetResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.WriteEffectOffsetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteEffectOffsetResponse {
    fn default() -> &'a WriteEffectOffsetResponse {
        <WriteEffectOffsetResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteEffectOffsetResponse {
    pub fn new() -> WriteEffectOffsetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteEffectOffsetResponse>(
            "WriteEffectOffsetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteEffectOffsetResponse {
    const NAME: &'static str = "WriteEffectOffsetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteEffectOffsetResponse {
        WriteEffectOffsetResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteEffectOffsetResponse {
        static instance: WriteEffectOffsetResponse = WriteEffectOffsetResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteEffectOffsetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteEffectOffsetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteEffectOffsetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteEffectOffsetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.WriteControlRequest)
pub struct WriteControlRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.WriteControlRequest.control)
    pub control: ::protobuf::EnumOrUnknown<super::fixtures::FixtureControl>,
    // message oneof groups
    pub value: ::std::option::Option<write_control_request::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.WriteControlRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteControlRequest {
    fn default() -> &'a WriteControlRequest {
        <WriteControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteControlRequest {
    pub fn new() -> WriteControlRequest {
        ::std::default::Default::default()
    }

    // double fader = 2;

    pub fn fader(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(write_control_request::Value::Fader(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_fader(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_fader(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(write_control_request::Value::Fader(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fader(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(write_control_request::Value::Fader(v))
    }

    // .mizer.fixtures.ColorMixerChannel color = 3;

    pub fn color(&self) -> &super::fixtures::ColorMixerChannel {
        match self.value {
            ::std::option::Option::Some(write_control_request::Value::Color(ref v)) => v,
            _ => <super::fixtures::ColorMixerChannel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_color(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(write_control_request::Value::Color(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: super::fixtures::ColorMixerChannel) {
        self.value = ::std::option::Option::Some(write_control_request::Value::Color(v))
    }

    // Mutable pointer to the field.
    pub fn mut_color(&mut self) -> &mut super::fixtures::ColorMixerChannel {
        if let ::std::option::Option::Some(write_control_request::Value::Color(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(write_control_request::Value::Color(super::fixtures::ColorMixerChannel::new()));
        }
        match self.value {
            ::std::option::Option::Some(write_control_request::Value::Color(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_color(&mut self) -> super::fixtures::ColorMixerChannel {
        if self.has_color() {
            match self.value.take() {
                ::std::option::Option::Some(write_control_request::Value::Color(v)) => v,
                _ => panic!(),
            }
        } else {
            super::fixtures::ColorMixerChannel::new()
        }
    }

    // .mizer.programmer.WriteControlRequest.GenericValue generic = 4;

    pub fn generic(&self) -> &write_control_request::GenericValue {
        match self.value {
            ::std::option::Option::Some(write_control_request::Value::Generic(ref v)) => v,
            _ => <write_control_request::GenericValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_generic(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_generic(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(write_control_request::Value::Generic(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_generic(&mut self, v: write_control_request::GenericValue) {
        self.value = ::std::option::Option::Some(write_control_request::Value::Generic(v))
    }

    // Mutable pointer to the field.
    pub fn mut_generic(&mut self) -> &mut write_control_request::GenericValue {
        if let ::std::option::Option::Some(write_control_request::Value::Generic(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(write_control_request::Value::Generic(write_control_request::GenericValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(write_control_request::Value::Generic(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_generic(&mut self) -> write_control_request::GenericValue {
        if self.has_generic() {
            match self.value.take() {
                ::std::option::Option::Some(write_control_request::Value::Generic(v)) => v,
                _ => panic!(),
            }
        } else {
            write_control_request::GenericValue::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "control",
            |m: &WriteControlRequest| { &m.control },
            |m: &mut WriteControlRequest| { &mut m.control },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "fader",
            WriteControlRequest::has_fader,
            WriteControlRequest::fader,
            WriteControlRequest::set_fader,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::fixtures::ColorMixerChannel>(
            "color",
            WriteControlRequest::has_color,
            WriteControlRequest::color,
            WriteControlRequest::mut_color,
            WriteControlRequest::set_color,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, write_control_request::GenericValue>(
            "generic",
            WriteControlRequest::has_generic,
            WriteControlRequest::generic,
            WriteControlRequest::mut_generic,
            WriteControlRequest::set_generic,
        ));
        oneofs.push(write_control_request::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteControlRequest>(
            "WriteControlRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteControlRequest {
    const NAME: &'static str = "WriteControlRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.control = is.read_enum_or_unknown()?;
                },
                17 => {
                    self.value = ::std::option::Option::Some(write_control_request::Value::Fader(is.read_double()?));
                },
                26 => {
                    self.value = ::std::option::Option::Some(write_control_request::Value::Color(is.read_message()?));
                },
                34 => {
                    self.value = ::std::option::Option::Some(write_control_request::Value::Generic(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.control != ::protobuf::EnumOrUnknown::new(super::fixtures::FixtureControl::INTENSITY) {
            my_size += ::protobuf::rt::int32_size(1, self.control.value());
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &write_control_request::Value::Fader(v) => {
                    my_size += 1 + 8;
                },
                &write_control_request::Value::Color(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_control_request::Value::Generic(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.control != ::protobuf::EnumOrUnknown::new(super::fixtures::FixtureControl::INTENSITY) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.control))?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &write_control_request::Value::Fader(v) => {
                    os.write_double(2, v)?;
                },
                &write_control_request::Value::Color(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &write_control_request::Value::Generic(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteControlRequest {
        WriteControlRequest::new()
    }

    fn clear(&mut self) {
        self.control = ::protobuf::EnumOrUnknown::new(super::fixtures::FixtureControl::INTENSITY);
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteControlRequest {
        static instance: WriteControlRequest = WriteControlRequest {
            control: ::protobuf::EnumOrUnknown::from_i32(0),
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteControlRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteControlRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteControlRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WriteControlRequest`
pub mod write_control_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.programmer.WriteControlRequest.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:mizer.programmer.WriteControlRequest.fader)
        Fader(f64),
        // @@protoc_insertion_point(oneof_field:mizer.programmer.WriteControlRequest.color)
        Color(super::super::fixtures::ColorMixerChannel),
        // @@protoc_insertion_point(oneof_field:mizer.programmer.WriteControlRequest.generic)
        Generic(GenericValue),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::WriteControlRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.programmer.WriteControlRequest.GenericValue)
    pub struct GenericValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.programmer.WriteControlRequest.GenericValue.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.programmer.WriteControlRequest.GenericValue.value)
        pub value: f64,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.programmer.WriteControlRequest.GenericValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GenericValue {
        fn default() -> &'a GenericValue {
            <GenericValue as ::protobuf::Message>::default_instance()
        }
    }

    impl GenericValue {
        pub fn new() -> GenericValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &GenericValue| { &m.name },
                |m: &mut GenericValue| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &GenericValue| { &m.value },
                |m: &mut GenericValue| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenericValue>(
                "WriteControlRequest.GenericValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GenericValue {
        const NAME: &'static str = "GenericValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    17 => {
                        self.value = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if self.value != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if self.value != 0. {
                os.write_double(2, self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GenericValue {
            GenericValue::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.value = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GenericValue {
            static instance: GenericValue = GenericValue {
                name: ::std::string::String::new(),
                value: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GenericValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("WriteControlRequest.GenericValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GenericValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GenericValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.WriteControlResponse)
pub struct WriteControlResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.WriteControlResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteControlResponse {
    fn default() -> &'a WriteControlResponse {
        <WriteControlResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteControlResponse {
    pub fn new() -> WriteControlResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteControlResponse>(
            "WriteControlResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteControlResponse {
    const NAME: &'static str = "WriteControlResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteControlResponse {
        WriteControlResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteControlResponse {
        static instance: WriteControlResponse = WriteControlResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteControlResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteControlResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteControlResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteControlResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.SelectFixturesRequest)
pub struct SelectFixturesRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.SelectFixturesRequest.fixtures)
    pub fixtures: ::std::vec::Vec<super::fixtures::FixtureId>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.SelectFixturesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectFixturesRequest {
    fn default() -> &'a SelectFixturesRequest {
        <SelectFixturesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SelectFixturesRequest {
    pub fn new() -> SelectFixturesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixtures",
            |m: &SelectFixturesRequest| { &m.fixtures },
            |m: &mut SelectFixturesRequest| { &mut m.fixtures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectFixturesRequest>(
            "SelectFixturesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectFixturesRequest {
    const NAME: &'static str = "SelectFixturesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fixtures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectFixturesRequest {
        SelectFixturesRequest::new()
    }

    fn clear(&mut self) {
        self.fixtures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectFixturesRequest {
        static instance: SelectFixturesRequest = SelectFixturesRequest {
            fixtures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectFixturesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectFixturesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectFixturesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectFixturesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.SelectFixturesResponse)
pub struct SelectFixturesResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.SelectFixturesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectFixturesResponse {
    fn default() -> &'a SelectFixturesResponse {
        <SelectFixturesResponse as ::protobuf::Message>::default_instance()
    }
}

impl SelectFixturesResponse {
    pub fn new() -> SelectFixturesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectFixturesResponse>(
            "SelectFixturesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectFixturesResponse {
    const NAME: &'static str = "SelectFixturesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectFixturesResponse {
        SelectFixturesResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectFixturesResponse {
        static instance: SelectFixturesResponse = SelectFixturesResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectFixturesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectFixturesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectFixturesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectFixturesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.UnselectFixturesRequest)
pub struct UnselectFixturesRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.UnselectFixturesRequest.fixtures)
    pub fixtures: ::std::vec::Vec<super::fixtures::FixtureId>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.UnselectFixturesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnselectFixturesRequest {
    fn default() -> &'a UnselectFixturesRequest {
        <UnselectFixturesRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnselectFixturesRequest {
    pub fn new() -> UnselectFixturesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixtures",
            |m: &UnselectFixturesRequest| { &m.fixtures },
            |m: &mut UnselectFixturesRequest| { &mut m.fixtures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnselectFixturesRequest>(
            "UnselectFixturesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnselectFixturesRequest {
    const NAME: &'static str = "UnselectFixturesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fixtures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnselectFixturesRequest {
        UnselectFixturesRequest::new()
    }

    fn clear(&mut self) {
        self.fixtures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnselectFixturesRequest {
        static instance: UnselectFixturesRequest = UnselectFixturesRequest {
            fixtures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnselectFixturesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnselectFixturesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnselectFixturesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnselectFixturesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.UnselectFixturesResponse)
pub struct UnselectFixturesResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.UnselectFixturesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnselectFixturesResponse {
    fn default() -> &'a UnselectFixturesResponse {
        <UnselectFixturesResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnselectFixturesResponse {
    pub fn new() -> UnselectFixturesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnselectFixturesResponse>(
            "UnselectFixturesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnselectFixturesResponse {
    const NAME: &'static str = "UnselectFixturesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnselectFixturesResponse {
        UnselectFixturesResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnselectFixturesResponse {
        static instance: UnselectFixturesResponse = UnselectFixturesResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnselectFixturesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnselectFixturesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnselectFixturesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnselectFixturesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.ClearRequest)
pub struct ClearRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.ClearRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClearRequest {
    fn default() -> &'a ClearRequest {
        <ClearRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClearRequest {
    pub fn new() -> ClearRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClearRequest>(
            "ClearRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClearRequest {
    const NAME: &'static str = "ClearRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClearRequest {
        ClearRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClearRequest {
        static instance: ClearRequest = ClearRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClearRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClearRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClearRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.ClearResponse)
pub struct ClearResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.ClearResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClearResponse {
    fn default() -> &'a ClearResponse {
        <ClearResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClearResponse {
    pub fn new() -> ClearResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClearResponse>(
            "ClearResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClearResponse {
    const NAME: &'static str = "ClearResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClearResponse {
        ClearResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClearResponse {
        static instance: ClearResponse = ClearResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClearResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClearResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClearResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.HighlightRequest)
pub struct HighlightRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.HighlightRequest.highlight)
    pub highlight: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.HighlightRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HighlightRequest {
    fn default() -> &'a HighlightRequest {
        <HighlightRequest as ::protobuf::Message>::default_instance()
    }
}

impl HighlightRequest {
    pub fn new() -> HighlightRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "highlight",
            |m: &HighlightRequest| { &m.highlight },
            |m: &mut HighlightRequest| { &mut m.highlight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HighlightRequest>(
            "HighlightRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HighlightRequest {
    const NAME: &'static str = "HighlightRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.highlight = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.highlight != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.highlight != false {
            os.write_bool(1, self.highlight)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HighlightRequest {
        HighlightRequest::new()
    }

    fn clear(&mut self) {
        self.highlight = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HighlightRequest {
        static instance: HighlightRequest = HighlightRequest {
            highlight: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HighlightRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HighlightRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HighlightRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HighlightRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.HighlightResponse)
pub struct HighlightResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.HighlightResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HighlightResponse {
    fn default() -> &'a HighlightResponse {
        <HighlightResponse as ::protobuf::Message>::default_instance()
    }
}

impl HighlightResponse {
    pub fn new() -> HighlightResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HighlightResponse>(
            "HighlightResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HighlightResponse {
    const NAME: &'static str = "HighlightResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HighlightResponse {
        HighlightResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HighlightResponse {
        static instance: HighlightResponse = HighlightResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HighlightResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HighlightResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HighlightResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HighlightResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.StoreRequest)
pub struct StoreRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.StoreRequest.sequence_id)
    pub sequence_id: u32,
    // @@protoc_insertion_point(field:mizer.programmer.StoreRequest.store_mode)
    pub store_mode: ::protobuf::EnumOrUnknown<store_request::Mode>,
    // @@protoc_insertion_point(field:mizer.programmer.StoreRequest.cue_id)
    pub cue_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.StoreRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreRequest {
    fn default() -> &'a StoreRequest {
        <StoreRequest as ::protobuf::Message>::default_instance()
    }
}

impl StoreRequest {
    pub fn new() -> StoreRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence_id",
            |m: &StoreRequest| { &m.sequence_id },
            |m: &mut StoreRequest| { &mut m.sequence_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "store_mode",
            |m: &StoreRequest| { &m.store_mode },
            |m: &mut StoreRequest| { &mut m.store_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cue_id",
            |m: &StoreRequest| { &m.cue_id },
            |m: &mut StoreRequest| { &mut m.cue_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StoreRequest>(
            "StoreRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StoreRequest {
    const NAME: &'static str = "StoreRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence_id = is.read_uint32()?;
                },
                16 => {
                    self.store_mode = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.cue_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence_id);
        }
        if self.store_mode != ::protobuf::EnumOrUnknown::new(store_request::Mode::OVERWRITE) {
            my_size += ::protobuf::rt::int32_size(2, self.store_mode.value());
        }
        if let Some(v) = self.cue_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence_id != 0 {
            os.write_uint32(1, self.sequence_id)?;
        }
        if self.store_mode != ::protobuf::EnumOrUnknown::new(store_request::Mode::OVERWRITE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.store_mode))?;
        }
        if let Some(v) = self.cue_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreRequest {
        StoreRequest::new()
    }

    fn clear(&mut self) {
        self.sequence_id = 0;
        self.store_mode = ::protobuf::EnumOrUnknown::new(store_request::Mode::OVERWRITE);
        self.cue_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreRequest {
        static instance: StoreRequest = StoreRequest {
            sequence_id: 0,
            store_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            cue_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StoreRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StoreRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StoreRequest`
pub mod store_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.programmer.StoreRequest.Mode)
    pub enum Mode {
        // @@protoc_insertion_point(enum_value:mizer.programmer.StoreRequest.Mode.OVERWRITE)
        OVERWRITE = 0,
        // @@protoc_insertion_point(enum_value:mizer.programmer.StoreRequest.Mode.MERGE)
        MERGE = 1,
        // @@protoc_insertion_point(enum_value:mizer.programmer.StoreRequest.Mode.ADD_CUE)
        ADD_CUE = 2,
    }

    impl ::protobuf::Enum for Mode {
        const NAME: &'static str = "Mode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Mode> {
            match value {
                0 => ::std::option::Option::Some(Mode::OVERWRITE),
                1 => ::std::option::Option::Some(Mode::MERGE),
                2 => ::std::option::Option::Some(Mode::ADD_CUE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Mode] = &[
            Mode::OVERWRITE,
            Mode::MERGE,
            Mode::ADD_CUE,
        ];
    }

    impl ::protobuf::EnumFull for Mode {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("StoreRequest.Mode").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Mode {
        fn default() -> Self {
            Mode::OVERWRITE
        }
    }

    impl Mode {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Mode>("StoreRequest.Mode")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.StoreResponse)
pub struct StoreResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.StoreResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreResponse {
    fn default() -> &'a StoreResponse {
        <StoreResponse as ::protobuf::Message>::default_instance()
    }
}

impl StoreResponse {
    pub fn new() -> StoreResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StoreResponse>(
            "StoreResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StoreResponse {
    const NAME: &'static str = "StoreResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreResponse {
        StoreResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreResponse {
        static instance: StoreResponse = StoreResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StoreResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StoreResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.PresetsRequest)
pub struct PresetsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.PresetsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PresetsRequest {
    fn default() -> &'a PresetsRequest {
        <PresetsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PresetsRequest {
    pub fn new() -> PresetsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PresetsRequest>(
            "PresetsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PresetsRequest {
    const NAME: &'static str = "PresetsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PresetsRequest {
        PresetsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PresetsRequest {
        static instance: PresetsRequest = PresetsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PresetsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PresetsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PresetsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PresetsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.PresetId)
pub struct PresetId {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.PresetId.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.programmer.PresetId.type)
    pub type_: ::protobuf::EnumOrUnknown<preset_id::PresetType>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.PresetId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PresetId {
    fn default() -> &'a PresetId {
        <PresetId as ::protobuf::Message>::default_instance()
    }
}

impl PresetId {
    pub fn new() -> PresetId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &PresetId| { &m.id },
            |m: &mut PresetId| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &PresetId| { &m.type_ },
            |m: &mut PresetId| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PresetId>(
            "PresetId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PresetId {
    const NAME: &'static str = "PresetId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(preset_id::PresetType::INTENSITY) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(preset_id::PresetType::INTENSITY) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PresetId {
        PresetId::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(preset_id::PresetType::INTENSITY);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PresetId {
        static instance: PresetId = PresetId {
            id: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PresetId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PresetId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PresetId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PresetId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PresetId`
pub mod preset_id {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.programmer.PresetId.PresetType)
    pub enum PresetType {
        // @@protoc_insertion_point(enum_value:mizer.programmer.PresetId.PresetType.INTENSITY)
        INTENSITY = 0,
        // @@protoc_insertion_point(enum_value:mizer.programmer.PresetId.PresetType.SHUTTER)
        SHUTTER = 1,
        // @@protoc_insertion_point(enum_value:mizer.programmer.PresetId.PresetType.COLOR)
        COLOR = 2,
        // @@protoc_insertion_point(enum_value:mizer.programmer.PresetId.PresetType.POSITION)
        POSITION = 3,
    }

    impl ::protobuf::Enum for PresetType {
        const NAME: &'static str = "PresetType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PresetType> {
            match value {
                0 => ::std::option::Option::Some(PresetType::INTENSITY),
                1 => ::std::option::Option::Some(PresetType::SHUTTER),
                2 => ::std::option::Option::Some(PresetType::COLOR),
                3 => ::std::option::Option::Some(PresetType::POSITION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PresetType] = &[
            PresetType::INTENSITY,
            PresetType::SHUTTER,
            PresetType::COLOR,
            PresetType::POSITION,
        ];
    }

    impl ::protobuf::EnumFull for PresetType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PresetId.PresetType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PresetType {
        fn default() -> Self {
            PresetType::INTENSITY
        }
    }

    impl PresetType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PresetType>("PresetId.PresetType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.Presets)
pub struct Presets {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.Presets.intensities)
    pub intensities: ::std::vec::Vec<Preset>,
    // @@protoc_insertion_point(field:mizer.programmer.Presets.shutters)
    pub shutters: ::std::vec::Vec<Preset>,
    // @@protoc_insertion_point(field:mizer.programmer.Presets.colors)
    pub colors: ::std::vec::Vec<Preset>,
    // @@protoc_insertion_point(field:mizer.programmer.Presets.positions)
    pub positions: ::std::vec::Vec<Preset>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.Presets.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Presets {
    fn default() -> &'a Presets {
        <Presets as ::protobuf::Message>::default_instance()
    }
}

impl Presets {
    pub fn new() -> Presets {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "intensities",
            |m: &Presets| { &m.intensities },
            |m: &mut Presets| { &mut m.intensities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shutters",
            |m: &Presets| { &m.shutters },
            |m: &mut Presets| { &mut m.shutters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colors",
            |m: &Presets| { &m.colors },
            |m: &mut Presets| { &mut m.colors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "positions",
            |m: &Presets| { &m.positions },
            |m: &mut Presets| { &mut m.positions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Presets>(
            "Presets",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Presets {
    const NAME: &'static str = "Presets";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.intensities.push(is.read_message()?);
                },
                18 => {
                    self.shutters.push(is.read_message()?);
                },
                26 => {
                    self.colors.push(is.read_message()?);
                },
                34 => {
                    self.positions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.intensities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.shutters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.colors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.intensities {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.shutters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.colors {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.positions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Presets {
        Presets::new()
    }

    fn clear(&mut self) {
        self.intensities.clear();
        self.shutters.clear();
        self.colors.clear();
        self.positions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Presets {
        static instance: Presets = Presets {
            intensities: ::std::vec::Vec::new(),
            shutters: ::std::vec::Vec::new(),
            colors: ::std::vec::Vec::new(),
            positions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Presets {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Presets").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Presets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Presets {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.Preset)
pub struct Preset {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.Preset.id)
    pub id: ::protobuf::MessageField<PresetId>,
    // @@protoc_insertion_point(field:mizer.programmer.Preset.label)
    pub label: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub value: ::std::option::Option<preset::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.Preset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Preset {
    fn default() -> &'a Preset {
        <Preset as ::protobuf::Message>::default_instance()
    }
}

impl Preset {
    pub fn new() -> Preset {
        ::std::default::Default::default()
    }

    // double fader = 3;

    pub fn fader(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(preset::Value::Fader(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_fader(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_fader(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(preset::Value::Fader(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fader(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(preset::Value::Fader(v))
    }

    // .mizer.programmer.Preset.Color color = 4;

    pub fn color(&self) -> &preset::Color {
        match self.value {
            ::std::option::Option::Some(preset::Value::Color(ref v)) => v,
            _ => <preset::Color as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_color(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(preset::Value::Color(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: preset::Color) {
        self.value = ::std::option::Option::Some(preset::Value::Color(v))
    }

    // Mutable pointer to the field.
    pub fn mut_color(&mut self) -> &mut preset::Color {
        if let ::std::option::Option::Some(preset::Value::Color(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(preset::Value::Color(preset::Color::new()));
        }
        match self.value {
            ::std::option::Option::Some(preset::Value::Color(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_color(&mut self) -> preset::Color {
        if self.has_color() {
            match self.value.take() {
                ::std::option::Option::Some(preset::Value::Color(v)) => v,
                _ => panic!(),
            }
        } else {
            preset::Color::new()
        }
    }

    // .mizer.programmer.Preset.Position position = 5;

    pub fn position(&self) -> &preset::Position {
        match self.value {
            ::std::option::Option::Some(preset::Value::Position(ref v)) => v,
            _ => <preset::Position as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_position(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(preset::Value::Position(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: preset::Position) {
        self.value = ::std::option::Option::Some(preset::Value::Position(v))
    }

    // Mutable pointer to the field.
    pub fn mut_position(&mut self) -> &mut preset::Position {
        if let ::std::option::Option::Some(preset::Value::Position(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(preset::Value::Position(preset::Position::new()));
        }
        match self.value {
            ::std::option::Option::Some(preset::Value::Position(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_position(&mut self) -> preset::Position {
        if self.has_position() {
            match self.value.take() {
                ::std::option::Option::Some(preset::Value::Position(v)) => v,
                _ => panic!(),
            }
        } else {
            preset::Position::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PresetId>(
            "id",
            |m: &Preset| { &m.id },
            |m: &mut Preset| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &Preset| { &m.label },
            |m: &mut Preset| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "fader",
            Preset::has_fader,
            Preset::fader,
            Preset::set_fader,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, preset::Color>(
            "color",
            Preset::has_color,
            Preset::color,
            Preset::mut_color,
            Preset::set_color,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, preset::Position>(
            "position",
            Preset::has_position,
            Preset::position,
            Preset::mut_position,
            Preset::set_position,
        ));
        oneofs.push(preset::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Preset>(
            "Preset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Preset {
    const NAME: &'static str = "Preset";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                18 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.value = ::std::option::Option::Some(preset::Value::Fader(is.read_double()?));
                },
                34 => {
                    self.value = ::std::option::Option::Some(preset::Value::Color(is.read_message()?));
                },
                42 => {
                    self.value = ::std::option::Option::Some(preset::Value::Position(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &preset::Value::Fader(v) => {
                    my_size += 1 + 8;
                },
                &preset::Value::Color(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &preset::Value::Position(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &preset::Value::Fader(v) => {
                    os.write_double(3, v)?;
                },
                &preset::Value::Color(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &preset::Value::Position(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Preset {
        Preset::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.label = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Preset {
        static instance: Preset = Preset {
            id: ::protobuf::MessageField::none(),
            label: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Preset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Preset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Preset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Preset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Preset`
pub mod preset {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.programmer.Preset.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:mizer.programmer.Preset.fader)
        Fader(f64),
        // @@protoc_insertion_point(oneof_field:mizer.programmer.Preset.color)
        Color(Color),
        // @@protoc_insertion_point(oneof_field:mizer.programmer.Preset.position)
        Position(Position),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Preset as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.programmer.Preset.Color)
    pub struct Color {
        // message fields
        // @@protoc_insertion_point(field:mizer.programmer.Preset.Color.red)
        pub red: f64,
        // @@protoc_insertion_point(field:mizer.programmer.Preset.Color.green)
        pub green: f64,
        // @@protoc_insertion_point(field:mizer.programmer.Preset.Color.blue)
        pub blue: f64,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.programmer.Preset.Color.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Color {
        fn default() -> &'a Color {
            <Color as ::protobuf::Message>::default_instance()
        }
    }

    impl Color {
        pub fn new() -> Color {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "red",
                |m: &Color| { &m.red },
                |m: &mut Color| { &mut m.red },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "green",
                |m: &Color| { &m.green },
                |m: &mut Color| { &mut m.green },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "blue",
                |m: &Color| { &m.blue },
                |m: &mut Color| { &mut m.blue },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Color>(
                "Preset.Color",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Color {
        const NAME: &'static str = "Color";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.red = is.read_double()?;
                    },
                    17 => {
                        self.green = is.read_double()?;
                    },
                    25 => {
                        self.blue = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.red != 0. {
                my_size += 1 + 8;
            }
            if self.green != 0. {
                my_size += 1 + 8;
            }
            if self.blue != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.red != 0. {
                os.write_double(1, self.red)?;
            }
            if self.green != 0. {
                os.write_double(2, self.green)?;
            }
            if self.blue != 0. {
                os.write_double(3, self.blue)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Color {
            Color::new()
        }

        fn clear(&mut self) {
            self.red = 0.;
            self.green = 0.;
            self.blue = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Color {
            static instance: Color = Color {
                red: 0.,
                green: 0.,
                blue: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Color {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Preset.Color").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Color {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Color {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.programmer.Preset.Position)
    pub struct Position {
        // message fields
        // @@protoc_insertion_point(field:mizer.programmer.Preset.Position.tilt)
        pub tilt: f64,
        // @@protoc_insertion_point(field:mizer.programmer.Preset.Position.pan)
        pub pan: f64,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.programmer.Preset.Position.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Position {
        fn default() -> &'a Position {
            <Position as ::protobuf::Message>::default_instance()
        }
    }

    impl Position {
        pub fn new() -> Position {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "tilt",
                |m: &Position| { &m.tilt },
                |m: &mut Position| { &mut m.tilt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "pan",
                |m: &Position| { &m.pan },
                |m: &mut Position| { &mut m.pan },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
                "Preset.Position",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Position {
        const NAME: &'static str = "Position";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.tilt = is.read_double()?;
                    },
                    17 => {
                        self.pan = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.tilt != 0. {
                my_size += 1 + 8;
            }
            if self.pan != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.tilt != 0. {
                os.write_double(1, self.tilt)?;
            }
            if self.pan != 0. {
                os.write_double(2, self.pan)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Position {
            Position::new()
        }

        fn clear(&mut self) {
            self.tilt = 0.;
            self.pan = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Position {
            static instance: Position = Position {
                tilt: 0.,
                pan: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Position {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Preset.Position").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Position {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Position {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.CallPresetResponse)
pub struct CallPresetResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.CallPresetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CallPresetResponse {
    fn default() -> &'a CallPresetResponse {
        <CallPresetResponse as ::protobuf::Message>::default_instance()
    }
}

impl CallPresetResponse {
    pub fn new() -> CallPresetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CallPresetResponse>(
            "CallPresetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CallPresetResponse {
    const NAME: &'static str = "CallPresetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CallPresetResponse {
        CallPresetResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CallPresetResponse {
        static instance: CallPresetResponse = CallPresetResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CallPresetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CallPresetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CallPresetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallPresetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.GroupsRequest)
pub struct GroupsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.GroupsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupsRequest {
    fn default() -> &'a GroupsRequest {
        <GroupsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GroupsRequest {
    pub fn new() -> GroupsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupsRequest>(
            "GroupsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupsRequest {
    const NAME: &'static str = "GroupsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupsRequest {
        GroupsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupsRequest {
        static instance: GroupsRequest = GroupsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.Groups)
pub struct Groups {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.Groups.groups)
    pub groups: ::std::vec::Vec<Group>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.Groups.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Groups {
    fn default() -> &'a Groups {
        <Groups as ::protobuf::Message>::default_instance()
    }
}

impl Groups {
    pub fn new() -> Groups {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groups",
            |m: &Groups| { &m.groups },
            |m: &mut Groups| { &mut m.groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Groups>(
            "Groups",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Groups {
    const NAME: &'static str = "Groups";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.groups {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Groups {
        Groups::new()
    }

    fn clear(&mut self) {
        self.groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Groups {
        static instance: Groups = Groups {
            groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Groups {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Groups").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Groups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Groups {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.Group)
pub struct Group {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.Group.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.programmer.Group.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.Group.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Group {
    fn default() -> &'a Group {
        <Group as ::protobuf::Message>::default_instance()
    }
}

impl Group {
    pub fn new() -> Group {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Group| { &m.id },
            |m: &mut Group| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Group| { &m.name },
            |m: &mut Group| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Group>(
            "Group",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Group {
    const NAME: &'static str = "Group";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Group {
        Group::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Group {
        static instance: Group = Group {
            id: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Group {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Group").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Group {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Group {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.SelectGroupRequest)
pub struct SelectGroupRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.SelectGroupRequest.id)
    pub id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.SelectGroupRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectGroupRequest {
    fn default() -> &'a SelectGroupRequest {
        <SelectGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl SelectGroupRequest {
    pub fn new() -> SelectGroupRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SelectGroupRequest| { &m.id },
            |m: &mut SelectGroupRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectGroupRequest>(
            "SelectGroupRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectGroupRequest {
    const NAME: &'static str = "SelectGroupRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectGroupRequest {
        SelectGroupRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectGroupRequest {
        static instance: SelectGroupRequest = SelectGroupRequest {
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectGroupRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectGroupRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectGroupRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.SelectGroupResponse)
pub struct SelectGroupResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.SelectGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectGroupResponse {
    fn default() -> &'a SelectGroupResponse {
        <SelectGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl SelectGroupResponse {
    pub fn new() -> SelectGroupResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectGroupResponse>(
            "SelectGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectGroupResponse {
    const NAME: &'static str = "SelectGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectGroupResponse {
        SelectGroupResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectGroupResponse {
        static instance: SelectGroupResponse = SelectGroupResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectGroupResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectGroupResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.AddGroupRequest)
pub struct AddGroupRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.AddGroupRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.AddGroupRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddGroupRequest {
    fn default() -> &'a AddGroupRequest {
        <AddGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddGroupRequest {
    pub fn new() -> AddGroupRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AddGroupRequest| { &m.name },
            |m: &mut AddGroupRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddGroupRequest>(
            "AddGroupRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddGroupRequest {
    const NAME: &'static str = "AddGroupRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddGroupRequest {
        AddGroupRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddGroupRequest {
        static instance: AddGroupRequest = AddGroupRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddGroupRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddGroupRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddGroupRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.AssignFixturesToGroupRequest)
pub struct AssignFixturesToGroupRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.AssignFixturesToGroupRequest.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.programmer.AssignFixturesToGroupRequest.fixtures)
    pub fixtures: ::std::vec::Vec<super::fixtures::FixtureId>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.AssignFixturesToGroupRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AssignFixturesToGroupRequest {
    fn default() -> &'a AssignFixturesToGroupRequest {
        <AssignFixturesToGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl AssignFixturesToGroupRequest {
    pub fn new() -> AssignFixturesToGroupRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &AssignFixturesToGroupRequest| { &m.id },
            |m: &mut AssignFixturesToGroupRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixtures",
            |m: &AssignFixturesToGroupRequest| { &m.fixtures },
            |m: &mut AssignFixturesToGroupRequest| { &mut m.fixtures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AssignFixturesToGroupRequest>(
            "AssignFixturesToGroupRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AssignFixturesToGroupRequest {
    const NAME: &'static str = "AssignFixturesToGroupRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.fixtures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        for value in &self.fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        for v in &self.fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AssignFixturesToGroupRequest {
        AssignFixturesToGroupRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.fixtures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AssignFixturesToGroupRequest {
        static instance: AssignFixturesToGroupRequest = AssignFixturesToGroupRequest {
            id: 0,
            fixtures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AssignFixturesToGroupRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AssignFixturesToGroupRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AssignFixturesToGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssignFixturesToGroupRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.AssignFixtureSelectionToGroupRequest)
pub struct AssignFixtureSelectionToGroupRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.programmer.AssignFixtureSelectionToGroupRequest.id)
    pub id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.AssignFixtureSelectionToGroupRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AssignFixtureSelectionToGroupRequest {
    fn default() -> &'a AssignFixtureSelectionToGroupRequest {
        <AssignFixtureSelectionToGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl AssignFixtureSelectionToGroupRequest {
    pub fn new() -> AssignFixtureSelectionToGroupRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &AssignFixtureSelectionToGroupRequest| { &m.id },
            |m: &mut AssignFixtureSelectionToGroupRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AssignFixtureSelectionToGroupRequest>(
            "AssignFixtureSelectionToGroupRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AssignFixtureSelectionToGroupRequest {
    const NAME: &'static str = "AssignFixtureSelectionToGroupRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AssignFixtureSelectionToGroupRequest {
        AssignFixtureSelectionToGroupRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AssignFixtureSelectionToGroupRequest {
        static instance: AssignFixtureSelectionToGroupRequest = AssignFixtureSelectionToGroupRequest {
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AssignFixtureSelectionToGroupRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AssignFixtureSelectionToGroupRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AssignFixtureSelectionToGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssignFixtureSelectionToGroupRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.programmer.AssignFixturesToGroupResponse)
pub struct AssignFixturesToGroupResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.programmer.AssignFixturesToGroupResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AssignFixturesToGroupResponse {
    fn default() -> &'a AssignFixturesToGroupResponse {
        <AssignFixturesToGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl AssignFixturesToGroupResponse {
    pub fn new() -> AssignFixturesToGroupResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AssignFixturesToGroupResponse>(
            "AssignFixturesToGroupResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AssignFixturesToGroupResponse {
    const NAME: &'static str = "AssignFixturesToGroupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AssignFixturesToGroupResponse {
        AssignFixturesToGroupResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AssignFixturesToGroupResponse {
        static instance: AssignFixturesToGroupResponse = AssignFixturesToGroupResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AssignFixturesToGroupResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AssignFixturesToGroupResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AssignFixturesToGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssignFixturesToGroupResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10programmer.proto\x12\x10mizer.programmer\x1a\x0efixtures.proto\"\
    \x1c\n\x1aSubscribeProgrammerRequest\"\xe2\x03\n\x0fProgrammerState\x125\
    \n\x08fixtures\x18\x01\x20\x03(\x0b2\x19.mizer.fixtures.FixtureIdR\x08fi\
    xtures\x12B\n\x0factive_fixtures\x18\x02\x20\x03(\x0b2\x19.mizer.fixture\
    s.FixtureIdR\x0eactiveFixtures\x12#\n\ractive_groups\x18\x03\x20\x03(\rR\
    \x0cactiveGroups\x12@\n\tselection\x18\x04\x20\x01(\x0b2\".mizer.program\
    mer.FixtureSelectionR\tselection\x12?\n\x08controls\x18\x05\x20\x03(\x0b\
    2#.mizer.programmer.ProgrammerChannelR\x08controls\x12\x1c\n\thighlight\
    \x18\x06\x20\x01(\x08R\thighlight\x12\x1d\n\nblock_size\x18\x07\x20\x01(\
    \rR\tblockSize\x12\x16\n\x06groups\x18\x08\x20\x01(\rR\x06groups\x12\x14\
    \n\x05wings\x18\t\x20\x01(\rR\x05wings\x12A\n\x07effects\x18\n\x20\x03(\
    \x0b2'.mizer.programmer.EffectProgrammerStateR\x07effects\"\xb2\x01\n\
    \x10FixtureSelection\x12Q\n\x08fixtures\x18\x01\x20\x03(\x0b25.mizer.pro\
    grammer.FixtureSelection.GroupedFixtureListR\x08fixtures\x1aK\n\x12Group\
    edFixtureList\x125\n\x08fixtures\x18\x01\x20\x03(\x0b2\x19.mizer.fixture\
    s.FixtureIdR\x08fixtures\"\x96\x03\n\x11ProgrammerChannel\x125\n\x08fixt\
    ures\x18\x01\x20\x03(\x0b2\x19.mizer.fixtures.FixtureIdR\x08fixtures\x12\
    8\n\x07control\x18\x02\x20\x01(\x0e2\x1e.mizer.fixtures.FixtureControlR\
    \x07control\x12\x16\n\x05fader\x18\x03\x20\x01(\x01H\0R\x05fader\x129\n\
    \x05color\x18\x04\x20\x01(\x0b2!.mizer.fixtures.ColorMixerChannelH\0R\
    \x05color\x12L\n\x07generic\x18\x05\x20\x01(\x0b20.mizer.programmer.Prog\
    rammerChannel.GenericValueH\0R\x07generic\x1a8\n\x0cGenericValue\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x01R\x05value\",\n\x0cColorChannel\x12\x07\n\x03RED\x10\0\x12\t\n\
    \x05GREEN\x10\x01\x12\x08\n\x04BLUE\x10\x02B\x07\n\x05value\"\x91\x01\n\
    \x15EffectProgrammerState\x12\x1b\n\teffect_id\x18\x01\x20\x01(\rR\x08ef\
    fectId\x12\x1f\n\x0beffect_rate\x18\x02\x20\x01(\x01R\neffectRate\x12(\n\
    \reffect_offset\x18\x03\x20\x01(\x01H\0R\x0ceffectOffset\x88\x01\x01B\
    \x10\n\x0e_effect_offset\"V\n\x16WriteEffectRateRequest\x12\x1b\n\teffec\
    t_id\x18\x01\x20\x01(\rR\x08effectId\x12\x1f\n\x0beffect_rate\x18\x02\
    \x20\x01(\x01R\neffectRate\"\x19\n\x17WriteEffectRateResponse\"s\n\x18Wr\
    iteEffectOffsetRequest\x12\x1b\n\teffect_id\x18\x01\x20\x01(\rR\x08effec\
    tId\x12(\n\reffect_offset\x18\x02\x20\x01(\x01H\0R\x0ceffectOffset\x88\
    \x01\x01B\x10\n\x0e_effect_offset\"\x1b\n\x19WriteEffectOffsetResponse\"\
    \xb5\x02\n\x13WriteControlRequest\x128\n\x07control\x18\x01\x20\x01(\x0e\
    2\x1e.mizer.fixtures.FixtureControlR\x07control\x12\x16\n\x05fader\x18\
    \x02\x20\x01(\x01H\0R\x05fader\x129\n\x05color\x18\x03\x20\x01(\x0b2!.mi\
    zer.fixtures.ColorMixerChannelH\0R\x05color\x12N\n\x07generic\x18\x04\
    \x20\x01(\x0b22.mizer.programmer.WriteControlRequest.GenericValueH\0R\
    \x07generic\x1a8\n\x0cGenericValue\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05valueB\x07\n\x05val\
    ue\"\x16\n\x14WriteControlResponse\"N\n\x15SelectFixturesRequest\x125\n\
    \x08fixtures\x18\x01\x20\x03(\x0b2\x19.mizer.fixtures.FixtureIdR\x08fixt\
    ures\"\x18\n\x16SelectFixturesResponse\"P\n\x17UnselectFixturesRequest\
    \x125\n\x08fixtures\x18\x01\x20\x03(\x0b2\x19.mizer.fixtures.FixtureIdR\
    \x08fixtures\"\x1a\n\x18UnselectFixturesResponse\"\x0e\n\x0cClearRequest\
    \"\x0f\n\rClearResponse\"0\n\x10HighlightRequest\x12\x1c\n\thighlight\
    \x18\x01\x20\x01(\x08R\thighlight\"\x13\n\x11HighlightResponse\"\xc9\x01\
    \n\x0cStoreRequest\x12\x1f\n\x0bsequence_id\x18\x01\x20\x01(\rR\nsequenc\
    eId\x12B\n\nstore_mode\x18\x02\x20\x01(\x0e2#.mizer.programmer.StoreRequ\
    est.ModeR\tstoreMode\x12\x1a\n\x06cue_id\x18\x03\x20\x01(\rH\0R\x05cueId\
    \x88\x01\x01\"-\n\x04Mode\x12\r\n\tOVERWRITE\x10\0\x12\t\n\x05MERGE\x10\
    \x01\x12\x0b\n\x07ADD_CUE\x10\x02B\t\n\x07_cue_id\"\x0f\n\rStoreResponse\
    \"\x10\n\x0ePresetsRequest\"\x98\x01\n\x08PresetId\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\rR\x02id\x129\n\x04type\x18\x02\x20\x01(\x0e2%.mizer.progr\
    ammer.PresetId.PresetTypeR\x04type\"A\n\nPresetType\x12\r\n\tINTENSITY\
    \x10\0\x12\x0b\n\x07SHUTTER\x10\x01\x12\t\n\x05COLOR\x10\x02\x12\x0c\n\
    \x08POSITION\x10\x03\"\xe5\x01\n\x07Presets\x12:\n\x0bintensities\x18\
    \x01\x20\x03(\x0b2\x18.mizer.programmer.PresetR\x0bintensities\x124\n\
    \x08shutters\x18\x02\x20\x03(\x0b2\x18.mizer.programmer.PresetR\x08shutt\
    ers\x120\n\x06colors\x18\x03\x20\x03(\x0b2\x18.mizer.programmer.PresetR\
    \x06colors\x126\n\tpositions\x18\x04\x20\x03(\x0b2\x18.mizer.programmer.\
    PresetR\tpositions\"\xea\x02\n\x06Preset\x12*\n\x02id\x18\x01\x20\x01(\
    \x0b2\x1a.mizer.programmer.PresetIdR\x02id\x12\x19\n\x05label\x18\x02\
    \x20\x01(\tH\0R\x05label\x88\x01\x01\x12\x16\n\x05fader\x18\x03\x20\x01(\
    \x01H\x01R\x05fader\x126\n\x05color\x18\x04\x20\x01(\x0b2\x1e.mizer.prog\
    rammer.Preset.ColorH\x01R\x05color\x12?\n\x08position\x18\x05\x20\x01(\
    \x0b2!.mizer.programmer.Preset.PositionH\x01R\x08position\x1aC\n\x05Colo\
    r\x12\x10\n\x03red\x18\x01\x20\x01(\x01R\x03red\x12\x14\n\x05green\x18\
    \x02\x20\x01(\x01R\x05green\x12\x12\n\x04blue\x18\x03\x20\x01(\x01R\x04b\
    lue\x1a0\n\x08Position\x12\x12\n\x04tilt\x18\x01\x20\x01(\x01R\x04tilt\
    \x12\x10\n\x03pan\x18\x02\x20\x01(\x01R\x03panB\x08\n\x06_labelB\x07\n\
    \x05value\"\x14\n\x12CallPresetResponse\"\x0f\n\rGroupsRequest\"9\n\x06G\
    roups\x12/\n\x06groups\x18\x01\x20\x03(\x0b2\x17.mizer.programmer.GroupR\
    \x06groups\"+\n\x05Group\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"$\n\x12SelectGroupRequest\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\"\x15\n\x13SelectGroupRespons\
    e\"%\n\x0fAddGroupRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \"e\n\x1cAssignFixturesToGroupRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\r\
    R\x02id\x125\n\x08fixtures\x18\x02\x20\x03(\x0b2\x19.mizer.fixtures.Fixt\
    ureIdR\x08fixtures\"6\n$AssignFixtureSelectionToGroupRequest\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\rR\x02id\"\x1f\n\x1dAssignFixturesToGroupRespons\
    e2\xf4\x0b\n\rProgrammerApi\x12h\n\x15SubscribeToProgrammer\x12,.mizer.p\
    rogrammer.SubscribeProgrammerRequest\x1a!.mizer.programmer.ProgrammerSta\
    te\x12]\n\x0cWriteControl\x12%.mizer.programmer.WriteControlRequest\x1a&\
    .mizer.programmer.WriteControlResponse\x12c\n\x0eSelectFixtures\x12'.miz\
    er.programmer.SelectFixturesRequest\x1a(.mizer.programmer.SelectFixtures\
    Response\x12i\n\x10UnselectFixtures\x12).mizer.programmer.UnselectFixtur\
    esRequest\x1a*.mizer.programmer.UnselectFixturesResponse\x12H\n\x05Clear\
    \x12\x1e.mizer.programmer.ClearRequest\x1a\x1f.mizer.programmer.ClearRes\
    ponse\x12T\n\tHighlight\x12\".mizer.programmer.HighlightRequest\x1a#.miz\
    er.programmer.HighlightResponse\x12H\n\x05Store\x12\x1e.mizer.programmer\
    .StoreRequest\x1a\x1f.mizer.programmer.StoreResponse\x12I\n\nGetPresets\
    \x12\x20.mizer.programmer.PresetsRequest\x1a\x19.mizer.programmer.Preset\
    s\x12N\n\nCallPreset\x12\x1a.mizer.programmer.PresetId\x1a$.mizer.progra\
    mmer.CallPresetResponse\x12F\n\tGetGroups\x12\x1f.mizer.programmer.Group\
    sRequest\x1a\x18.mizer.programmer.Groups\x12Z\n\x0bSelectGroup\x12$.mize\
    r.programmer.SelectGroupRequest\x1a%.mizer.programmer.SelectGroupRespons\
    e\x12F\n\x08AddGroup\x12!.mizer.programmer.AddGroupRequest\x1a\x17.mizer\
    .programmer.Group\x12x\n\x15AssignFixturesToGroup\x12..mizer.programmer.\
    AssignFixturesToGroupRequest\x1a/.mizer.programmer.AssignFixturesToGroup\
    Response\x12\x88\x01\n\x1dAssignFixtureSelectionToGroup\x126.mizer.progr\
    ammer.AssignFixtureSelectionToGroupRequest\x1a/.mizer.programmer.AssignF\
    ixturesToGroupResponse\x12f\n\x0fWriteEffectRate\x12(.mizer.programmer.W\
    riteEffectRateRequest\x1a).mizer.programmer.WriteEffectRateResponse\x12l\
    \n\x11WriteEffectOffset\x12*.mizer.programmer.WriteEffectOffsetRequest\
    \x1a+.mizer.programmer.WriteEffectOffsetResponseb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::fixtures::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(40);
            messages.push(SubscribeProgrammerRequest::generated_message_descriptor_data());
            messages.push(ProgrammerState::generated_message_descriptor_data());
            messages.push(FixtureSelection::generated_message_descriptor_data());
            messages.push(ProgrammerChannel::generated_message_descriptor_data());
            messages.push(EffectProgrammerState::generated_message_descriptor_data());
            messages.push(WriteEffectRateRequest::generated_message_descriptor_data());
            messages.push(WriteEffectRateResponse::generated_message_descriptor_data());
            messages.push(WriteEffectOffsetRequest::generated_message_descriptor_data());
            messages.push(WriteEffectOffsetResponse::generated_message_descriptor_data());
            messages.push(WriteControlRequest::generated_message_descriptor_data());
            messages.push(WriteControlResponse::generated_message_descriptor_data());
            messages.push(SelectFixturesRequest::generated_message_descriptor_data());
            messages.push(SelectFixturesResponse::generated_message_descriptor_data());
            messages.push(UnselectFixturesRequest::generated_message_descriptor_data());
            messages.push(UnselectFixturesResponse::generated_message_descriptor_data());
            messages.push(ClearRequest::generated_message_descriptor_data());
            messages.push(ClearResponse::generated_message_descriptor_data());
            messages.push(HighlightRequest::generated_message_descriptor_data());
            messages.push(HighlightResponse::generated_message_descriptor_data());
            messages.push(StoreRequest::generated_message_descriptor_data());
            messages.push(StoreResponse::generated_message_descriptor_data());
            messages.push(PresetsRequest::generated_message_descriptor_data());
            messages.push(PresetId::generated_message_descriptor_data());
            messages.push(Presets::generated_message_descriptor_data());
            messages.push(Preset::generated_message_descriptor_data());
            messages.push(CallPresetResponse::generated_message_descriptor_data());
            messages.push(GroupsRequest::generated_message_descriptor_data());
            messages.push(Groups::generated_message_descriptor_data());
            messages.push(Group::generated_message_descriptor_data());
            messages.push(SelectGroupRequest::generated_message_descriptor_data());
            messages.push(SelectGroupResponse::generated_message_descriptor_data());
            messages.push(AddGroupRequest::generated_message_descriptor_data());
            messages.push(AssignFixturesToGroupRequest::generated_message_descriptor_data());
            messages.push(AssignFixtureSelectionToGroupRequest::generated_message_descriptor_data());
            messages.push(AssignFixturesToGroupResponse::generated_message_descriptor_data());
            messages.push(fixture_selection::GroupedFixtureList::generated_message_descriptor_data());
            messages.push(programmer_channel::GenericValue::generated_message_descriptor_data());
            messages.push(write_control_request::GenericValue::generated_message_descriptor_data());
            messages.push(preset::Color::generated_message_descriptor_data());
            messages.push(preset::Position::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(programmer_channel::ColorChannel::generated_enum_descriptor_data());
            enums.push(store_request::Mode::generated_enum_descriptor_data());
            enums.push(preset_id::PresetType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
