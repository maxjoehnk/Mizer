// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `sequencer.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.GetSequencesRequest)
pub struct GetSequencesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.GetSequencesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSequencesRequest {
    fn default() -> &'a GetSequencesRequest {
        <GetSequencesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSequencesRequest {
    pub fn new() -> GetSequencesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSequencesRequest>(
            "GetSequencesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSequencesRequest {
    const NAME: &'static str = "GetSequencesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSequencesRequest {
        GetSequencesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSequencesRequest {
        static instance: GetSequencesRequest = GetSequencesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSequencesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSequencesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSequencesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSequencesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.GetSequenceRequest)
pub struct GetSequenceRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.GetSequenceRequest.sequence)
    pub sequence: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.GetSequenceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSequenceRequest {
    fn default() -> &'a GetSequenceRequest {
        <GetSequenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSequenceRequest {
    pub fn new() -> GetSequenceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &GetSequenceRequest| { &m.sequence },
            |m: &mut GetSequenceRequest| { &mut m.sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSequenceRequest>(
            "GetSequenceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSequenceRequest {
    const NAME: &'static str = "GetSequenceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSequenceRequest {
        GetSequenceRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSequenceRequest {
        static instance: GetSequenceRequest = GetSequenceRequest {
            sequence: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSequenceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSequenceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSequenceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSequenceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.AddSequenceRequest)
pub struct AddSequenceRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.AddSequenceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddSequenceRequest {
    fn default() -> &'a AddSequenceRequest {
        <AddSequenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddSequenceRequest {
    pub fn new() -> AddSequenceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddSequenceRequest>(
            "AddSequenceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddSequenceRequest {
    const NAME: &'static str = "AddSequenceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddSequenceRequest {
        AddSequenceRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddSequenceRequest {
        static instance: AddSequenceRequest = AddSequenceRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddSequenceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddSequenceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddSequenceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddSequenceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.DeleteSequenceRequest)
pub struct DeleteSequenceRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.DeleteSequenceRequest.sequence)
    pub sequence: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.DeleteSequenceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSequenceRequest {
    fn default() -> &'a DeleteSequenceRequest {
        <DeleteSequenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSequenceRequest {
    pub fn new() -> DeleteSequenceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &DeleteSequenceRequest| { &m.sequence },
            |m: &mut DeleteSequenceRequest| { &mut m.sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSequenceRequest>(
            "DeleteSequenceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSequenceRequest {
    const NAME: &'static str = "DeleteSequenceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSequenceRequest {
        DeleteSequenceRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSequenceRequest {
        static instance: DeleteSequenceRequest = DeleteSequenceRequest {
            sequence: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSequenceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSequenceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSequenceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSequenceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.SequenceGoRequest)
pub struct SequenceGoRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.SequenceGoRequest.sequence)
    pub sequence: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.SequenceGoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SequenceGoRequest {
    fn default() -> &'a SequenceGoRequest {
        <SequenceGoRequest as ::protobuf::Message>::default_instance()
    }
}

impl SequenceGoRequest {
    pub fn new() -> SequenceGoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &SequenceGoRequest| { &m.sequence },
            |m: &mut SequenceGoRequest| { &mut m.sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SequenceGoRequest>(
            "SequenceGoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SequenceGoRequest {
    const NAME: &'static str = "SequenceGoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SequenceGoRequest {
        SequenceGoRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SequenceGoRequest {
        static instance: SequenceGoRequest = SequenceGoRequest {
            sequence: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SequenceGoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SequenceGoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SequenceGoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceGoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.SequenceStopRequest)
pub struct SequenceStopRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.SequenceStopRequest.sequence)
    pub sequence: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.SequenceStopRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SequenceStopRequest {
    fn default() -> &'a SequenceStopRequest {
        <SequenceStopRequest as ::protobuf::Message>::default_instance()
    }
}

impl SequenceStopRequest {
    pub fn new() -> SequenceStopRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &SequenceStopRequest| { &m.sequence },
            |m: &mut SequenceStopRequest| { &mut m.sequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SequenceStopRequest>(
            "SequenceStopRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SequenceStopRequest {
    const NAME: &'static str = "SequenceStopRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SequenceStopRequest {
        SequenceStopRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SequenceStopRequest {
        static instance: SequenceStopRequest = SequenceStopRequest {
            sequence: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SequenceStopRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SequenceStopRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SequenceStopRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceStopRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueTriggerRequest)
pub struct CueTriggerRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueTriggerRequest.sequence)
    pub sequence: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueTriggerRequest.cue)
    pub cue: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueTriggerRequest.trigger)
    pub trigger: ::protobuf::EnumOrUnknown<cue_trigger::Type>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueTriggerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueTriggerRequest {
    fn default() -> &'a CueTriggerRequest {
        <CueTriggerRequest as ::protobuf::Message>::default_instance()
    }
}

impl CueTriggerRequest {
    pub fn new() -> CueTriggerRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &CueTriggerRequest| { &m.sequence },
            |m: &mut CueTriggerRequest| { &mut m.sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cue",
            |m: &CueTriggerRequest| { &m.cue },
            |m: &mut CueTriggerRequest| { &mut m.cue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trigger",
            |m: &CueTriggerRequest| { &m.trigger },
            |m: &mut CueTriggerRequest| { &mut m.trigger },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueTriggerRequest>(
            "CueTriggerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueTriggerRequest {
    const NAME: &'static str = "CueTriggerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                16 => {
                    self.cue = is.read_uint32()?;
                },
                24 => {
                    self.trigger = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        if self.cue != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.cue);
        }
        if self.trigger != ::protobuf::EnumOrUnknown::new(cue_trigger::Type::GO) {
            my_size += ::protobuf::rt::int32_size(3, self.trigger.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        if self.cue != 0 {
            os.write_uint32(2, self.cue)?;
        }
        if self.trigger != ::protobuf::EnumOrUnknown::new(cue_trigger::Type::GO) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.trigger))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueTriggerRequest {
        CueTriggerRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.cue = 0;
        self.trigger = ::protobuf::EnumOrUnknown::new(cue_trigger::Type::GO);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueTriggerRequest {
        static instance: CueTriggerRequest = CueTriggerRequest {
            sequence: 0,
            cue: 0,
            trigger: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueTriggerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueTriggerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueTriggerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueTriggerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueTriggerTimeRequest)
pub struct CueTriggerTimeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueTriggerTimeRequest.sequence)
    pub sequence: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueTriggerTimeRequest.cue)
    pub cue: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueTriggerTimeRequest.time)
    pub time: ::protobuf::MessageField<CueTime>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueTriggerTimeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueTriggerTimeRequest {
    fn default() -> &'a CueTriggerTimeRequest {
        <CueTriggerTimeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CueTriggerTimeRequest {
    pub fn new() -> CueTriggerTimeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &CueTriggerTimeRequest| { &m.sequence },
            |m: &mut CueTriggerTimeRequest| { &mut m.sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cue",
            |m: &CueTriggerTimeRequest| { &m.cue },
            |m: &mut CueTriggerTimeRequest| { &mut m.cue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTime>(
            "time",
            |m: &CueTriggerTimeRequest| { &m.time },
            |m: &mut CueTriggerTimeRequest| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueTriggerTimeRequest>(
            "CueTriggerTimeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueTriggerTimeRequest {
    const NAME: &'static str = "CueTriggerTimeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                16 => {
                    self.cue = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        if self.cue != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.cue);
        }
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        if self.cue != 0 {
            os.write_uint32(2, self.cue)?;
        }
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueTriggerTimeRequest {
        CueTriggerTimeRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.cue = 0;
        self.time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueTriggerTimeRequest {
        static instance: CueTriggerTimeRequest = CueTriggerTimeRequest {
            sequence: 0,
            cue: 0,
            time: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueTriggerTimeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueTriggerTimeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueTriggerTimeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueTriggerTimeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueNameRequest)
pub struct CueNameRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueNameRequest.sequence)
    pub sequence: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueNameRequest.cue)
    pub cue: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueNameRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueNameRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueNameRequest {
    fn default() -> &'a CueNameRequest {
        <CueNameRequest as ::protobuf::Message>::default_instance()
    }
}

impl CueNameRequest {
    pub fn new() -> CueNameRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &CueNameRequest| { &m.sequence },
            |m: &mut CueNameRequest| { &mut m.sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cue",
            |m: &CueNameRequest| { &m.cue },
            |m: &mut CueNameRequest| { &mut m.cue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CueNameRequest| { &m.name },
            |m: &mut CueNameRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueNameRequest>(
            "CueNameRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueNameRequest {
    const NAME: &'static str = "CueNameRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                16 => {
                    self.cue = is.read_uint32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        if self.cue != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.cue);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        if self.cue != 0 {
            os.write_uint32(2, self.cue)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueNameRequest {
        CueNameRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.cue = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueNameRequest {
        static instance: CueNameRequest = CueNameRequest {
            sequence: 0,
            cue: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueNameRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueNameRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueNameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueNameRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueValueRequest)
pub struct CueValueRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueValueRequest.sequence_id)
    pub sequence_id: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueValueRequest.cue_id)
    pub cue_id: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueValueRequest.control_index)
    pub control_index: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueValueRequest.value)
    pub value: ::protobuf::MessageField<CueValue>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueValueRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueValueRequest {
    fn default() -> &'a CueValueRequest {
        <CueValueRequest as ::protobuf::Message>::default_instance()
    }
}

impl CueValueRequest {
    pub fn new() -> CueValueRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence_id",
            |m: &CueValueRequest| { &m.sequence_id },
            |m: &mut CueValueRequest| { &mut m.sequence_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cue_id",
            |m: &CueValueRequest| { &m.cue_id },
            |m: &mut CueValueRequest| { &mut m.cue_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "control_index",
            |m: &CueValueRequest| { &m.control_index },
            |m: &mut CueValueRequest| { &mut m.control_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueValue>(
            "value",
            |m: &CueValueRequest| { &m.value },
            |m: &mut CueValueRequest| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueValueRequest>(
            "CueValueRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueValueRequest {
    const NAME: &'static str = "CueValueRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence_id = is.read_uint32()?;
                },
                16 => {
                    self.cue_id = is.read_uint32()?;
                },
                24 => {
                    self.control_index = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence_id);
        }
        if self.cue_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.cue_id);
        }
        if self.control_index != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.control_index);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence_id != 0 {
            os.write_uint32(1, self.sequence_id)?;
        }
        if self.cue_id != 0 {
            os.write_uint32(2, self.cue_id)?;
        }
        if self.control_index != 0 {
            os.write_uint32(3, self.control_index)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueValueRequest {
        CueValueRequest::new()
    }

    fn clear(&mut self) {
        self.sequence_id = 0;
        self.cue_id = 0;
        self.control_index = 0;
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueValueRequest {
        static instance: CueValueRequest = CueValueRequest {
            sequence_id: 0,
            cue_id: 0,
            control_index: 0,
            value: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueValueRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueValueRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueValueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueValueRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueTimingRequest)
pub struct CueTimingRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueTimingRequest.sequence_id)
    pub sequence_id: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueTimingRequest.cue_id)
    pub cue_id: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.CueTimingRequest.time)
    pub time: ::protobuf::MessageField<CueTimer>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueTimingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueTimingRequest {
    fn default() -> &'a CueTimingRequest {
        <CueTimingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CueTimingRequest {
    pub fn new() -> CueTimingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence_id",
            |m: &CueTimingRequest| { &m.sequence_id },
            |m: &mut CueTimingRequest| { &mut m.sequence_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cue_id",
            |m: &CueTimingRequest| { &m.cue_id },
            |m: &mut CueTimingRequest| { &mut m.cue_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTimer>(
            "time",
            |m: &CueTimingRequest| { &m.time },
            |m: &mut CueTimingRequest| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueTimingRequest>(
            "CueTimingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueTimingRequest {
    const NAME: &'static str = "CueTimingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence_id = is.read_uint32()?;
                },
                16 => {
                    self.cue_id = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence_id);
        }
        if self.cue_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.cue_id);
        }
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence_id != 0 {
            os.write_uint32(1, self.sequence_id)?;
        }
        if self.cue_id != 0 {
            os.write_uint32(2, self.cue_id)?;
        }
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueTimingRequest {
        CueTimingRequest::new()
    }

    fn clear(&mut self) {
        self.sequence_id = 0;
        self.cue_id = 0;
        self.time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueTimingRequest {
        static instance: CueTimingRequest = CueTimingRequest {
            sequence_id: 0,
            cue_id: 0,
            time: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueTimingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueTimingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueTimingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueTimingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.SequenceWrapAroundRequest)
pub struct SequenceWrapAroundRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.SequenceWrapAroundRequest.sequence)
    pub sequence: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.SequenceWrapAroundRequest.wrapAround)
    pub wrapAround: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.SequenceWrapAroundRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SequenceWrapAroundRequest {
    fn default() -> &'a SequenceWrapAroundRequest {
        <SequenceWrapAroundRequest as ::protobuf::Message>::default_instance()
    }
}

impl SequenceWrapAroundRequest {
    pub fn new() -> SequenceWrapAroundRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &SequenceWrapAroundRequest| { &m.sequence },
            |m: &mut SequenceWrapAroundRequest| { &mut m.sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wrapAround",
            |m: &SequenceWrapAroundRequest| { &m.wrapAround },
            |m: &mut SequenceWrapAroundRequest| { &mut m.wrapAround },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SequenceWrapAroundRequest>(
            "SequenceWrapAroundRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SequenceWrapAroundRequest {
    const NAME: &'static str = "SequenceWrapAroundRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                16 => {
                    self.wrapAround = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        if self.wrapAround != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        if self.wrapAround != false {
            os.write_bool(2, self.wrapAround)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SequenceWrapAroundRequest {
        SequenceWrapAroundRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.wrapAround = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SequenceWrapAroundRequest {
        static instance: SequenceWrapAroundRequest = SequenceWrapAroundRequest {
            sequence: 0,
            wrapAround: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SequenceWrapAroundRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SequenceWrapAroundRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SequenceWrapAroundRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceWrapAroundRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.SequenceStopOnLastCueRequest)
pub struct SequenceStopOnLastCueRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.SequenceStopOnLastCueRequest.sequence)
    pub sequence: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.SequenceStopOnLastCueRequest.stopOnLastCue)
    pub stopOnLastCue: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.SequenceStopOnLastCueRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SequenceStopOnLastCueRequest {
    fn default() -> &'a SequenceStopOnLastCueRequest {
        <SequenceStopOnLastCueRequest as ::protobuf::Message>::default_instance()
    }
}

impl SequenceStopOnLastCueRequest {
    pub fn new() -> SequenceStopOnLastCueRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &SequenceStopOnLastCueRequest| { &m.sequence },
            |m: &mut SequenceStopOnLastCueRequest| { &mut m.sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stopOnLastCue",
            |m: &SequenceStopOnLastCueRequest| { &m.stopOnLastCue },
            |m: &mut SequenceStopOnLastCueRequest| { &mut m.stopOnLastCue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SequenceStopOnLastCueRequest>(
            "SequenceStopOnLastCueRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SequenceStopOnLastCueRequest {
    const NAME: &'static str = "SequenceStopOnLastCueRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                16 => {
                    self.stopOnLastCue = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        if self.stopOnLastCue != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        if self.stopOnLastCue != false {
            os.write_bool(2, self.stopOnLastCue)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SequenceStopOnLastCueRequest {
        SequenceStopOnLastCueRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.stopOnLastCue = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SequenceStopOnLastCueRequest {
        static instance: SequenceStopOnLastCueRequest = SequenceStopOnLastCueRequest {
            sequence: 0,
            stopOnLastCue: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SequenceStopOnLastCueRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SequenceStopOnLastCueRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SequenceStopOnLastCueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceStopOnLastCueRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.SequenceNameRequest)
pub struct SequenceNameRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.SequenceNameRequest.sequence)
    pub sequence: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.SequenceNameRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.SequenceNameRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SequenceNameRequest {
    fn default() -> &'a SequenceNameRequest {
        <SequenceNameRequest as ::protobuf::Message>::default_instance()
    }
}

impl SequenceNameRequest {
    pub fn new() -> SequenceNameRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence",
            |m: &SequenceNameRequest| { &m.sequence },
            |m: &mut SequenceNameRequest| { &mut m.sequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &SequenceNameRequest| { &m.name },
            |m: &mut SequenceNameRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SequenceNameRequest>(
            "SequenceNameRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SequenceNameRequest {
    const NAME: &'static str = "SequenceNameRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sequence != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.sequence);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sequence != 0 {
            os.write_uint32(1, self.sequence)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SequenceNameRequest {
        SequenceNameRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SequenceNameRequest {
        static instance: SequenceNameRequest = SequenceNameRequest {
            sequence: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SequenceNameRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SequenceNameRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SequenceNameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceNameRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.EmptyResponse)
pub struct EmptyResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.EmptyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmptyResponse {
    fn default() -> &'a EmptyResponse {
        <EmptyResponse as ::protobuf::Message>::default_instance()
    }
}

impl EmptyResponse {
    pub fn new() -> EmptyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmptyResponse>(
            "EmptyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmptyResponse {
    const NAME: &'static str = "EmptyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmptyResponse {
        EmptyResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmptyResponse {
        static instance: EmptyResponse = EmptyResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmptyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmptyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmptyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.Sequences)
pub struct Sequences {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.Sequences.sequences)
    pub sequences: ::std::vec::Vec<Sequence>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.Sequences.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sequences {
    fn default() -> &'a Sequences {
        <Sequences as ::protobuf::Message>::default_instance()
    }
}

impl Sequences {
    pub fn new() -> Sequences {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sequences",
            |m: &Sequences| { &m.sequences },
            |m: &mut Sequences| { &mut m.sequences },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sequences>(
            "Sequences",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sequences {
    const NAME: &'static str = "Sequences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sequences.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sequences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sequences {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sequences {
        Sequences::new()
    }

    fn clear(&mut self) {
        self.sequences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sequences {
        static instance: Sequences = Sequences {
            sequences: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sequences {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sequences").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sequences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sequences {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.Sequence)
pub struct Sequence {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.Sequence.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.Sequence.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.sequencer.Sequence.cues)
    pub cues: ::std::vec::Vec<Cue>,
    // @@protoc_insertion_point(field:mizer.sequencer.Sequence.fixtures)
    pub fixtures: ::std::vec::Vec<super::fixtures::FixtureId>,
    // @@protoc_insertion_point(field:mizer.sequencer.Sequence.wrapAround)
    pub wrapAround: bool,
    // @@protoc_insertion_point(field:mizer.sequencer.Sequence.stopOnLastCue)
    pub stopOnLastCue: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.Sequence.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sequence {
    fn default() -> &'a Sequence {
        <Sequence as ::protobuf::Message>::default_instance()
    }
}

impl Sequence {
    pub fn new() -> Sequence {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Sequence| { &m.id },
            |m: &mut Sequence| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Sequence| { &m.name },
            |m: &mut Sequence| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cues",
            |m: &Sequence| { &m.cues },
            |m: &mut Sequence| { &mut m.cues },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixtures",
            |m: &Sequence| { &m.fixtures },
            |m: &mut Sequence| { &mut m.fixtures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wrapAround",
            |m: &Sequence| { &m.wrapAround },
            |m: &mut Sequence| { &mut m.wrapAround },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stopOnLastCue",
            |m: &Sequence| { &m.stopOnLastCue },
            |m: &mut Sequence| { &mut m.stopOnLastCue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sequence>(
            "Sequence",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sequence {
    const NAME: &'static str = "Sequence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.cues.push(is.read_message()?);
                },
                34 => {
                    self.fixtures.push(is.read_message()?);
                },
                40 => {
                    self.wrapAround = is.read_bool()?;
                },
                48 => {
                    self.stopOnLastCue = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.cues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.wrapAround != false {
            my_size += 1 + 1;
        }
        if self.stopOnLastCue != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.cues {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.wrapAround != false {
            os.write_bool(5, self.wrapAround)?;
        }
        if self.stopOnLastCue != false {
            os.write_bool(6, self.stopOnLastCue)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sequence {
        Sequence::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.cues.clear();
        self.fixtures.clear();
        self.wrapAround = false;
        self.stopOnLastCue = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sequence {
        static instance: Sequence = Sequence {
            id: 0,
            name: ::std::string::String::new(),
            cues: ::std::vec::Vec::new(),
            fixtures: ::std::vec::Vec::new(),
            wrapAround: false,
            stopOnLastCue: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sequence {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sequence").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sequence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sequence {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.Cue)
pub struct Cue {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.Cue.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.sequencer.Cue.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.sequencer.Cue.trigger)
    pub trigger: ::protobuf::MessageField<CueTrigger>,
    // @@protoc_insertion_point(field:mizer.sequencer.Cue.controls)
    pub controls: ::std::vec::Vec<CueControl>,
    // @@protoc_insertion_point(field:mizer.sequencer.Cue.cue_timings)
    pub cue_timings: ::protobuf::MessageField<CueTimings>,
    // @@protoc_insertion_point(field:mizer.sequencer.Cue.dimmer_timings)
    pub dimmer_timings: ::protobuf::MessageField<CueTimings>,
    // @@protoc_insertion_point(field:mizer.sequencer.Cue.position_timings)
    pub position_timings: ::protobuf::MessageField<CueTimings>,
    // @@protoc_insertion_point(field:mizer.sequencer.Cue.color_timings)
    pub color_timings: ::protobuf::MessageField<CueTimings>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.Cue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Cue {
    fn default() -> &'a Cue {
        <Cue as ::protobuf::Message>::default_instance()
    }
}

impl Cue {
    pub fn new() -> Cue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Cue| { &m.id },
            |m: &mut Cue| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Cue| { &m.name },
            |m: &mut Cue| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTrigger>(
            "trigger",
            |m: &Cue| { &m.trigger },
            |m: &mut Cue| { &mut m.trigger },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "controls",
            |m: &Cue| { &m.controls },
            |m: &mut Cue| { &mut m.controls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTimings>(
            "cue_timings",
            |m: &Cue| { &m.cue_timings },
            |m: &mut Cue| { &mut m.cue_timings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTimings>(
            "dimmer_timings",
            |m: &Cue| { &m.dimmer_timings },
            |m: &mut Cue| { &mut m.dimmer_timings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTimings>(
            "position_timings",
            |m: &Cue| { &m.position_timings },
            |m: &mut Cue| { &mut m.position_timings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTimings>(
            "color_timings",
            |m: &Cue| { &m.color_timings },
            |m: &mut Cue| { &mut m.color_timings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cue>(
            "Cue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Cue {
    const NAME: &'static str = "Cue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trigger)?;
                },
                34 => {
                    self.controls.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cue_timings)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dimmer_timings)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position_timings)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color_timings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(v) = self.trigger.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.controls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cue_timings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dimmer_timings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.position_timings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.color_timings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(v) = self.trigger.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.controls {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.cue_timings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.dimmer_timings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.position_timings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.color_timings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Cue {
        Cue::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.trigger.clear();
        self.controls.clear();
        self.cue_timings.clear();
        self.dimmer_timings.clear();
        self.position_timings.clear();
        self.color_timings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Cue {
        static instance: Cue = Cue {
            id: 0,
            name: ::std::string::String::new(),
            trigger: ::protobuf::MessageField::none(),
            controls: ::std::vec::Vec::new(),
            cue_timings: ::protobuf::MessageField::none(),
            dimmer_timings: ::protobuf::MessageField::none(),
            position_timings: ::protobuf::MessageField::none(),
            color_timings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Cue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Cue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Cue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueTimings)
pub struct CueTimings {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueTimings.fade)
    pub fade: ::protobuf::MessageField<CueTimer>,
    // @@protoc_insertion_point(field:mizer.sequencer.CueTimings.delay)
    pub delay: ::protobuf::MessageField<CueTimer>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueTimings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueTimings {
    fn default() -> &'a CueTimings {
        <CueTimings as ::protobuf::Message>::default_instance()
    }
}

impl CueTimings {
    pub fn new() -> CueTimings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTimer>(
            "fade",
            |m: &CueTimings| { &m.fade },
            |m: &mut CueTimings| { &mut m.fade },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTimer>(
            "delay",
            |m: &CueTimings| { &m.delay },
            |m: &mut CueTimings| { &mut m.delay },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueTimings>(
            "CueTimings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueTimings {
    const NAME: &'static str = "CueTimings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fade)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.delay)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fade.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.delay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fade.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.delay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueTimings {
        CueTimings::new()
    }

    fn clear(&mut self) {
        self.fade.clear();
        self.delay.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueTimings {
        static instance: CueTimings = CueTimings {
            fade: ::protobuf::MessageField::none(),
            delay: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueTimings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueTimings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueTimings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueTimings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueTrigger)
pub struct CueTrigger {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueTrigger.type)
    pub type_: ::protobuf::EnumOrUnknown<cue_trigger::Type>,
    // @@protoc_insertion_point(field:mizer.sequencer.CueTrigger.time)
    pub time: ::protobuf::MessageField<CueTime>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueTrigger.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueTrigger {
    fn default() -> &'a CueTrigger {
        <CueTrigger as ::protobuf::Message>::default_instance()
    }
}

impl CueTrigger {
    pub fn new() -> CueTrigger {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &CueTrigger| { &m.type_ },
            |m: &mut CueTrigger| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTime>(
            "time",
            |m: &CueTrigger| { &m.time },
            |m: &mut CueTrigger| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueTrigger>(
            "CueTrigger",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueTrigger {
    const NAME: &'static str = "CueTrigger";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(cue_trigger::Type::GO) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(cue_trigger::Type::GO) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueTrigger {
        CueTrigger::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(cue_trigger::Type::GO);
        self.time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueTrigger {
        static instance: CueTrigger = CueTrigger {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            time: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueTrigger {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueTrigger").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueTrigger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueTrigger {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CueTrigger`
pub mod cue_trigger {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.sequencer.CueTrigger.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueTrigger.Type.GO)
        GO = 0,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueTrigger.Type.FOLLOW)
        FOLLOW = 1,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueTrigger.Type.TIME)
        TIME = 2,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueTrigger.Type.BEATS)
        BEATS = 3,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueTrigger.Type.TIMECODE)
        TIMECODE = 4,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::GO),
                1 => ::std::option::Option::Some(Type::FOLLOW),
                2 => ::std::option::Option::Some(Type::TIME),
                3 => ::std::option::Option::Some(Type::BEATS),
                4 => ::std::option::Option::Some(Type::TIMECODE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::GO,
            Type::FOLLOW,
            Type::TIME,
            Type::BEATS,
            Type::TIMECODE,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CueTrigger.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::GO
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("CueTrigger.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueControl)
pub struct CueControl {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueControl.type)
    pub type_: ::protobuf::EnumOrUnknown<cue_control::Type>,
    // @@protoc_insertion_point(field:mizer.sequencer.CueControl.value)
    pub value: ::protobuf::MessageField<CueValue>,
    // @@protoc_insertion_point(field:mizer.sequencer.CueControl.fixtures)
    pub fixtures: ::std::vec::Vec<super::fixtures::FixtureId>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueControl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueControl {
    fn default() -> &'a CueControl {
        <CueControl as ::protobuf::Message>::default_instance()
    }
}

impl CueControl {
    pub fn new() -> CueControl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &CueControl| { &m.type_ },
            |m: &mut CueControl| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueValue>(
            "value",
            |m: &CueControl| { &m.value },
            |m: &mut CueControl| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fixtures",
            |m: &CueControl| { &m.fixtures },
            |m: &mut CueControl| { &mut m.fixtures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueControl>(
            "CueControl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueControl {
    const NAME: &'static str = "CueControl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                26 => {
                    self.fixtures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(cue_control::Type::INTENSITY) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.fixtures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(cue_control::Type::INTENSITY) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.fixtures {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueControl {
        CueControl::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(cue_control::Type::INTENSITY);
        self.value.clear();
        self.fixtures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueControl {
        static instance: CueControl = CueControl {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            value: ::protobuf::MessageField::none(),
            fixtures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueControl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueControl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueControl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CueControl`
pub mod cue_control {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.sequencer.CueControl.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.INTENSITY)
        INTENSITY = 0,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.SHUTTER)
        SHUTTER = 1,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.COLOR_RED)
        COLOR_RED = 2,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.COLOR_GREEN)
        COLOR_GREEN = 3,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.COLOR_BLUE)
        COLOR_BLUE = 4,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.COLOR_WHEEL)
        COLOR_WHEEL = 5,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.PAN)
        PAN = 6,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.TILT)
        TILT = 7,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.FOCUS)
        FOCUS = 8,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.ZOOM)
        ZOOM = 9,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.PRISM)
        PRISM = 10,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.IRIS)
        IRIS = 11,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.FROST)
        FROST = 12,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.GOBO)
        GOBO = 13,
        // @@protoc_insertion_point(enum_value:mizer.sequencer.CueControl.Type.GENERIC)
        GENERIC = 14,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::INTENSITY),
                1 => ::std::option::Option::Some(Type::SHUTTER),
                2 => ::std::option::Option::Some(Type::COLOR_RED),
                3 => ::std::option::Option::Some(Type::COLOR_GREEN),
                4 => ::std::option::Option::Some(Type::COLOR_BLUE),
                5 => ::std::option::Option::Some(Type::COLOR_WHEEL),
                6 => ::std::option::Option::Some(Type::PAN),
                7 => ::std::option::Option::Some(Type::TILT),
                8 => ::std::option::Option::Some(Type::FOCUS),
                9 => ::std::option::Option::Some(Type::ZOOM),
                10 => ::std::option::Option::Some(Type::PRISM),
                11 => ::std::option::Option::Some(Type::IRIS),
                12 => ::std::option::Option::Some(Type::FROST),
                13 => ::std::option::Option::Some(Type::GOBO),
                14 => ::std::option::Option::Some(Type::GENERIC),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::INTENSITY,
            Type::SHUTTER,
            Type::COLOR_RED,
            Type::COLOR_GREEN,
            Type::COLOR_BLUE,
            Type::COLOR_WHEEL,
            Type::PAN,
            Type::TILT,
            Type::FOCUS,
            Type::ZOOM,
            Type::PRISM,
            Type::IRIS,
            Type::FROST,
            Type::GOBO,
            Type::GENERIC,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CueControl.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::INTENSITY
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("CueControl.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueValue)
pub struct CueValue {
    // message oneof groups
    pub value: ::std::option::Option<cue_value::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueValue {
    fn default() -> &'a CueValue {
        <CueValue as ::protobuf::Message>::default_instance()
    }
}

impl CueValue {
    pub fn new() -> CueValue {
        ::std::default::Default::default()
    }

    // double direct = 3;

    pub fn direct(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(cue_value::Value::Direct(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_direct(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_direct(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cue_value::Value::Direct(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(cue_value::Value::Direct(v))
    }

    // .mizer.sequencer.CueValueRange range = 4;

    pub fn range(&self) -> &CueValueRange {
        match self.value {
            ::std::option::Option::Some(cue_value::Value::Range(ref v)) => v,
            _ => <CueValueRange as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_range(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(cue_value::Value::Range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: CueValueRange) {
        self.value = ::std::option::Option::Some(cue_value::Value::Range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_range(&mut self) -> &mut CueValueRange {
        if let ::std::option::Option::Some(cue_value::Value::Range(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(cue_value::Value::Range(CueValueRange::new()));
        }
        match self.value {
            ::std::option::Option::Some(cue_value::Value::Range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range(&mut self) -> CueValueRange {
        if self.has_range() {
            match self.value.take() {
                ::std::option::Option::Some(cue_value::Value::Range(v)) => v,
                _ => panic!(),
            }
        } else {
            CueValueRange::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "direct",
            CueValue::has_direct,
            CueValue::direct,
            CueValue::set_direct,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CueValueRange>(
            "range",
            CueValue::has_range,
            CueValue::range,
            CueValue::mut_range,
            CueValue::set_range,
        ));
        oneofs.push(cue_value::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueValue>(
            "CueValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueValue {
    const NAME: &'static str = "CueValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                25 => {
                    self.value = ::std::option::Option::Some(cue_value::Value::Direct(is.read_double()?));
                },
                34 => {
                    self.value = ::std::option::Option::Some(cue_value::Value::Range(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &cue_value::Value::Direct(v) => {
                    my_size += 1 + 8;
                },
                &cue_value::Value::Range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &cue_value::Value::Direct(v) => {
                    os.write_double(3, v)?;
                },
                &cue_value::Value::Range(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueValue {
        CueValue::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueValue {
        static instance: CueValue = CueValue {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CueValue`
pub mod cue_value {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.sequencer.CueValue.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:mizer.sequencer.CueValue.direct)
        Direct(f64),
        // @@protoc_insertion_point(oneof_field:mizer.sequencer.CueValue.range)
        Range(super::CueValueRange),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CueValue as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueTimer)
pub struct CueTimer {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueTimer.hasTimer)
    pub hasTimer: bool,
    // message oneof groups
    pub timer: ::std::option::Option<cue_timer::Timer>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueTimer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueTimer {
    fn default() -> &'a CueTimer {
        <CueTimer as ::protobuf::Message>::default_instance()
    }
}

impl CueTimer {
    pub fn new() -> CueTimer {
        ::std::default::Default::default()
    }

    // .mizer.sequencer.CueTime direct = 2;

    pub fn direct(&self) -> &CueTime {
        match self.timer {
            ::std::option::Option::Some(cue_timer::Timer::Direct(ref v)) => v,
            _ => <CueTime as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_direct(&mut self) {
        self.timer = ::std::option::Option::None;
    }

    pub fn has_direct(&self) -> bool {
        match self.timer {
            ::std::option::Option::Some(cue_timer::Timer::Direct(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct(&mut self, v: CueTime) {
        self.timer = ::std::option::Option::Some(cue_timer::Timer::Direct(v))
    }

    // Mutable pointer to the field.
    pub fn mut_direct(&mut self) -> &mut CueTime {
        if let ::std::option::Option::Some(cue_timer::Timer::Direct(_)) = self.timer {
        } else {
            self.timer = ::std::option::Option::Some(cue_timer::Timer::Direct(CueTime::new()));
        }
        match self.timer {
            ::std::option::Option::Some(cue_timer::Timer::Direct(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_direct(&mut self) -> CueTime {
        if self.has_direct() {
            match self.timer.take() {
                ::std::option::Option::Some(cue_timer::Timer::Direct(v)) => v,
                _ => panic!(),
            }
        } else {
            CueTime::new()
        }
    }

    // .mizer.sequencer.CueTimerRange range = 3;

    pub fn range(&self) -> &CueTimerRange {
        match self.timer {
            ::std::option::Option::Some(cue_timer::Timer::Range(ref v)) => v,
            _ => <CueTimerRange as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_range(&mut self) {
        self.timer = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        match self.timer {
            ::std::option::Option::Some(cue_timer::Timer::Range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: CueTimerRange) {
        self.timer = ::std::option::Option::Some(cue_timer::Timer::Range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_range(&mut self) -> &mut CueTimerRange {
        if let ::std::option::Option::Some(cue_timer::Timer::Range(_)) = self.timer {
        } else {
            self.timer = ::std::option::Option::Some(cue_timer::Timer::Range(CueTimerRange::new()));
        }
        match self.timer {
            ::std::option::Option::Some(cue_timer::Timer::Range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range(&mut self) -> CueTimerRange {
        if self.has_range() {
            match self.timer.take() {
                ::std::option::Option::Some(cue_timer::Timer::Range(v)) => v,
                _ => panic!(),
            }
        } else {
            CueTimerRange::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hasTimer",
            |m: &CueTimer| { &m.hasTimer },
            |m: &mut CueTimer| { &mut m.hasTimer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CueTime>(
            "direct",
            CueTimer::has_direct,
            CueTimer::direct,
            CueTimer::mut_direct,
            CueTimer::set_direct,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CueTimerRange>(
            "range",
            CueTimer::has_range,
            CueTimer::range,
            CueTimer::mut_range,
            CueTimer::set_range,
        ));
        oneofs.push(cue_timer::Timer::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueTimer>(
            "CueTimer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueTimer {
    const NAME: &'static str = "CueTimer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hasTimer = is.read_bool()?;
                },
                18 => {
                    self.timer = ::std::option::Option::Some(cue_timer::Timer::Direct(is.read_message()?));
                },
                26 => {
                    self.timer = ::std::option::Option::Some(cue_timer::Timer::Range(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.hasTimer != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.timer {
            match v {
                &cue_timer::Timer::Direct(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cue_timer::Timer::Range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.hasTimer != false {
            os.write_bool(1, self.hasTimer)?;
        }
        if let ::std::option::Option::Some(ref v) = self.timer {
            match v {
                &cue_timer::Timer::Direct(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &cue_timer::Timer::Range(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueTimer {
        CueTimer::new()
    }

    fn clear(&mut self) {
        self.hasTimer = false;
        self.timer = ::std::option::Option::None;
        self.timer = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueTimer {
        static instance: CueTimer = CueTimer {
            hasTimer: false,
            timer: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueTimer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueTimer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueTimer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueTimer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CueTimer`
pub mod cue_timer {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.sequencer.CueTimer.timer)
    pub enum Timer {
        // @@protoc_insertion_point(oneof_field:mizer.sequencer.CueTimer.direct)
        Direct(super::CueTime),
        // @@protoc_insertion_point(oneof_field:mizer.sequencer.CueTimer.range)
        Range(super::CueTimerRange),
    }

    impl ::protobuf::Oneof for Timer {
    }

    impl ::protobuf::OneofFull for Timer {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CueTimer as ::protobuf::MessageFull>::descriptor().oneof_by_name("timer").unwrap()).clone()
        }
    }

    impl Timer {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Timer>("timer")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueValueRange)
pub struct CueValueRange {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueValueRange.from)
    pub from: f64,
    // @@protoc_insertion_point(field:mizer.sequencer.CueValueRange.to)
    pub to: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueValueRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueValueRange {
    fn default() -> &'a CueValueRange {
        <CueValueRange as ::protobuf::Message>::default_instance()
    }
}

impl CueValueRange {
    pub fn new() -> CueValueRange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from",
            |m: &CueValueRange| { &m.from },
            |m: &mut CueValueRange| { &mut m.from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to",
            |m: &CueValueRange| { &m.to },
            |m: &mut CueValueRange| { &mut m.to },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueValueRange>(
            "CueValueRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueValueRange {
    const NAME: &'static str = "CueValueRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.from = is.read_double()?;
                },
                17 => {
                    self.to = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.from != 0. {
            my_size += 1 + 8;
        }
        if self.to != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.from != 0. {
            os.write_double(1, self.from)?;
        }
        if self.to != 0. {
            os.write_double(2, self.to)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueValueRange {
        CueValueRange::new()
    }

    fn clear(&mut self) {
        self.from = 0.;
        self.to = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueValueRange {
        static instance: CueValueRange = CueValueRange {
            from: 0.,
            to: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueValueRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueValueRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueValueRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueValueRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueTime)
pub struct CueTime {
    // message oneof groups
    pub time: ::std::option::Option<cue_time::Time>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueTime.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueTime {
    fn default() -> &'a CueTime {
        <CueTime as ::protobuf::Message>::default_instance()
    }
}

impl CueTime {
    pub fn new() -> CueTime {
        ::std::default::Default::default()
    }

    // double seconds = 1;

    pub fn seconds(&self) -> f64 {
        match self.time {
            ::std::option::Option::Some(cue_time::Time::Seconds(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_seconds(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        match self.time {
            ::std::option::Option::Some(cue_time::Time::Seconds(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: f64) {
        self.time = ::std::option::Option::Some(cue_time::Time::Seconds(v))
    }

    // double beats = 2;

    pub fn beats(&self) -> f64 {
        match self.time {
            ::std::option::Option::Some(cue_time::Time::Beats(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_beats(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_beats(&self) -> bool {
        match self.time {
            ::std::option::Option::Some(cue_time::Time::Beats(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_beats(&mut self, v: f64) {
        self.time = ::std::option::Option::Some(cue_time::Time::Beats(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "seconds",
            CueTime::has_seconds,
            CueTime::seconds,
            CueTime::set_seconds,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "beats",
            CueTime::has_beats,
            CueTime::beats,
            CueTime::set_beats,
        ));
        oneofs.push(cue_time::Time::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueTime>(
            "CueTime",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueTime {
    const NAME: &'static str = "CueTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.time = ::std::option::Option::Some(cue_time::Time::Seconds(is.read_double()?));
                },
                17 => {
                    self.time = ::std::option::Option::Some(cue_time::Time::Beats(is.read_double()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.time {
            match v {
                &cue_time::Time::Seconds(v) => {
                    my_size += 1 + 8;
                },
                &cue_time::Time::Beats(v) => {
                    my_size += 1 + 8;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.time {
            match v {
                &cue_time::Time::Seconds(v) => {
                    os.write_double(1, v)?;
                },
                &cue_time::Time::Beats(v) => {
                    os.write_double(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueTime {
        CueTime::new()
    }

    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueTime {
        static instance: CueTime = CueTime {
            time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueTime {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueTime").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueTime {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CueTime`
pub mod cue_time {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.sequencer.CueTime.time)
    pub enum Time {
        // @@protoc_insertion_point(oneof_field:mizer.sequencer.CueTime.seconds)
        Seconds(f64),
        // @@protoc_insertion_point(oneof_field:mizer.sequencer.CueTime.beats)
        Beats(f64),
    }

    impl ::protobuf::Oneof for Time {
    }

    impl ::protobuf::OneofFull for Time {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CueTime as ::protobuf::MessageFull>::descriptor().oneof_by_name("time").unwrap()).clone()
        }
    }

    impl Time {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Time>("time")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.sequencer.CueTimerRange)
pub struct CueTimerRange {
    // message fields
    // @@protoc_insertion_point(field:mizer.sequencer.CueTimerRange.from)
    pub from: ::protobuf::MessageField<CueTime>,
    // @@protoc_insertion_point(field:mizer.sequencer.CueTimerRange.to)
    pub to: ::protobuf::MessageField<CueTime>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.sequencer.CueTimerRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CueTimerRange {
    fn default() -> &'a CueTimerRange {
        <CueTimerRange as ::protobuf::Message>::default_instance()
    }
}

impl CueTimerRange {
    pub fn new() -> CueTimerRange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTime>(
            "from",
            |m: &CueTimerRange| { &m.from },
            |m: &mut CueTimerRange| { &mut m.from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CueTime>(
            "to",
            |m: &CueTimerRange| { &m.to },
            |m: &mut CueTimerRange| { &mut m.to },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CueTimerRange>(
            "CueTimerRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CueTimerRange {
    const NAME: &'static str = "CueTimerRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.from)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.to)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.from.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.to.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.from.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.to.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CueTimerRange {
        CueTimerRange::new()
    }

    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CueTimerRange {
        static instance: CueTimerRange = CueTimerRange {
            from: ::protobuf::MessageField::none(),
            to: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CueTimerRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CueTimerRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CueTimerRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CueTimerRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fsequencer.proto\x12\x0fmizer.sequencer\x1a\x0efixtures.proto\"\x15\
    \n\x13GetSequencesRequest\"0\n\x12GetSequenceRequest\x12\x1a\n\x08sequen\
    ce\x18\x01\x20\x01(\rR\x08sequence\"\x14\n\x12AddSequenceRequest\"3\n\
    \x15DeleteSequenceRequest\x12\x1a\n\x08sequence\x18\x01\x20\x01(\rR\x08s\
    equence\"/\n\x11SequenceGoRequest\x12\x1a\n\x08sequence\x18\x01\x20\x01(\
    \rR\x08sequence\"1\n\x13SequenceStopRequest\x12\x1a\n\x08sequence\x18\
    \x01\x20\x01(\rR\x08sequence\"}\n\x11CueTriggerRequest\x12\x1a\n\x08sequ\
    ence\x18\x01\x20\x01(\rR\x08sequence\x12\x10\n\x03cue\x18\x02\x20\x01(\r\
    R\x03cue\x12:\n\x07trigger\x18\x03\x20\x01(\x0e2\x20.mizer.sequencer.Cue\
    Trigger.TypeR\x07trigger\"s\n\x15CueTriggerTimeRequest\x12\x1a\n\x08sequ\
    ence\x18\x01\x20\x01(\rR\x08sequence\x12\x10\n\x03cue\x18\x02\x20\x01(\r\
    R\x03cue\x12,\n\x04time\x18\x03\x20\x01(\x0b2\x18.mizer.sequencer.CueTim\
    eR\x04time\"R\n\x0eCueNameRequest\x12\x1a\n\x08sequence\x18\x01\x20\x01(\
    \rR\x08sequence\x12\x10\n\x03cue\x18\x02\x20\x01(\rR\x03cue\x12\x12\n\
    \x04name\x18\x03\x20\x01(\tR\x04name\"\x9f\x01\n\x0fCueValueRequest\x12\
    \x1f\n\x0bsequence_id\x18\x01\x20\x01(\rR\nsequenceId\x12\x15\n\x06cue_i\
    d\x18\x02\x20\x01(\rR\x05cueId\x12#\n\rcontrol_index\x18\x03\x20\x01(\rR\
    \x0ccontrolIndex\x12/\n\x05value\x18\x04\x20\x01(\x0b2\x19.mizer.sequenc\
    er.CueValueR\x05value\"y\n\x10CueTimingRequest\x12\x1f\n\x0bsequence_id\
    \x18\x01\x20\x01(\rR\nsequenceId\x12\x15\n\x06cue_id\x18\x02\x20\x01(\rR\
    \x05cueId\x12-\n\x04time\x18\x03\x20\x01(\x0b2\x19.mizer.sequencer.CueTi\
    merR\x04time\"W\n\x19SequenceWrapAroundRequest\x12\x1a\n\x08sequence\x18\
    \x01\x20\x01(\rR\x08sequence\x12\x1e\n\nwrapAround\x18\x02\x20\x01(\x08R\
    \nwrapAround\"`\n\x1cSequenceStopOnLastCueRequest\x12\x1a\n\x08sequence\
    \x18\x01\x20\x01(\rR\x08sequence\x12$\n\rstopOnLastCue\x18\x02\x20\x01(\
    \x08R\rstopOnLastCue\"E\n\x13SequenceNameRequest\x12\x1a\n\x08sequence\
    \x18\x01\x20\x01(\rR\x08sequence\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\"\x0f\n\rEmptyResponse\"D\n\tSequences\x127\n\tsequences\x18\
    \x01\x20\x03(\x0b2\x19.mizer.sequencer.SequenceR\tsequences\"\xd5\x01\n\
    \x08Sequence\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12(\n\x04cues\x18\x03\x20\x03(\x0b2\x14.mi\
    zer.sequencer.CueR\x04cues\x125\n\x08fixtures\x18\x04\x20\x03(\x0b2\x19.\
    mizer.fixtures.FixtureIdR\x08fixtures\x12\x1e\n\nwrapAround\x18\x05\x20\
    \x01(\x08R\nwrapAround\x12$\n\rstopOnLastCue\x18\x06\x20\x01(\x08R\rstop\
    OnLastCue\"\xa5\x03\n\x03Cue\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x125\n\x07trigger\x18\x03\
    \x20\x01(\x0b2\x1b.mizer.sequencer.CueTriggerR\x07trigger\x127\n\x08cont\
    rols\x18\x04\x20\x03(\x0b2\x1b.mizer.sequencer.CueControlR\x08controls\
    \x12<\n\x0bcue_timings\x18\x05\x20\x01(\x0b2\x1b.mizer.sequencer.CueTimi\
    ngsR\ncueTimings\x12B\n\x0edimmer_timings\x18\x06\x20\x01(\x0b2\x1b.mize\
    r.sequencer.CueTimingsR\rdimmerTimings\x12F\n\x10position_timings\x18\
    \x07\x20\x01(\x0b2\x1b.mizer.sequencer.CueTimingsR\x0fpositionTimings\
    \x12@\n\rcolor_timings\x18\x08\x20\x01(\x0b2\x1b.mizer.sequencer.CueTimi\
    ngsR\x0ccolorTimings\"l\n\nCueTimings\x12-\n\x04fade\x18\x08\x20\x01(\
    \x0b2\x19.mizer.sequencer.CueTimerR\x04fade\x12/\n\x05delay\x18\t\x20\
    \x01(\x0b2\x19.mizer.sequencer.CueTimerR\x05delay\"\xbd\x01\n\nCueTrigge\
    r\x124\n\x04type\x18\x01\x20\x01(\x0e2\x20.mizer.sequencer.CueTrigger.Ty\
    peR\x04type\x121\n\x04time\x18\x02\x20\x01(\x0b2\x18.mizer.sequencer.Cue\
    TimeH\0R\x04time\x88\x01\x01\"=\n\x04Type\x12\x06\n\x02GO\x10\0\x12\n\n\
    \x06FOLLOW\x10\x01\x12\x08\n\x04TIME\x10\x02\x12\t\n\x05BEATS\x10\x03\
    \x12\x0c\n\x08TIMECODE\x10\x04B\x07\n\x05_time\"\xef\x02\n\nCueControl\
    \x124\n\x04type\x18\x01\x20\x01(\x0e2\x20.mizer.sequencer.CueControl.Typ\
    eR\x04type\x12/\n\x05value\x18\x02\x20\x01(\x0b2\x19.mizer.sequencer.Cue\
    ValueR\x05value\x125\n\x08fixtures\x18\x03\x20\x03(\x0b2\x19.mizer.fixtu\
    res.FixtureIdR\x08fixtures\"\xc2\x01\n\x04Type\x12\r\n\tINTENSITY\x10\0\
    \x12\x0b\n\x07SHUTTER\x10\x01\x12\r\n\tCOLOR_RED\x10\x02\x12\x0f\n\x0bCO\
    LOR_GREEN\x10\x03\x12\x0e\n\nCOLOR_BLUE\x10\x04\x12\x0f\n\x0bCOLOR_WHEEL\
    \x10\x05\x12\x07\n\x03PAN\x10\x06\x12\x08\n\x04TILT\x10\x07\x12\t\n\x05F\
    OCUS\x10\x08\x12\x08\n\x04ZOOM\x10\t\x12\t\n\x05PRISM\x10\n\x12\x08\n\
    \x04IRIS\x10\x0b\x12\t\n\x05FROST\x10\x0c\x12\x08\n\x04GOBO\x10\r\x12\
    \x0b\n\x07GENERIC\x10\x0e\"e\n\x08CueValue\x12\x18\n\x06direct\x18\x03\
    \x20\x01(\x01H\0R\x06direct\x126\n\x05range\x18\x04\x20\x01(\x0b2\x1e.mi\
    zer.sequencer.CueValueRangeH\0R\x05rangeB\x07\n\x05value\"\x9b\x01\n\x08\
    CueTimer\x12\x1a\n\x08hasTimer\x18\x01\x20\x01(\x08R\x08hasTimer\x122\n\
    \x06direct\x18\x02\x20\x01(\x0b2\x18.mizer.sequencer.CueTimeH\0R\x06dire\
    ct\x126\n\x05range\x18\x03\x20\x01(\x0b2\x1e.mizer.sequencer.CueTimerRan\
    geH\0R\x05rangeB\x07\n\x05timer\"3\n\rCueValueRange\x12\x12\n\x04from\
    \x18\x01\x20\x01(\x01R\x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\x01R\x02\
    to\"E\n\x07CueTime\x12\x1a\n\x07seconds\x18\x01\x20\x01(\x01H\0R\x07seco\
    nds\x12\x16\n\x05beats\x18\x02\x20\x01(\x01H\0R\x05beatsB\x06\n\x04time\
    \"g\n\rCueTimerRange\x12,\n\x04from\x18\x01\x20\x01(\x0b2\x18.mizer.sequ\
    encer.CueTimeR\x04from\x12(\n\x02to\x18\x02\x20\x01(\x0b2\x18.mizer.sequ\
    encer.CueTimeR\x02to2\x94\n\n\x0cSequencerApi\x12P\n\x0cGetSequences\x12\
    $.mizer.sequencer.GetSequencesRequest\x1a\x1a.mizer.sequencer.Sequences\
    \x12M\n\x0bGetSequence\x12#.mizer.sequencer.GetSequenceRequest\x1a\x19.m\
    izer.sequencer.Sequence\x12M\n\x0bAddSequence\x12#.mizer.sequencer.AddSe\
    quenceRequest\x1a\x19.mizer.sequencer.Sequence\x12T\n\x0eDeleteSequence\
    \x12&.mizer.sequencer.DeleteSequenceRequest\x1a\x1a.mizer.sequencer.Sequ\
    ences\x12P\n\nSequenceGo\x12\".mizer.sequencer.SequenceGoRequest\x1a\x1e\
    .mizer.sequencer.EmptyResponse\x12T\n\x0cSequenceStop\x12$.mizer.sequenc\
    er.SequenceStopRequest\x1a\x1e.mizer.sequencer.EmptyResponse\x12R\n\x10U\
    pdateCueTrigger\x12\".mizer.sequencer.CueTriggerRequest\x1a\x1a.mizer.se\
    quencer.Sequences\x12Z\n\x14UpdateCueTriggerTime\x12&.mizer.sequencer.Cu\
    eTriggerTimeRequest\x1a\x1a.mizer.sequencer.Sequences\x12L\n\rUpdateCueN\
    ame\x12\x1f.mizer.sequencer.CueNameRequest\x1a\x1a.mizer.sequencer.Seque\
    nces\x12N\n\x0eUpdateCueValue\x12\x20.mizer.sequencer.CueValueRequest\
    \x1a\x1a.mizer.sequencer.Sequences\x12R\n\x11UpdateCueFadeTime\x12!.mize\
    r.sequencer.CueTimingRequest\x1a\x1a.mizer.sequencer.Sequences\x12S\n\
    \x12UpdateCueDelayTime\x12!.mizer.sequencer.CueTimingRequest\x1a\x1a.miz\
    er.sequencer.Sequences\x12b\n\x18UpdateSequenceWrapAround\x12*.mizer.seq\
    uencer.SequenceWrapAroundRequest\x1a\x1a.mizer.sequencer.Sequences\x12h\
    \n\x1bUpdateSequenceStopOnLastCue\x12-.mizer.sequencer.SequenceStopOnLas\
    tCueRequest\x1a\x1a.mizer.sequencer.Sequences\x12Q\n\x12UpdateSequenceNa\
    me\x12\x1f.mizer.sequencer.CueNameRequest\x1a\x1a.mizer.sequencer.Sequen\
    cesb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::fixtures::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(26);
            messages.push(GetSequencesRequest::generated_message_descriptor_data());
            messages.push(GetSequenceRequest::generated_message_descriptor_data());
            messages.push(AddSequenceRequest::generated_message_descriptor_data());
            messages.push(DeleteSequenceRequest::generated_message_descriptor_data());
            messages.push(SequenceGoRequest::generated_message_descriptor_data());
            messages.push(SequenceStopRequest::generated_message_descriptor_data());
            messages.push(CueTriggerRequest::generated_message_descriptor_data());
            messages.push(CueTriggerTimeRequest::generated_message_descriptor_data());
            messages.push(CueNameRequest::generated_message_descriptor_data());
            messages.push(CueValueRequest::generated_message_descriptor_data());
            messages.push(CueTimingRequest::generated_message_descriptor_data());
            messages.push(SequenceWrapAroundRequest::generated_message_descriptor_data());
            messages.push(SequenceStopOnLastCueRequest::generated_message_descriptor_data());
            messages.push(SequenceNameRequest::generated_message_descriptor_data());
            messages.push(EmptyResponse::generated_message_descriptor_data());
            messages.push(Sequences::generated_message_descriptor_data());
            messages.push(Sequence::generated_message_descriptor_data());
            messages.push(Cue::generated_message_descriptor_data());
            messages.push(CueTimings::generated_message_descriptor_data());
            messages.push(CueTrigger::generated_message_descriptor_data());
            messages.push(CueControl::generated_message_descriptor_data());
            messages.push(CueValue::generated_message_descriptor_data());
            messages.push(CueTimer::generated_message_descriptor_data());
            messages.push(CueValueRange::generated_message_descriptor_data());
            messages.push(CueTime::generated_message_descriptor_data());
            messages.push(CueTimerRange::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(cue_trigger::Type::generated_enum_descriptor_data());
            enums.push(cue_control::Type::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
