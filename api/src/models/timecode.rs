// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `timecode.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.NoContentResponse)
pub struct NoContentResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.NoContentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NoContentResponse {
    fn default() -> &'a NoContentResponse {
        <NoContentResponse as ::protobuf::Message>::default_instance()
    }
}

impl NoContentResponse {
    pub fn new() -> NoContentResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoContentResponse>(
            "NoContentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NoContentResponse {
    const NAME: &'static str = "NoContentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NoContentResponse {
        NoContentResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NoContentResponse {
        static instance: NoContentResponse = NoContentResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NoContentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NoContentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NoContentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoContentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.AddTimecodeRequest)
pub struct AddTimecodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.AddTimecodeRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.AddTimecodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddTimecodeRequest {
    fn default() -> &'a AddTimecodeRequest {
        <AddTimecodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddTimecodeRequest {
    pub fn new() -> AddTimecodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AddTimecodeRequest| { &m.name },
            |m: &mut AddTimecodeRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddTimecodeRequest>(
            "AddTimecodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddTimecodeRequest {
    const NAME: &'static str = "AddTimecodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddTimecodeRequest {
        AddTimecodeRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddTimecodeRequest {
        static instance: AddTimecodeRequest = AddTimecodeRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddTimecodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddTimecodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddTimecodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddTimecodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.RenameTimecodeRequest)
pub struct RenameTimecodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.RenameTimecodeRequest.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.timecode.RenameTimecodeRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.RenameTimecodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RenameTimecodeRequest {
    fn default() -> &'a RenameTimecodeRequest {
        <RenameTimecodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl RenameTimecodeRequest {
    pub fn new() -> RenameTimecodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &RenameTimecodeRequest| { &m.id },
            |m: &mut RenameTimecodeRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &RenameTimecodeRequest| { &m.name },
            |m: &mut RenameTimecodeRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RenameTimecodeRequest>(
            "RenameTimecodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RenameTimecodeRequest {
    const NAME: &'static str = "RenameTimecodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RenameTimecodeRequest {
        RenameTimecodeRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RenameTimecodeRequest {
        static instance: RenameTimecodeRequest = RenameTimecodeRequest {
            id: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RenameTimecodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RenameTimecodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RenameTimecodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameTimecodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.DeleteTimecodeRequest)
pub struct DeleteTimecodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.DeleteTimecodeRequest.id)
    pub id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.DeleteTimecodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTimecodeRequest {
    fn default() -> &'a DeleteTimecodeRequest {
        <DeleteTimecodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTimecodeRequest {
    pub fn new() -> DeleteTimecodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteTimecodeRequest| { &m.id },
            |m: &mut DeleteTimecodeRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTimecodeRequest>(
            "DeleteTimecodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTimecodeRequest {
    const NAME: &'static str = "DeleteTimecodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTimecodeRequest {
        DeleteTimecodeRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTimecodeRequest {
        static instance: DeleteTimecodeRequest = DeleteTimecodeRequest {
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTimecodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTimecodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTimecodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTimecodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.AddTimecodeControlRequest)
pub struct AddTimecodeControlRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.AddTimecodeControlRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.AddTimecodeControlRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddTimecodeControlRequest {
    fn default() -> &'a AddTimecodeControlRequest {
        <AddTimecodeControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddTimecodeControlRequest {
    pub fn new() -> AddTimecodeControlRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AddTimecodeControlRequest| { &m.name },
            |m: &mut AddTimecodeControlRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddTimecodeControlRequest>(
            "AddTimecodeControlRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddTimecodeControlRequest {
    const NAME: &'static str = "AddTimecodeControlRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddTimecodeControlRequest {
        AddTimecodeControlRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddTimecodeControlRequest {
        static instance: AddTimecodeControlRequest = AddTimecodeControlRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddTimecodeControlRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddTimecodeControlRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddTimecodeControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddTimecodeControlRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.RenameTimecodeControlRequest)
pub struct RenameTimecodeControlRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.RenameTimecodeControlRequest.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.timecode.RenameTimecodeControlRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.RenameTimecodeControlRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RenameTimecodeControlRequest {
    fn default() -> &'a RenameTimecodeControlRequest {
        <RenameTimecodeControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl RenameTimecodeControlRequest {
    pub fn new() -> RenameTimecodeControlRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &RenameTimecodeControlRequest| { &m.id },
            |m: &mut RenameTimecodeControlRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &RenameTimecodeControlRequest| { &m.name },
            |m: &mut RenameTimecodeControlRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RenameTimecodeControlRequest>(
            "RenameTimecodeControlRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RenameTimecodeControlRequest {
    const NAME: &'static str = "RenameTimecodeControlRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RenameTimecodeControlRequest {
        RenameTimecodeControlRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RenameTimecodeControlRequest {
        static instance: RenameTimecodeControlRequest = RenameTimecodeControlRequest {
            id: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RenameTimecodeControlRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RenameTimecodeControlRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RenameTimecodeControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameTimecodeControlRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.DeleteTimecodeControlRequest)
pub struct DeleteTimecodeControlRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.DeleteTimecodeControlRequest.id)
    pub id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.DeleteTimecodeControlRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTimecodeControlRequest {
    fn default() -> &'a DeleteTimecodeControlRequest {
        <DeleteTimecodeControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTimecodeControlRequest {
    pub fn new() -> DeleteTimecodeControlRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &DeleteTimecodeControlRequest| { &m.id },
            |m: &mut DeleteTimecodeControlRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTimecodeControlRequest>(
            "DeleteTimecodeControlRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTimecodeControlRequest {
    const NAME: &'static str = "DeleteTimecodeControlRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTimecodeControlRequest {
        DeleteTimecodeControlRequest::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTimecodeControlRequest {
        static instance: DeleteTimecodeControlRequest = DeleteTimecodeControlRequest {
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTimecodeControlRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTimecodeControlRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTimecodeControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTimecodeControlRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.AllTimecodes)
pub struct AllTimecodes {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.AllTimecodes.timecodes)
    pub timecodes: ::std::vec::Vec<Timecode>,
    // @@protoc_insertion_point(field:mizer.timecode.AllTimecodes.controls)
    pub controls: ::std::vec::Vec<TimecodeControl>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.AllTimecodes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllTimecodes {
    fn default() -> &'a AllTimecodes {
        <AllTimecodes as ::protobuf::Message>::default_instance()
    }
}

impl AllTimecodes {
    pub fn new() -> AllTimecodes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "timecodes",
            |m: &AllTimecodes| { &m.timecodes },
            |m: &mut AllTimecodes| { &mut m.timecodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "controls",
            |m: &AllTimecodes| { &m.controls },
            |m: &mut AllTimecodes| { &mut m.controls },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllTimecodes>(
            "AllTimecodes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllTimecodes {
    const NAME: &'static str = "AllTimecodes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.timecodes.push(is.read_message()?);
                },
                18 => {
                    self.controls.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.timecodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.controls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.timecodes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.controls {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllTimecodes {
        AllTimecodes::new()
    }

    fn clear(&mut self) {
        self.timecodes.clear();
        self.controls.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllTimecodes {
        static instance: AllTimecodes = AllTimecodes {
            timecodes: ::std::vec::Vec::new(),
            controls: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllTimecodes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllTimecodes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllTimecodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllTimecodes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.Timecode)
pub struct Timecode {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.Timecode.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.timecode.Timecode.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.timecode.Timecode.controls)
    pub controls: ::std::vec::Vec<TimecodeControlValues>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.Timecode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Timecode {
    fn default() -> &'a Timecode {
        <Timecode as ::protobuf::Message>::default_instance()
    }
}

impl Timecode {
    pub fn new() -> Timecode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Timecode| { &m.id },
            |m: &mut Timecode| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Timecode| { &m.name },
            |m: &mut Timecode| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "controls",
            |m: &Timecode| { &m.controls },
            |m: &mut Timecode| { &mut m.controls },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Timecode>(
            "Timecode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Timecode {
    const NAME: &'static str = "Timecode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.controls.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.controls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.controls {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Timecode {
        Timecode::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.controls.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Timecode {
        static instance: Timecode = Timecode {
            id: 0,
            name: ::std::string::String::new(),
            controls: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Timecode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Timecode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Timecode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timecode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.TimecodeControl)
pub struct TimecodeControl {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.TimecodeControl.id)
    pub id: u32,
    // @@protoc_insertion_point(field:mizer.timecode.TimecodeControl.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.TimecodeControl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimecodeControl {
    fn default() -> &'a TimecodeControl {
        <TimecodeControl as ::protobuf::Message>::default_instance()
    }
}

impl TimecodeControl {
    pub fn new() -> TimecodeControl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &TimecodeControl| { &m.id },
            |m: &mut TimecodeControl| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &TimecodeControl| { &m.name },
            |m: &mut TimecodeControl| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimecodeControl>(
            "TimecodeControl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimecodeControl {
    const NAME: &'static str = "TimecodeControl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimecodeControl {
        TimecodeControl::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimecodeControl {
        static instance: TimecodeControl = TimecodeControl {
            id: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimecodeControl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimecodeControl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimecodeControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimecodeControl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.timecode.TimecodeControlValues)
pub struct TimecodeControlValues {
    // message fields
    // @@protoc_insertion_point(field:mizer.timecode.TimecodeControlValues.control_id)
    pub control_id: u32,
    // @@protoc_insertion_point(field:mizer.timecode.TimecodeControlValues.steps)
    pub steps: ::std::vec::Vec<timecode_control_values::Step>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.timecode.TimecodeControlValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimecodeControlValues {
    fn default() -> &'a TimecodeControlValues {
        <TimecodeControlValues as ::protobuf::Message>::default_instance()
    }
}

impl TimecodeControlValues {
    pub fn new() -> TimecodeControlValues {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "control_id",
            |m: &TimecodeControlValues| { &m.control_id },
            |m: &mut TimecodeControlValues| { &mut m.control_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &TimecodeControlValues| { &m.steps },
            |m: &mut TimecodeControlValues| { &mut m.steps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimecodeControlValues>(
            "TimecodeControlValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimecodeControlValues {
    const NAME: &'static str = "TimecodeControlValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.control_id = is.read_uint32()?;
                },
                18 => {
                    self.steps.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.control_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.control_id);
        }
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.control_id != 0 {
            os.write_uint32(1, self.control_id)?;
        }
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimecodeControlValues {
        TimecodeControlValues::new()
    }

    fn clear(&mut self) {
        self.control_id = 0;
        self.steps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimecodeControlValues {
        static instance: TimecodeControlValues = TimecodeControlValues {
            control_id: 0,
            steps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimecodeControlValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimecodeControlValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimecodeControlValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimecodeControlValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TimecodeControlValues`
pub mod timecode_control_values {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.timecode.TimecodeControlValues.Step)
    pub struct Step {
        // message fields
        // @@protoc_insertion_point(field:mizer.timecode.TimecodeControlValues.Step.x)
        pub x: f64,
        // @@protoc_insertion_point(field:mizer.timecode.TimecodeControlValues.Step.y)
        pub y: f64,
        // @@protoc_insertion_point(field:mizer.timecode.TimecodeControlValues.Step.c0a)
        pub c0a: f64,
        // @@protoc_insertion_point(field:mizer.timecode.TimecodeControlValues.Step.c0b)
        pub c0b: f64,
        // @@protoc_insertion_point(field:mizer.timecode.TimecodeControlValues.Step.c1a)
        pub c1a: f64,
        // @@protoc_insertion_point(field:mizer.timecode.TimecodeControlValues.Step.c1b)
        pub c1b: f64,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.timecode.TimecodeControlValues.Step.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Step {
        fn default() -> &'a Step {
            <Step as ::protobuf::Message>::default_instance()
        }
    }

    impl Step {
        pub fn new() -> Step {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "x",
                |m: &Step| { &m.x },
                |m: &mut Step| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "y",
                |m: &Step| { &m.y },
                |m: &mut Step| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "c0a",
                |m: &Step| { &m.c0a },
                |m: &mut Step| { &mut m.c0a },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "c0b",
                |m: &Step| { &m.c0b },
                |m: &mut Step| { &mut m.c0b },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "c1a",
                |m: &Step| { &m.c1a },
                |m: &mut Step| { &mut m.c1a },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "c1b",
                |m: &Step| { &m.c1b },
                |m: &mut Step| { &mut m.c1b },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Step>(
                "TimecodeControlValues.Step",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Step {
        const NAME: &'static str = "Step";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.x = is.read_double()?;
                    },
                    17 => {
                        self.y = is.read_double()?;
                    },
                    25 => {
                        self.c0a = is.read_double()?;
                    },
                    33 => {
                        self.c0b = is.read_double()?;
                    },
                    41 => {
                        self.c1a = is.read_double()?;
                    },
                    49 => {
                        self.c1b = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.x != 0. {
                my_size += 1 + 8;
            }
            if self.y != 0. {
                my_size += 1 + 8;
            }
            if self.c0a != 0. {
                my_size += 1 + 8;
            }
            if self.c0b != 0. {
                my_size += 1 + 8;
            }
            if self.c1a != 0. {
                my_size += 1 + 8;
            }
            if self.c1b != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.x != 0. {
                os.write_double(1, self.x)?;
            }
            if self.y != 0. {
                os.write_double(2, self.y)?;
            }
            if self.c0a != 0. {
                os.write_double(3, self.c0a)?;
            }
            if self.c0b != 0. {
                os.write_double(4, self.c0b)?;
            }
            if self.c1a != 0. {
                os.write_double(5, self.c1a)?;
            }
            if self.c1b != 0. {
                os.write_double(6, self.c1b)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Step {
            Step::new()
        }

        fn clear(&mut self) {
            self.x = 0.;
            self.y = 0.;
            self.c0a = 0.;
            self.c0b = 0.;
            self.c1a = 0.;
            self.c1b = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Step {
            static instance: Step = Step {
                x: 0.,
                y: 0.,
                c0a: 0.,
                c0b: 0.,
                c1a: 0.,
                c1b: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Step {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TimecodeControlValues.Step").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Step {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Step {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0etimecode.proto\x12\x0emizer.timecode\"\x13\n\x11NoContentResponse\
    \"(\n\x12AddTimecodeRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04nam\
    e\";\n\x15RenameTimecodeRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02i\
    d\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"'\n\x15DeleteTimecodeRe\
    quest\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\"/\n\x19AddTimecodeContr\
    olRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"B\n\x1cRenameTi\
    mecodeControlRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\".\n\x1cDeleteTimecodeControlReques\
    t\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\"\x83\x01\n\x0cAllTimecodes\
    \x126\n\ttimecodes\x18\x01\x20\x03(\x0b2\x18.mizer.timecode.TimecodeR\tt\
    imecodes\x12;\n\x08controls\x18\x02\x20\x03(\x0b2\x1f.mizer.timecode.Tim\
    ecodeControlR\x08controls\"q\n\x08Timecode\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12A\n\x08c\
    ontrols\x18\x03\x20\x03(\x0b2%.mizer.timecode.TimecodeControlValuesR\x08\
    controls\"5\n\x0fTimecodeControl\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02\
    id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"\xe4\x01\n\x15Timecode\
    ControlValues\x12\x1d\n\ncontrol_id\x18\x01\x20\x01(\rR\tcontrolId\x12@\
    \n\x05steps\x18\x02\x20\x03(\x0b2*.mizer.timecode.TimecodeControlValues.\
    StepR\x05steps\x1aj\n\x04Step\x12\x0c\n\x01x\x18\x01\x20\x01(\x01R\x01x\
    \x12\x0c\n\x01y\x18\x02\x20\x01(\x01R\x01y\x12\x10\n\x03c0a\x18\x03\x20\
    \x01(\x01R\x03c0a\x12\x10\n\x03c0b\x18\x04\x20\x01(\x01R\x03c0b\x12\x10\
    \n\x03c1a\x18\x05\x20\x01(\x01R\x03c1a\x12\x10\n\x03c1b\x18\x06\x20\x01(\
    \x01R\x03c1b2\xd3\x04\n\x0bTimecodeApi\x12T\n\x0bAddTimecode\x12\".mizer\
    .timecode.AddTimecodeRequest\x1a!.mizer.timecode.NoContentResponse\x12Z\
    \n\x0eRenameTimecode\x12%.mizer.timecode.RenameTimecodeRequest\x1a!.mize\
    r.timecode.NoContentResponse\x12Z\n\x0eDeleteTimecode\x12%.mizer.timecod\
    e.DeleteTimecodeRequest\x1a!.mizer.timecode.NoContentResponse\x12b\n\x12\
    AddTimecodeControl\x12).mizer.timecode.AddTimecodeControlRequest\x1a!.mi\
    zer.timecode.NoContentResponse\x12h\n\x15RenameTimecodeControl\x12,.mize\
    r.timecode.RenameTimecodeControlRequest\x1a!.mizer.timecode.NoContentRes\
    ponse\x12h\n\x15DeleteTimecodeControl\x12,.mizer.timecode.DeleteTimecode\
    ControlRequest\x1a!.mizer.timecode.NoContentResponseb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(NoContentResponse::generated_message_descriptor_data());
            messages.push(AddTimecodeRequest::generated_message_descriptor_data());
            messages.push(RenameTimecodeRequest::generated_message_descriptor_data());
            messages.push(DeleteTimecodeRequest::generated_message_descriptor_data());
            messages.push(AddTimecodeControlRequest::generated_message_descriptor_data());
            messages.push(RenameTimecodeControlRequest::generated_message_descriptor_data());
            messages.push(DeleteTimecodeControlRequest::generated_message_descriptor_data());
            messages.push(AllTimecodes::generated_message_descriptor_data());
            messages.push(Timecode::generated_message_descriptor_data());
            messages.push(TimecodeControl::generated_message_descriptor_data());
            messages.push(TimecodeControlValues::generated_message_descriptor_data());
            messages.push(timecode_control_values::Step::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
