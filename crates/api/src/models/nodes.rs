// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `nodes.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.AddNodeRequest)
pub struct AddNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.AddNodeRequest.type)
    pub type_: ::protobuf::EnumOrUnknown<node::NodeType>,
    // @@protoc_insertion_point(field:mizer.nodes.AddNodeRequest.position)
    pub position: ::protobuf::MessageField<NodePosition>,
    // @@protoc_insertion_point(field:mizer.nodes.AddNodeRequest.parent)
    pub parent: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.AddNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddNodeRequest {
    fn default() -> &'a AddNodeRequest {
        <AddNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddNodeRequest {
    pub fn new() -> AddNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &AddNodeRequest| { &m.type_ },
            |m: &mut AddNodeRequest| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodePosition>(
            "position",
            |m: &AddNodeRequest| { &m.position },
            |m: &mut AddNodeRequest| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &AddNodeRequest| { &m.parent },
            |m: &mut AddNodeRequest| { &mut m.parent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddNodeRequest>(
            "AddNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddNodeRequest {
    const NAME: &'static str = "AddNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                26 => {
                    self.parent = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::FADER) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.parent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::FADER) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.parent.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddNodeRequest {
        AddNodeRequest::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(node::NodeType::FADER);
        self.position.clear();
        self.parent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddNodeRequest {
        static instance: AddNodeRequest = AddNodeRequest {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            position: ::protobuf::MessageField::none(),
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.DuplicateNodeRequest)
pub struct DuplicateNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.DuplicateNodeRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.DuplicateNodeRequest.parent)
    pub parent: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.DuplicateNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DuplicateNodeRequest {
    fn default() -> &'a DuplicateNodeRequest {
        <DuplicateNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DuplicateNodeRequest {
    pub fn new() -> DuplicateNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &DuplicateNodeRequest| { &m.path },
            |m: &mut DuplicateNodeRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &DuplicateNodeRequest| { &m.parent },
            |m: &mut DuplicateNodeRequest| { &mut m.parent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DuplicateNodeRequest>(
            "DuplicateNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DuplicateNodeRequest {
    const NAME: &'static str = "DuplicateNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.parent = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(v) = self.parent.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(v) = self.parent.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DuplicateNodeRequest {
        DuplicateNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.parent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DuplicateNodeRequest {
        static instance: DuplicateNodeRequest = DuplicateNodeRequest {
            path: ::std::string::String::new(),
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DuplicateNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DuplicateNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DuplicateNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DuplicateNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodesRequest)
pub struct NodesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodesRequest {
    fn default() -> &'a NodesRequest {
        <NodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl NodesRequest {
    pub fn new() -> NodesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodesRequest>(
            "NodesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodesRequest {
    const NAME: &'static str = "NodesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodesRequest {
        NodesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodesRequest {
        static instance: NodesRequest = NodesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.WriteControl)
pub struct WriteControl {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.WriteControl.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.WriteControl.port)
    pub port: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.WriteControl.value)
    pub value: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.WriteControl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteControl {
    fn default() -> &'a WriteControl {
        <WriteControl as ::protobuf::Message>::default_instance()
    }
}

impl WriteControl {
    pub fn new() -> WriteControl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &WriteControl| { &m.path },
            |m: &mut WriteControl| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &WriteControl| { &m.port },
            |m: &mut WriteControl| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &WriteControl| { &m.value },
            |m: &mut WriteControl| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteControl>(
            "WriteControl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteControl {
    const NAME: &'static str = "WriteControl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.port = is.read_string()?;
                },
                25 => {
                    self.value = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.port.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.port);
        }
        if self.value != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.port.is_empty() {
            os.write_string(2, &self.port)?;
        }
        if self.value != 0. {
            os.write_double(3, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteControl {
        WriteControl::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.port.clear();
        self.value = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteControl {
        static instance: WriteControl = WriteControl {
            path: ::std::string::String::new(),
            port: ::std::string::String::new(),
            value: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteControl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteControl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteControl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.WriteResponse)
pub struct WriteResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.WriteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteResponse {
    fn default() -> &'a WriteResponse {
        <WriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteResponse {
    pub fn new() -> WriteResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteResponse>(
            "WriteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteResponse {
    const NAME: &'static str = "WriteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteResponse {
        WriteResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteResponse {
        static instance: WriteResponse = WriteResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.UpdateNodeSettingRequest)
pub struct UpdateNodeSettingRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.UpdateNodeSettingRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.UpdateNodeSettingRequest.setting)
    pub setting: ::protobuf::MessageField<NodeSetting>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.UpdateNodeSettingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateNodeSettingRequest {
    fn default() -> &'a UpdateNodeSettingRequest {
        <UpdateNodeSettingRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNodeSettingRequest {
    pub fn new() -> UpdateNodeSettingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &UpdateNodeSettingRequest| { &m.path },
            |m: &mut UpdateNodeSettingRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeSetting>(
            "setting",
            |m: &UpdateNodeSettingRequest| { &m.setting },
            |m: &mut UpdateNodeSettingRequest| { &mut m.setting },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateNodeSettingRequest>(
            "UpdateNodeSettingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateNodeSettingRequest {
    const NAME: &'static str = "UpdateNodeSettingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.setting)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(v) = self.setting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(v) = self.setting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateNodeSettingRequest {
        UpdateNodeSettingRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.setting.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateNodeSettingRequest {
        static instance: UpdateNodeSettingRequest = UpdateNodeSettingRequest {
            path: ::std::string::String::new(),
            setting: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateNodeSettingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateNodeSettingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateNodeSettingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNodeSettingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MoveNodeRequest)
pub struct MoveNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.MoveNodeRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.MoveNodeRequest.position)
    pub position: ::protobuf::MessageField<NodePosition>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MoveNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveNodeRequest {
    fn default() -> &'a MoveNodeRequest {
        <MoveNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoveNodeRequest {
    pub fn new() -> MoveNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &MoveNodeRequest| { &m.path },
            |m: &mut MoveNodeRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodePosition>(
            "position",
            |m: &MoveNodeRequest| { &m.position },
            |m: &mut MoveNodeRequest| { &mut m.position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveNodeRequest>(
            "MoveNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveNodeRequest {
    const NAME: &'static str = "MoveNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveNodeRequest {
        MoveNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.position.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveNodeRequest {
        static instance: MoveNodeRequest = MoveNodeRequest {
            path: ::std::string::String::new(),
            position: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MoveNodeResponse)
pub struct MoveNodeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MoveNodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveNodeResponse {
    fn default() -> &'a MoveNodeResponse {
        <MoveNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl MoveNodeResponse {
    pub fn new() -> MoveNodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveNodeResponse>(
            "MoveNodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveNodeResponse {
    const NAME: &'static str = "MoveNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveNodeResponse {
        MoveNodeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveNodeResponse {
        static instance: MoveNodeResponse = MoveNodeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveNodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveNodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveNodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ShowNodeRequest)
pub struct ShowNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.ShowNodeRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.ShowNodeRequest.position)
    pub position: ::protobuf::MessageField<NodePosition>,
    // @@protoc_insertion_point(field:mizer.nodes.ShowNodeRequest.parent)
    pub parent: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ShowNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShowNodeRequest {
    fn default() -> &'a ShowNodeRequest {
        <ShowNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ShowNodeRequest {
    pub fn new() -> ShowNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &ShowNodeRequest| { &m.path },
            |m: &mut ShowNodeRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodePosition>(
            "position",
            |m: &ShowNodeRequest| { &m.position },
            |m: &mut ShowNodeRequest| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &ShowNodeRequest| { &m.parent },
            |m: &mut ShowNodeRequest| { &mut m.parent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShowNodeRequest>(
            "ShowNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShowNodeRequest {
    const NAME: &'static str = "ShowNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                26 => {
                    self.parent = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.parent.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.parent.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShowNodeRequest {
        ShowNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.position.clear();
        self.parent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShowNodeRequest {
        static instance: ShowNodeRequest = ShowNodeRequest {
            path: ::std::string::String::new(),
            position: ::protobuf::MessageField::none(),
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShowNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShowNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShowNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShowNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ShowNodeResponse)
pub struct ShowNodeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ShowNodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShowNodeResponse {
    fn default() -> &'a ShowNodeResponse {
        <ShowNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ShowNodeResponse {
    pub fn new() -> ShowNodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShowNodeResponse>(
            "ShowNodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShowNodeResponse {
    const NAME: &'static str = "ShowNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShowNodeResponse {
        ShowNodeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShowNodeResponse {
        static instance: ShowNodeResponse = ShowNodeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShowNodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShowNodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShowNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShowNodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.RenameNodeRequest)
pub struct RenameNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.RenameNodeRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.RenameNodeRequest.new_name)
    pub new_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.RenameNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RenameNodeRequest {
    fn default() -> &'a RenameNodeRequest {
        <RenameNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl RenameNodeRequest {
    pub fn new() -> RenameNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &RenameNodeRequest| { &m.path },
            |m: &mut RenameNodeRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_name",
            |m: &RenameNodeRequest| { &m.new_name },
            |m: &mut RenameNodeRequest| { &mut m.new_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RenameNodeRequest>(
            "RenameNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RenameNodeRequest {
    const NAME: &'static str = "RenameNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.new_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.new_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.new_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.new_name.is_empty() {
            os.write_string(2, &self.new_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RenameNodeRequest {
        RenameNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.new_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RenameNodeRequest {
        static instance: RenameNodeRequest = RenameNodeRequest {
            path: ::std::string::String::new(),
            new_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RenameNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RenameNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RenameNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.RenameNodeResponse)
pub struct RenameNodeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.RenameNodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RenameNodeResponse {
    fn default() -> &'a RenameNodeResponse {
        <RenameNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl RenameNodeResponse {
    pub fn new() -> RenameNodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RenameNodeResponse>(
            "RenameNodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RenameNodeResponse {
    const NAME: &'static str = "RenameNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RenameNodeResponse {
        RenameNodeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RenameNodeResponse {
        static instance: RenameNodeResponse = RenameNodeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RenameNodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RenameNodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RenameNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameNodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.GroupNodesRequest)
pub struct GroupNodesRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.GroupNodesRequest.nodes)
    pub nodes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:mizer.nodes.GroupNodesRequest.parent)
    pub parent: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.GroupNodesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupNodesRequest {
    fn default() -> &'a GroupNodesRequest {
        <GroupNodesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GroupNodesRequest {
    pub fn new() -> GroupNodesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &GroupNodesRequest| { &m.nodes },
            |m: &mut GroupNodesRequest| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent",
            |m: &GroupNodesRequest| { &m.parent },
            |m: &mut GroupNodesRequest| { &mut m.parent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupNodesRequest>(
            "GroupNodesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupNodesRequest {
    const NAME: &'static str = "GroupNodesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nodes.push(is.read_string()?);
                },
                18 => {
                    self.parent = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nodes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.parent.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nodes {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.parent.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupNodesRequest {
        GroupNodesRequest::new()
    }

    fn clear(&mut self) {
        self.nodes.clear();
        self.parent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupNodesRequest {
        static instance: GroupNodesRequest = GroupNodesRequest {
            nodes: ::std::vec::Vec::new(),
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupNodesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupNodesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupNodesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupNodesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.GroupNodesResponse)
pub struct GroupNodesResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.GroupNodesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupNodesResponse {
    fn default() -> &'a GroupNodesResponse {
        <GroupNodesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GroupNodesResponse {
    pub fn new() -> GroupNodesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupNodesResponse>(
            "GroupNodesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupNodesResponse {
    const NAME: &'static str = "GroupNodesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupNodesResponse {
        GroupNodesResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupNodesResponse {
        static instance: GroupNodesResponse = GroupNodesResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupNodesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupNodesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupNodesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupNodesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.DeleteNodeRequest)
pub struct DeleteNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.DeleteNodeRequest.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.DeleteNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteNodeRequest {
    fn default() -> &'a DeleteNodeRequest {
        <DeleteNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNodeRequest {
    pub fn new() -> DeleteNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &DeleteNodeRequest| { &m.path },
            |m: &mut DeleteNodeRequest| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteNodeRequest>(
            "DeleteNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteNodeRequest {
    const NAME: &'static str = "DeleteNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteNodeRequest {
        DeleteNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteNodeRequest {
        static instance: DeleteNodeRequest = DeleteNodeRequest {
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.DeleteNodeResponse)
pub struct DeleteNodeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.DeleteNodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteNodeResponse {
    fn default() -> &'a DeleteNodeResponse {
        <DeleteNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNodeResponse {
    pub fn new() -> DeleteNodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteNodeResponse>(
            "DeleteNodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteNodeResponse {
    const NAME: &'static str = "DeleteNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteNodeResponse {
        DeleteNodeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteNodeResponse {
        static instance: DeleteNodeResponse = DeleteNodeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteNodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteNodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.HideNodeRequest)
pub struct HideNodeRequest {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.HideNodeRequest.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.HideNodeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HideNodeRequest {
    fn default() -> &'a HideNodeRequest {
        <HideNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl HideNodeRequest {
    pub fn new() -> HideNodeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &HideNodeRequest| { &m.path },
            |m: &mut HideNodeRequest| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HideNodeRequest>(
            "HideNodeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HideNodeRequest {
    const NAME: &'static str = "HideNodeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HideNodeRequest {
        HideNodeRequest::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HideNodeRequest {
        static instance: HideNodeRequest = HideNodeRequest {
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HideNodeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HideNodeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HideNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HideNodeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.HideNodeResponse)
pub struct HideNodeResponse {
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.HideNodeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HideNodeResponse {
    fn default() -> &'a HideNodeResponse {
        <HideNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl HideNodeResponse {
    pub fn new() -> HideNodeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HideNodeResponse>(
            "HideNodeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HideNodeResponse {
    const NAME: &'static str = "HideNodeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HideNodeResponse {
        HideNodeResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HideNodeResponse {
        static instance: HideNodeResponse = HideNodeResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HideNodeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HideNodeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HideNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HideNodeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.Nodes)
pub struct Nodes {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.Nodes.nodes)
    pub nodes: ::std::vec::Vec<Node>,
    // @@protoc_insertion_point(field:mizer.nodes.Nodes.channels)
    pub channels: ::std::vec::Vec<NodeConnection>,
    // @@protoc_insertion_point(field:mizer.nodes.Nodes.all_nodes)
    pub all_nodes: ::std::vec::Vec<Node>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.Nodes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Nodes {
    fn default() -> &'a Nodes {
        <Nodes as ::protobuf::Message>::default_instance()
    }
}

impl Nodes {
    pub fn new() -> Nodes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &Nodes| { &m.nodes },
            |m: &mut Nodes| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels",
            |m: &Nodes| { &m.channels },
            |m: &mut Nodes| { &mut m.channels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "all_nodes",
            |m: &Nodes| { &m.all_nodes },
            |m: &mut Nodes| { &mut m.all_nodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Nodes>(
            "Nodes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Nodes {
    const NAME: &'static str = "Nodes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nodes.push(is.read_message()?);
                },
                18 => {
                    self.channels.push(is.read_message()?);
                },
                26 => {
                    self.all_nodes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.all_nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.all_nodes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Nodes {
        Nodes::new()
    }

    fn clear(&mut self) {
        self.nodes.clear();
        self.channels.clear();
        self.all_nodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Nodes {
        static instance: Nodes = Nodes {
            nodes: ::std::vec::Vec::new(),
            channels: ::std::vec::Vec::new(),
            all_nodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Nodes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Nodes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Nodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Nodes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.AvailableNodes)
pub struct AvailableNodes {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.AvailableNodes.nodes)
    pub nodes: ::std::vec::Vec<AvailableNode>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.AvailableNodes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvailableNodes {
    fn default() -> &'a AvailableNodes {
        <AvailableNodes as ::protobuf::Message>::default_instance()
    }
}

impl AvailableNodes {
    pub fn new() -> AvailableNodes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &AvailableNodes| { &m.nodes },
            |m: &mut AvailableNodes| { &mut m.nodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvailableNodes>(
            "AvailableNodes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvailableNodes {
    const NAME: &'static str = "AvailableNodes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nodes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvailableNodes {
        AvailableNodes::new()
    }

    fn clear(&mut self) {
        self.nodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvailableNodes {
        static instance: AvailableNodes = AvailableNodes {
            nodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AvailableNodes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvailableNodes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvailableNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvailableNodes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.AvailableNode)
pub struct AvailableNode {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.AvailableNode.type)
    pub type_: ::protobuf::EnumOrUnknown<node::NodeType>,
    // @@protoc_insertion_point(field:mizer.nodes.AvailableNode.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.AvailableNode.category)
    pub category: ::protobuf::EnumOrUnknown<NodeCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.AvailableNode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvailableNode {
    fn default() -> &'a AvailableNode {
        <AvailableNode as ::protobuf::Message>::default_instance()
    }
}

impl AvailableNode {
    pub fn new() -> AvailableNode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &AvailableNode| { &m.type_ },
            |m: &mut AvailableNode| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AvailableNode| { &m.name },
            |m: &mut AvailableNode| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "category",
            |m: &AvailableNode| { &m.category },
            |m: &mut AvailableNode| { &mut m.category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvailableNode>(
            "AvailableNode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvailableNode {
    const NAME: &'static str = "AvailableNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::FADER) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.category != ::protobuf::EnumOrUnknown::new(NodeCategory::NODE_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(3, self.category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::FADER) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.category != ::protobuf::EnumOrUnknown::new(NodeCategory::NODE_CATEGORY_NONE) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvailableNode {
        AvailableNode::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(node::NodeType::FADER);
        self.name.clear();
        self.category = ::protobuf::EnumOrUnknown::new(NodeCategory::NODE_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvailableNode {
        static instance: AvailableNode = AvailableNode {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AvailableNode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvailableNode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvailableNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvailableNode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodeConnection)
pub struct NodeConnection {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.target_node)
    pub target_node: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.target_port)
    pub target_port: ::protobuf::MessageField<Port>,
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.source_node)
    pub source_node: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.source_port)
    pub source_port: ::protobuf::MessageField<Port>,
    // @@protoc_insertion_point(field:mizer.nodes.NodeConnection.protocol)
    pub protocol: ::protobuf::EnumOrUnknown<ChannelProtocol>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodeConnection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeConnection {
    fn default() -> &'a NodeConnection {
        <NodeConnection as ::protobuf::Message>::default_instance()
    }
}

impl NodeConnection {
    pub fn new() -> NodeConnection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_node",
            |m: &NodeConnection| { &m.target_node },
            |m: &mut NodeConnection| { &mut m.target_node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Port>(
            "target_port",
            |m: &NodeConnection| { &m.target_port },
            |m: &mut NodeConnection| { &mut m.target_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_node",
            |m: &NodeConnection| { &m.source_node },
            |m: &mut NodeConnection| { &mut m.source_node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Port>(
            "source_port",
            |m: &NodeConnection| { &m.source_port },
            |m: &mut NodeConnection| { &mut m.source_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol",
            |m: &NodeConnection| { &m.protocol },
            |m: &mut NodeConnection| { &mut m.protocol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeConnection>(
            "NodeConnection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeConnection {
    const NAME: &'static str = "NodeConnection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.target_node = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.target_port)?;
                },
                26 => {
                    self.source_node = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source_port)?;
                },
                40 => {
                    self.protocol = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.target_node.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.target_node);
        }
        if let Some(v) = self.target_port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.source_node.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source_node);
        }
        if let Some(v) = self.source_port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE) {
            my_size += ::protobuf::rt::int32_size(5, self.protocol.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.target_node.is_empty() {
            os.write_string(1, &self.target_node)?;
        }
        if let Some(v) = self.target_port.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.source_node.is_empty() {
            os.write_string(3, &self.source_node)?;
        }
        if let Some(v) = self.source_port.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.protocol))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeConnection {
        NodeConnection::new()
    }

    fn clear(&mut self) {
        self.target_node.clear();
        self.target_port.clear();
        self.source_node.clear();
        self.source_port.clear();
        self.protocol = ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeConnection {
        static instance: NodeConnection = NodeConnection {
            target_node: ::std::string::String::new(),
            target_port: ::protobuf::MessageField::none(),
            source_node: ::std::string::String::new(),
            source_port: ::protobuf::MessageField::none(),
            protocol: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeConnection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeConnection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConnection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.Node)
pub struct Node {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.Node.type)
    pub type_: ::protobuf::EnumOrUnknown<node::NodeType>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.Node.inputs)
    pub inputs: ::std::vec::Vec<Port>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.outputs)
    pub outputs: ::std::vec::Vec<Port>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.designer)
    pub designer: ::protobuf::MessageField<NodeDesigner>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.preview)
    pub preview: ::protobuf::EnumOrUnknown<node::NodePreviewType>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.config)
    pub config: ::protobuf::MessageField<NodeConfig>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.settings)
    pub settings: ::std::vec::Vec<NodeSetting>,
    // @@protoc_insertion_point(field:mizer.nodes.Node.details)
    pub details: ::protobuf::MessageField<NodeDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.Node.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Node| { &m.type_ },
            |m: &mut Node| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &Node| { &m.path },
            |m: &mut Node| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inputs",
            |m: &Node| { &m.inputs },
            |m: &mut Node| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &Node| { &m.outputs },
            |m: &mut Node| { &mut m.outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeDesigner>(
            "designer",
            |m: &Node| { &m.designer },
            |m: &mut Node| { &mut m.designer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preview",
            |m: &Node| { &m.preview },
            |m: &mut Node| { &mut m.preview },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeConfig>(
            "config",
            |m: &Node| { &m.config },
            |m: &mut Node| { &mut m.config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "settings",
            |m: &Node| { &m.settings },
            |m: &mut Node| { &mut m.settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodeDetails>(
            "details",
            |m: &Node| { &m.details },
            |m: &mut Node| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Node>(
            "Node",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Node {
    const NAME: &'static str = "Node";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.path = is.read_string()?;
                },
                26 => {
                    self.inputs.push(is.read_message()?);
                },
                34 => {
                    self.outputs.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.designer)?;
                },
                48 => {
                    self.preview = is.read_enum_or_unknown()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                66 => {
                    self.settings.push(is.read_message()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.details)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::FADER) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.designer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.preview != ::protobuf::EnumOrUnknown::new(node::NodePreviewType::NONE) {
            my_size += ::protobuf::rt::int32_size(6, self.preview.value());
        }
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.settings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(node::NodeType::FADER) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        for v in &self.inputs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.designer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.preview != ::protobuf::EnumOrUnknown::new(node::NodePreviewType::NONE) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.preview))?;
        }
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.settings {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Node {
        Node::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(node::NodeType::FADER);
        self.path.clear();
        self.inputs.clear();
        self.outputs.clear();
        self.designer.clear();
        self.preview = ::protobuf::EnumOrUnknown::new(node::NodePreviewType::NONE);
        self.config.clear();
        self.settings.clear();
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Node {
        static instance: Node = Node {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            path: ::std::string::String::new(),
            inputs: ::std::vec::Vec::new(),
            outputs: ::std::vec::Vec::new(),
            designer: ::protobuf::MessageField::none(),
            preview: ::protobuf::EnumOrUnknown::from_i32(0),
            config: ::protobuf::MessageField::none(),
            settings: ::std::vec::Vec::new(),
            details: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Node {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Node").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Node`
pub mod node {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.Node.NodeType)
    pub enum NodeType {
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.FADER)
        FADER = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.BUTTON)
        BUTTON = 1,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.OSCILLATOR)
        OSCILLATOR = 2,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.CLOCK)
        CLOCK = 3,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.SCRIPT)
        SCRIPT = 4,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.ENVELOPE)
        ENVELOPE = 5,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.SEQUENCE)
        SEQUENCE = 6,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.SELECT)
        SELECT = 7,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MERGE)
        MERGE = 8,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.THRESHOLD)
        THRESHOLD = 9,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.DMX_OUTPUT)
        DMX_OUTPUT = 10,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.OSC_INPUT)
        OSC_INPUT = 11,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.OSC_OUTPUT)
        OSC_OUTPUT = 12,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MIDI_INPUT)
        MIDI_INPUT = 13,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MIDI_OUTPUT)
        MIDI_OUTPUT = 14,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.SEQUENCER)
        SEQUENCER = 15,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.FIXTURE)
        FIXTURE = 16,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.PROGRAMMER)
        PROGRAMMER = 17,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.GROUP)
        GROUP = 18,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.PRESET)
        PRESET = 19,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VIDEO_FILE)
        VIDEO_FILE = 20,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VIDEO_OUTPUT)
        VIDEO_OUTPUT = 21,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VIDEO_COLOR_BALANCE)
        VIDEO_COLOR_BALANCE = 23,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VIDEO_TRANSFORM)
        VIDEO_TRANSFORM = 24,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VIDEO_MIXER)
        VIDEO_MIXER = 25,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VIDEO_RGB)
        VIDEO_RGB = 26,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VIDEO_RGB_SPLIT)
        VIDEO_RGB_SPLIT = 27,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.PIXEL_TO_DMX)
        PIXEL_TO_DMX = 30,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.PIXEL_PATTERN)
        PIXEL_PATTERN = 31,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.OPC_OUTPUT)
        OPC_OUTPUT = 32,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.LASER)
        LASER = 40,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.ILDA_FILE)
        ILDA_FILE = 41,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.GAMEPAD)
        GAMEPAD = 45,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.COLOR_RGB)
        COLOR_RGB = 50,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.COLOR_HSV)
        COLOR_HSV = 51,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.COLOR_CONSTANT)
        COLOR_CONSTANT = 52,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.COLOR_BRIGHTNESS)
        COLOR_BRIGHTNESS = 53,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.ENCODER)
        ENCODER = 55,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MATH)
        MATH = 56,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.DATA_TO_NUMBER)
        DATA_TO_NUMBER = 57,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.NUMBER_TO_DATA)
        NUMBER_TO_DATA = 58,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.VALUE)
        VALUE = 59,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.EXTRACT)
        EXTRACT = 60,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MQTT_INPUT)
        MQTT_INPUT = 61,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.MQTT_OUTPUT)
        MQTT_OUTPUT = 62,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.PLAN_SCREEN)
        PLAN_SCREEN = 63,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.DELAY)
        DELAY = 64,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.RAMP)
        RAMP = 65,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.NOISE)
        NOISE = 66,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.LABEL)
        LABEL = 67,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.TRANSPORT)
        TRANSPORT = 68,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.G13INPUT)
        G13INPUT = 69,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.G13OUTPUT)
        G13OUTPUT = 70,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.CONSTANT_NUMBER)
        CONSTANT_NUMBER = 71,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.CONDITIONAL)
        CONDITIONAL = 72,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.TIMECODE_CONTROL)
        TIMECODE_CONTROL = 73,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.TIMECODE_OUTPUT)
        TIMECODE_OUTPUT = 74,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.AUDIO_FILE)
        AUDIO_FILE = 75,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.AUDIO_OUTPUT)
        AUDIO_OUTPUT = 76,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.AUDIO_VOLUME)
        AUDIO_VOLUME = 77,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.AUDIO_INPUT)
        AUDIO_INPUT = 78,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.AUDIO_MIX)
        AUDIO_MIX = 79,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.AUDIO_METER)
        AUDIO_METER = 80,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.TEMPLATE)
        TEMPLATE = 81,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodeType.CONTAINER)
        CONTAINER = 100,
    }

    impl ::protobuf::Enum for NodeType {
        const NAME: &'static str = "NodeType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NodeType> {
            match value {
                0 => ::std::option::Option::Some(NodeType::FADER),
                1 => ::std::option::Option::Some(NodeType::BUTTON),
                2 => ::std::option::Option::Some(NodeType::OSCILLATOR),
                3 => ::std::option::Option::Some(NodeType::CLOCK),
                4 => ::std::option::Option::Some(NodeType::SCRIPT),
                5 => ::std::option::Option::Some(NodeType::ENVELOPE),
                6 => ::std::option::Option::Some(NodeType::SEQUENCE),
                7 => ::std::option::Option::Some(NodeType::SELECT),
                8 => ::std::option::Option::Some(NodeType::MERGE),
                9 => ::std::option::Option::Some(NodeType::THRESHOLD),
                10 => ::std::option::Option::Some(NodeType::DMX_OUTPUT),
                11 => ::std::option::Option::Some(NodeType::OSC_INPUT),
                12 => ::std::option::Option::Some(NodeType::OSC_OUTPUT),
                13 => ::std::option::Option::Some(NodeType::MIDI_INPUT),
                14 => ::std::option::Option::Some(NodeType::MIDI_OUTPUT),
                15 => ::std::option::Option::Some(NodeType::SEQUENCER),
                16 => ::std::option::Option::Some(NodeType::FIXTURE),
                17 => ::std::option::Option::Some(NodeType::PROGRAMMER),
                18 => ::std::option::Option::Some(NodeType::GROUP),
                19 => ::std::option::Option::Some(NodeType::PRESET),
                20 => ::std::option::Option::Some(NodeType::VIDEO_FILE),
                21 => ::std::option::Option::Some(NodeType::VIDEO_OUTPUT),
                23 => ::std::option::Option::Some(NodeType::VIDEO_COLOR_BALANCE),
                24 => ::std::option::Option::Some(NodeType::VIDEO_TRANSFORM),
                25 => ::std::option::Option::Some(NodeType::VIDEO_MIXER),
                26 => ::std::option::Option::Some(NodeType::VIDEO_RGB),
                27 => ::std::option::Option::Some(NodeType::VIDEO_RGB_SPLIT),
                30 => ::std::option::Option::Some(NodeType::PIXEL_TO_DMX),
                31 => ::std::option::Option::Some(NodeType::PIXEL_PATTERN),
                32 => ::std::option::Option::Some(NodeType::OPC_OUTPUT),
                40 => ::std::option::Option::Some(NodeType::LASER),
                41 => ::std::option::Option::Some(NodeType::ILDA_FILE),
                45 => ::std::option::Option::Some(NodeType::GAMEPAD),
                50 => ::std::option::Option::Some(NodeType::COLOR_RGB),
                51 => ::std::option::Option::Some(NodeType::COLOR_HSV),
                52 => ::std::option::Option::Some(NodeType::COLOR_CONSTANT),
                53 => ::std::option::Option::Some(NodeType::COLOR_BRIGHTNESS),
                55 => ::std::option::Option::Some(NodeType::ENCODER),
                56 => ::std::option::Option::Some(NodeType::MATH),
                57 => ::std::option::Option::Some(NodeType::DATA_TO_NUMBER),
                58 => ::std::option::Option::Some(NodeType::NUMBER_TO_DATA),
                59 => ::std::option::Option::Some(NodeType::VALUE),
                60 => ::std::option::Option::Some(NodeType::EXTRACT),
                61 => ::std::option::Option::Some(NodeType::MQTT_INPUT),
                62 => ::std::option::Option::Some(NodeType::MQTT_OUTPUT),
                63 => ::std::option::Option::Some(NodeType::PLAN_SCREEN),
                64 => ::std::option::Option::Some(NodeType::DELAY),
                65 => ::std::option::Option::Some(NodeType::RAMP),
                66 => ::std::option::Option::Some(NodeType::NOISE),
                67 => ::std::option::Option::Some(NodeType::LABEL),
                68 => ::std::option::Option::Some(NodeType::TRANSPORT),
                69 => ::std::option::Option::Some(NodeType::G13INPUT),
                70 => ::std::option::Option::Some(NodeType::G13OUTPUT),
                71 => ::std::option::Option::Some(NodeType::CONSTANT_NUMBER),
                72 => ::std::option::Option::Some(NodeType::CONDITIONAL),
                73 => ::std::option::Option::Some(NodeType::TIMECODE_CONTROL),
                74 => ::std::option::Option::Some(NodeType::TIMECODE_OUTPUT),
                75 => ::std::option::Option::Some(NodeType::AUDIO_FILE),
                76 => ::std::option::Option::Some(NodeType::AUDIO_OUTPUT),
                77 => ::std::option::Option::Some(NodeType::AUDIO_VOLUME),
                78 => ::std::option::Option::Some(NodeType::AUDIO_INPUT),
                79 => ::std::option::Option::Some(NodeType::AUDIO_MIX),
                80 => ::std::option::Option::Some(NodeType::AUDIO_METER),
                81 => ::std::option::Option::Some(NodeType::TEMPLATE),
                100 => ::std::option::Option::Some(NodeType::CONTAINER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NodeType] = &[
            NodeType::FADER,
            NodeType::BUTTON,
            NodeType::OSCILLATOR,
            NodeType::CLOCK,
            NodeType::SCRIPT,
            NodeType::ENVELOPE,
            NodeType::SEQUENCE,
            NodeType::SELECT,
            NodeType::MERGE,
            NodeType::THRESHOLD,
            NodeType::DMX_OUTPUT,
            NodeType::OSC_INPUT,
            NodeType::OSC_OUTPUT,
            NodeType::MIDI_INPUT,
            NodeType::MIDI_OUTPUT,
            NodeType::SEQUENCER,
            NodeType::FIXTURE,
            NodeType::PROGRAMMER,
            NodeType::GROUP,
            NodeType::PRESET,
            NodeType::VIDEO_FILE,
            NodeType::VIDEO_OUTPUT,
            NodeType::VIDEO_COLOR_BALANCE,
            NodeType::VIDEO_TRANSFORM,
            NodeType::VIDEO_MIXER,
            NodeType::VIDEO_RGB,
            NodeType::VIDEO_RGB_SPLIT,
            NodeType::PIXEL_TO_DMX,
            NodeType::PIXEL_PATTERN,
            NodeType::OPC_OUTPUT,
            NodeType::LASER,
            NodeType::ILDA_FILE,
            NodeType::GAMEPAD,
            NodeType::COLOR_RGB,
            NodeType::COLOR_HSV,
            NodeType::COLOR_CONSTANT,
            NodeType::COLOR_BRIGHTNESS,
            NodeType::ENCODER,
            NodeType::MATH,
            NodeType::DATA_TO_NUMBER,
            NodeType::NUMBER_TO_DATA,
            NodeType::VALUE,
            NodeType::EXTRACT,
            NodeType::MQTT_INPUT,
            NodeType::MQTT_OUTPUT,
            NodeType::PLAN_SCREEN,
            NodeType::DELAY,
            NodeType::RAMP,
            NodeType::NOISE,
            NodeType::LABEL,
            NodeType::TRANSPORT,
            NodeType::G13INPUT,
            NodeType::G13OUTPUT,
            NodeType::CONSTANT_NUMBER,
            NodeType::CONDITIONAL,
            NodeType::TIMECODE_CONTROL,
            NodeType::TIMECODE_OUTPUT,
            NodeType::AUDIO_FILE,
            NodeType::AUDIO_OUTPUT,
            NodeType::AUDIO_VOLUME,
            NodeType::AUDIO_INPUT,
            NodeType::AUDIO_MIX,
            NodeType::AUDIO_METER,
            NodeType::TEMPLATE,
            NodeType::CONTAINER,
        ];
    }

    impl ::protobuf::EnumFull for NodeType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Node.NodeType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                NodeType::FADER => 0,
                NodeType::BUTTON => 1,
                NodeType::OSCILLATOR => 2,
                NodeType::CLOCK => 3,
                NodeType::SCRIPT => 4,
                NodeType::ENVELOPE => 5,
                NodeType::SEQUENCE => 6,
                NodeType::SELECT => 7,
                NodeType::MERGE => 8,
                NodeType::THRESHOLD => 9,
                NodeType::DMX_OUTPUT => 10,
                NodeType::OSC_INPUT => 11,
                NodeType::OSC_OUTPUT => 12,
                NodeType::MIDI_INPUT => 13,
                NodeType::MIDI_OUTPUT => 14,
                NodeType::SEQUENCER => 15,
                NodeType::FIXTURE => 16,
                NodeType::PROGRAMMER => 17,
                NodeType::GROUP => 18,
                NodeType::PRESET => 19,
                NodeType::VIDEO_FILE => 20,
                NodeType::VIDEO_OUTPUT => 21,
                NodeType::VIDEO_COLOR_BALANCE => 22,
                NodeType::VIDEO_TRANSFORM => 23,
                NodeType::VIDEO_MIXER => 24,
                NodeType::VIDEO_RGB => 25,
                NodeType::VIDEO_RGB_SPLIT => 26,
                NodeType::PIXEL_TO_DMX => 27,
                NodeType::PIXEL_PATTERN => 28,
                NodeType::OPC_OUTPUT => 29,
                NodeType::LASER => 30,
                NodeType::ILDA_FILE => 31,
                NodeType::GAMEPAD => 32,
                NodeType::COLOR_RGB => 33,
                NodeType::COLOR_HSV => 34,
                NodeType::COLOR_CONSTANT => 35,
                NodeType::COLOR_BRIGHTNESS => 36,
                NodeType::ENCODER => 37,
                NodeType::MATH => 38,
                NodeType::DATA_TO_NUMBER => 39,
                NodeType::NUMBER_TO_DATA => 40,
                NodeType::VALUE => 41,
                NodeType::EXTRACT => 42,
                NodeType::MQTT_INPUT => 43,
                NodeType::MQTT_OUTPUT => 44,
                NodeType::PLAN_SCREEN => 45,
                NodeType::DELAY => 46,
                NodeType::RAMP => 47,
                NodeType::NOISE => 48,
                NodeType::LABEL => 49,
                NodeType::TRANSPORT => 50,
                NodeType::G13INPUT => 51,
                NodeType::G13OUTPUT => 52,
                NodeType::CONSTANT_NUMBER => 53,
                NodeType::CONDITIONAL => 54,
                NodeType::TIMECODE_CONTROL => 55,
                NodeType::TIMECODE_OUTPUT => 56,
                NodeType::AUDIO_FILE => 57,
                NodeType::AUDIO_OUTPUT => 58,
                NodeType::AUDIO_VOLUME => 59,
                NodeType::AUDIO_INPUT => 60,
                NodeType::AUDIO_MIX => 61,
                NodeType::AUDIO_METER => 62,
                NodeType::TEMPLATE => 63,
                NodeType::CONTAINER => 64,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for NodeType {
        fn default() -> Self {
            NodeType::FADER
        }
    }

    impl NodeType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NodeType>("Node.NodeType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mizer.nodes.Node.NodePreviewType)
    pub enum NodePreviewType {
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.HISTORY)
        HISTORY = 1,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.WAVEFORM)
        WAVEFORM = 2,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.MULTIPLE)
        MULTIPLE = 3,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.TEXTURE)
        TEXTURE = 4,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.TIMECODE)
        TIMECODE = 5,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.DATA)
        DATA = 6,
        // @@protoc_insertion_point(enum_value:mizer.nodes.Node.NodePreviewType.COLOR)
        COLOR = 7,
    }

    impl ::protobuf::Enum for NodePreviewType {
        const NAME: &'static str = "NodePreviewType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NodePreviewType> {
            match value {
                0 => ::std::option::Option::Some(NodePreviewType::NONE),
                1 => ::std::option::Option::Some(NodePreviewType::HISTORY),
                2 => ::std::option::Option::Some(NodePreviewType::WAVEFORM),
                3 => ::std::option::Option::Some(NodePreviewType::MULTIPLE),
                4 => ::std::option::Option::Some(NodePreviewType::TEXTURE),
                5 => ::std::option::Option::Some(NodePreviewType::TIMECODE),
                6 => ::std::option::Option::Some(NodePreviewType::DATA),
                7 => ::std::option::Option::Some(NodePreviewType::COLOR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NodePreviewType] = &[
            NodePreviewType::NONE,
            NodePreviewType::HISTORY,
            NodePreviewType::WAVEFORM,
            NodePreviewType::MULTIPLE,
            NodePreviewType::TEXTURE,
            NodePreviewType::TIMECODE,
            NodePreviewType::DATA,
            NodePreviewType::COLOR,
        ];
    }

    impl ::protobuf::EnumFull for NodePreviewType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Node.NodePreviewType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for NodePreviewType {
        fn default() -> Self {
            NodePreviewType::NONE
        }
    }

    impl NodePreviewType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NodePreviewType>("Node.NodePreviewType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodeDetails)
pub struct NodeDetails {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.NodeDetails.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.NodeDetails.category)
    pub category: ::protobuf::EnumOrUnknown<NodeCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodeDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeDetails {
    fn default() -> &'a NodeDetails {
        <NodeDetails as ::protobuf::Message>::default_instance()
    }
}

impl NodeDetails {
    pub fn new() -> NodeDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &NodeDetails| { &m.name },
            |m: &mut NodeDetails| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "category",
            |m: &NodeDetails| { &m.category },
            |m: &mut NodeDetails| { &mut m.category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeDetails>(
            "NodeDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeDetails {
    const NAME: &'static str = "NodeDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.category != ::protobuf::EnumOrUnknown::new(NodeCategory::NODE_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.category != ::protobuf::EnumOrUnknown::new(NodeCategory::NODE_CATEGORY_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeDetails {
        NodeDetails::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.category = ::protobuf::EnumOrUnknown::new(NodeCategory::NODE_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeDetails {
        static instance: NodeDetails = NodeDetails {
            name: ::std::string::String::new(),
            category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodeConfig)
pub struct NodeConfig {
    // message oneof groups
    pub type_: ::std::option::Option<node_config::Type>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeConfig {
    fn default() -> &'a NodeConfig {
        <NodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl NodeConfig {
    pub fn new() -> NodeConfig {
        ::std::default::Default::default()
    }

    // .mizer.nodes.ContainerNodeConfig container_config = 45;

    pub fn container_config(&self) -> &ContainerNodeConfig {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ContainerConfig(ref v)) => v,
            _ => <ContainerNodeConfig as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_container_config(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_container_config(&self) -> bool {
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ContainerConfig(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_container_config(&mut self, v: ContainerNodeConfig) {
        self.type_ = ::std::option::Option::Some(node_config::Type::ContainerConfig(v))
    }

    // Mutable pointer to the field.
    pub fn mut_container_config(&mut self) -> &mut ContainerNodeConfig {
        if let ::std::option::Option::Some(node_config::Type::ContainerConfig(_)) = self.type_ {
        } else {
            self.type_ = ::std::option::Option::Some(node_config::Type::ContainerConfig(ContainerNodeConfig::new()));
        }
        match self.type_ {
            ::std::option::Option::Some(node_config::Type::ContainerConfig(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_container_config(&mut self) -> ContainerNodeConfig {
        if self.has_container_config() {
            match self.type_.take() {
                ::std::option::Option::Some(node_config::Type::ContainerConfig(v)) => v,
                _ => panic!(),
            }
        } else {
            ContainerNodeConfig::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ContainerNodeConfig>(
            "container_config",
            NodeConfig::has_container_config,
            NodeConfig::container_config,
            NodeConfig::mut_container_config,
            NodeConfig::set_container_config,
        ));
        oneofs.push(node_config::Type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeConfig>(
            "NodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeConfig {
    const NAME: &'static str = "NodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                362 => {
                    self.type_ = ::std::option::Option::Some(node_config::Type::ContainerConfig(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.type_ {
            match v {
                &node_config::Type::ContainerConfig(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.type_ {
            match v {
                &node_config::Type::ContainerConfig(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeConfig {
        NodeConfig::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeConfig {
        static instance: NodeConfig = NodeConfig {
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NodeConfig`
pub mod node_config {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.nodes.NodeConfig.type)
    pub enum Type {
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeConfig.container_config)
        ContainerConfig(super::ContainerNodeConfig),
    }

    impl ::protobuf::Oneof for Type {
    }

    impl ::protobuf::OneofFull for Type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::NodeConfig as ::protobuf::MessageFull>::descriptor().oneof_by_name("type").unwrap()).clone()
        }
    }

    impl Type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Type>("type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodeSetting)
pub struct NodeSetting {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.disabled)
    pub disabled: bool,
    // message oneof groups
    pub value: ::std::option::Option<node_setting::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeSetting {
    fn default() -> &'a NodeSetting {
        <NodeSetting as ::protobuf::Message>::default_instance()
    }
}

impl NodeSetting {
    pub fn new() -> NodeSetting {
        ::std::default::Default::default()
    }

    // .mizer.nodes.NodeSetting.TextValue text = 4;

    pub fn text(&self) -> &node_setting::TextValue {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Text(ref v)) => v,
            _ => <node_setting::TextValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_text(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: node_setting::TextValue) {
        self.value = ::std::option::Option::Some(node_setting::Value::Text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut node_setting::TextValue {
        if let ::std::option::Option::Some(node_setting::Value::Text(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(node_setting::Value::Text(node_setting::TextValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> node_setting::TextValue {
        if self.has_text() {
            match self.value.take() {
                ::std::option::Option::Some(node_setting::Value::Text(v)) => v,
                _ => panic!(),
            }
        } else {
            node_setting::TextValue::new()
        }
    }

    // .mizer.nodes.NodeSetting.FloatValue float = 5;

    pub fn float(&self) -> &node_setting::FloatValue {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Float(ref v)) => v,
            _ => <node_setting::FloatValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_float(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: node_setting::FloatValue) {
        self.value = ::std::option::Option::Some(node_setting::Value::Float(v))
    }

    // Mutable pointer to the field.
    pub fn mut_float(&mut self) -> &mut node_setting::FloatValue {
        if let ::std::option::Option::Some(node_setting::Value::Float(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(node_setting::Value::Float(node_setting::FloatValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Float(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_float(&mut self) -> node_setting::FloatValue {
        if self.has_float() {
            match self.value.take() {
                ::std::option::Option::Some(node_setting::Value::Float(v)) => v,
                _ => panic!(),
            }
        } else {
            node_setting::FloatValue::new()
        }
    }

    // .mizer.nodes.NodeSetting.IntValue int = 6;

    pub fn int(&self) -> &node_setting::IntValue {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Int(ref v)) => v,
            _ => <node_setting::IntValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_int(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int(&mut self, v: node_setting::IntValue) {
        self.value = ::std::option::Option::Some(node_setting::Value::Int(v))
    }

    // Mutable pointer to the field.
    pub fn mut_int(&mut self) -> &mut node_setting::IntValue {
        if let ::std::option::Option::Some(node_setting::Value::Int(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(node_setting::Value::Int(node_setting::IntValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Int(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_int(&mut self) -> node_setting::IntValue {
        if self.has_int() {
            match self.value.take() {
                ::std::option::Option::Some(node_setting::Value::Int(v)) => v,
                _ => panic!(),
            }
        } else {
            node_setting::IntValue::new()
        }
    }

    // .mizer.nodes.NodeSetting.BoolValue bool = 7;

    pub fn bool(&self) -> &node_setting::BoolValue {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Bool(ref v)) => v,
            _ => <node_setting::BoolValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bool(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: node_setting::BoolValue) {
        self.value = ::std::option::Option::Some(node_setting::Value::Bool(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bool(&mut self) -> &mut node_setting::BoolValue {
        if let ::std::option::Option::Some(node_setting::Value::Bool(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(node_setting::Value::Bool(node_setting::BoolValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Bool(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bool(&mut self) -> node_setting::BoolValue {
        if self.has_bool() {
            match self.value.take() {
                ::std::option::Option::Some(node_setting::Value::Bool(v)) => v,
                _ => panic!(),
            }
        } else {
            node_setting::BoolValue::new()
        }
    }

    // .mizer.nodes.NodeSetting.SelectValue select = 8;

    pub fn select(&self) -> &node_setting::SelectValue {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Select(ref v)) => v,
            _ => <node_setting::SelectValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_select(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_select(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Select(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select(&mut self, v: node_setting::SelectValue) {
        self.value = ::std::option::Option::Some(node_setting::Value::Select(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select(&mut self) -> &mut node_setting::SelectValue {
        if let ::std::option::Option::Some(node_setting::Value::Select(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(node_setting::Value::Select(node_setting::SelectValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Select(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select(&mut self) -> node_setting::SelectValue {
        if self.has_select() {
            match self.value.take() {
                ::std::option::Option::Some(node_setting::Value::Select(v)) => v,
                _ => panic!(),
            }
        } else {
            node_setting::SelectValue::new()
        }
    }

    // .mizer.nodes.NodeSetting.EnumValue enum = 9;

    pub fn enum_(&self) -> &node_setting::EnumValue {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Enum(ref v)) => v,
            _ => <node_setting::EnumValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_enum_(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_enum(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Enum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enum(&mut self, v: node_setting::EnumValue) {
        self.value = ::std::option::Option::Some(node_setting::Value::Enum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enum(&mut self) -> &mut node_setting::EnumValue {
        if let ::std::option::Option::Some(node_setting::Value::Enum(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(node_setting::Value::Enum(node_setting::EnumValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Enum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enum_(&mut self) -> node_setting::EnumValue {
        if self.has_enum() {
            match self.value.take() {
                ::std::option::Option::Some(node_setting::Value::Enum(v)) => v,
                _ => panic!(),
            }
        } else {
            node_setting::EnumValue::new()
        }
    }

    // .mizer.nodes.NodeSetting.IdValue id = 10;

    pub fn id(&self) -> &node_setting::IdValue {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Id(ref v)) => v,
            _ => <node_setting::IdValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_id(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: node_setting::IdValue) {
        self.value = ::std::option::Option::Some(node_setting::Value::Id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut node_setting::IdValue {
        if let ::std::option::Option::Some(node_setting::Value::Id(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(node_setting::Value::Id(node_setting::IdValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> node_setting::IdValue {
        if self.has_id() {
            match self.value.take() {
                ::std::option::Option::Some(node_setting::Value::Id(v)) => v,
                _ => panic!(),
            }
        } else {
            node_setting::IdValue::new()
        }
    }

    // .mizer.nodes.NodeSetting.SplineValue spline = 11;

    pub fn spline(&self) -> &node_setting::SplineValue {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Spline(ref v)) => v,
            _ => <node_setting::SplineValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_spline(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_spline(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Spline(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_spline(&mut self, v: node_setting::SplineValue) {
        self.value = ::std::option::Option::Some(node_setting::Value::Spline(v))
    }

    // Mutable pointer to the field.
    pub fn mut_spline(&mut self) -> &mut node_setting::SplineValue {
        if let ::std::option::Option::Some(node_setting::Value::Spline(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(node_setting::Value::Spline(node_setting::SplineValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Spline(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_spline(&mut self) -> node_setting::SplineValue {
        if self.has_spline() {
            match self.value.take() {
                ::std::option::Option::Some(node_setting::Value::Spline(v)) => v,
                _ => panic!(),
            }
        } else {
            node_setting::SplineValue::new()
        }
    }

    // .mizer.nodes.NodeSetting.MediaValue media = 12;

    pub fn media(&self) -> &node_setting::MediaValue {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Media(ref v)) => v,
            _ => <node_setting::MediaValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_media(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Media(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: node_setting::MediaValue) {
        self.value = ::std::option::Option::Some(node_setting::Value::Media(v))
    }

    // Mutable pointer to the field.
    pub fn mut_media(&mut self) -> &mut node_setting::MediaValue {
        if let ::std::option::Option::Some(node_setting::Value::Media(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(node_setting::Value::Media(node_setting::MediaValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(node_setting::Value::Media(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_media(&mut self) -> node_setting::MediaValue {
        if self.has_media() {
            match self.value.take() {
                ::std::option::Option::Some(node_setting::Value::Media(v)) => v,
                _ => panic!(),
            }
        } else {
            node_setting::MediaValue::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &NodeSetting| { &m.label },
            |m: &mut NodeSetting| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &NodeSetting| { &m.description },
            |m: &mut NodeSetting| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled",
            |m: &NodeSetting| { &m.disabled },
            |m: &mut NodeSetting| { &mut m.disabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, node_setting::TextValue>(
            "text",
            NodeSetting::has_text,
            NodeSetting::text,
            NodeSetting::mut_text,
            NodeSetting::set_text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, node_setting::FloatValue>(
            "float",
            NodeSetting::has_float,
            NodeSetting::float,
            NodeSetting::mut_float,
            NodeSetting::set_float,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, node_setting::IntValue>(
            "int",
            NodeSetting::has_int,
            NodeSetting::int,
            NodeSetting::mut_int,
            NodeSetting::set_int,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, node_setting::BoolValue>(
            "bool",
            NodeSetting::has_bool,
            NodeSetting::bool,
            NodeSetting::mut_bool,
            NodeSetting::set_bool,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, node_setting::SelectValue>(
            "select",
            NodeSetting::has_select,
            NodeSetting::select,
            NodeSetting::mut_select,
            NodeSetting::set_select,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, node_setting::EnumValue>(
            "enum",
            NodeSetting::has_enum,
            NodeSetting::enum_,
            NodeSetting::mut_enum,
            NodeSetting::set_enum,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, node_setting::IdValue>(
            "id",
            NodeSetting::has_id,
            NodeSetting::id,
            NodeSetting::mut_id,
            NodeSetting::set_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, node_setting::SplineValue>(
            "spline",
            NodeSetting::has_spline,
            NodeSetting::spline,
            NodeSetting::mut_spline,
            NodeSetting::set_spline,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, node_setting::MediaValue>(
            "media",
            NodeSetting::has_media,
            NodeSetting::media,
            NodeSetting::mut_media,
            NodeSetting::set_media,
        ));
        oneofs.push(node_setting::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeSetting>(
            "NodeSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeSetting {
    const NAME: &'static str = "NodeSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                24 => {
                    self.disabled = is.read_bool()?;
                },
                34 => {
                    self.value = ::std::option::Option::Some(node_setting::Value::Text(is.read_message()?));
                },
                42 => {
                    self.value = ::std::option::Option::Some(node_setting::Value::Float(is.read_message()?));
                },
                50 => {
                    self.value = ::std::option::Option::Some(node_setting::Value::Int(is.read_message()?));
                },
                58 => {
                    self.value = ::std::option::Option::Some(node_setting::Value::Bool(is.read_message()?));
                },
                66 => {
                    self.value = ::std::option::Option::Some(node_setting::Value::Select(is.read_message()?));
                },
                74 => {
                    self.value = ::std::option::Option::Some(node_setting::Value::Enum(is.read_message()?));
                },
                82 => {
                    self.value = ::std::option::Option::Some(node_setting::Value::Id(is.read_message()?));
                },
                90 => {
                    self.value = ::std::option::Option::Some(node_setting::Value::Spline(is.read_message()?));
                },
                98 => {
                    self.value = ::std::option::Option::Some(node_setting::Value::Media(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.disabled != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &node_setting::Value::Text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_setting::Value::Float(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_setting::Value::Int(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_setting::Value::Bool(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_setting::Value::Select(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_setting::Value::Enum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_setting::Value::Id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_setting::Value::Spline(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &node_setting::Value::Media(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.disabled != false {
            os.write_bool(3, self.disabled)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &node_setting::Value::Text(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &node_setting::Value::Float(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &node_setting::Value::Int(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &node_setting::Value::Bool(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &node_setting::Value::Select(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &node_setting::Value::Enum(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &node_setting::Value::Id(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &node_setting::Value::Spline(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &node_setting::Value::Media(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeSetting {
        NodeSetting::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.description.clear();
        self.disabled = false;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeSetting {
        static instance: NodeSetting = NodeSetting {
            label: ::std::string::String::new(),
            description: ::std::string::String::new(),
            disabled: false,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NodeSetting`
pub mod node_setting {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.nodes.NodeSetting.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.text)
        Text(TextValue),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.float)
        Float(FloatValue),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.int)
        Int(IntValue),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.bool)
        Bool(BoolValue),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.select)
        Select(SelectValue),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.enum)
        Enum(EnumValue),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.id)
        Id(IdValue),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.spline)
        Spline(SplineValue),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.media)
        Media(MediaValue),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::NodeSetting as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.TextValue)
    pub struct TextValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.TextValue.value)
        pub value: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.TextValue.multiline)
        pub multiline: bool,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.TextValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextValue {
        fn default() -> &'a TextValue {
            <TextValue as ::protobuf::Message>::default_instance()
        }
    }

    impl TextValue {
        pub fn new() -> TextValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &TextValue| { &m.value },
                |m: &mut TextValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "multiline",
                |m: &TextValue| { &m.multiline },
                |m: &mut TextValue| { &mut m.multiline },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextValue>(
                "NodeSetting.TextValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TextValue {
        const NAME: &'static str = "TextValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.value = is.read_string()?;
                    },
                    16 => {
                        self.multiline = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.value.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.value);
            }
            if self.multiline != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.value.is_empty() {
                os.write_string(1, &self.value)?;
            }
            if self.multiline != false {
                os.write_bool(2, self.multiline)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextValue {
            TextValue::new()
        }

        fn clear(&mut self) {
            self.value.clear();
            self.multiline = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextValue {
            static instance: TextValue = TextValue {
                value: ::std::string::String::new(),
                multiline: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TextValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.TextValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TextValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TextValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.FloatValue)
    pub struct FloatValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.FloatValue.value)
        pub value: f64,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.FloatValue.min)
        pub min: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.FloatValue.min_hint)
        pub min_hint: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.FloatValue.max)
        pub max: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.FloatValue.max_hint)
        pub max_hint: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.FloatValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FloatValue {
        fn default() -> &'a FloatValue {
            <FloatValue as ::protobuf::Message>::default_instance()
        }
    }

    impl FloatValue {
        pub fn new() -> FloatValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &FloatValue| { &m.value },
                |m: &mut FloatValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "min",
                |m: &FloatValue| { &m.min },
                |m: &mut FloatValue| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "min_hint",
                |m: &FloatValue| { &m.min_hint },
                |m: &mut FloatValue| { &mut m.min_hint },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max",
                |m: &FloatValue| { &m.max },
                |m: &mut FloatValue| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_hint",
                |m: &FloatValue| { &m.max_hint },
                |m: &mut FloatValue| { &mut m.max_hint },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FloatValue>(
                "NodeSetting.FloatValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FloatValue {
        const NAME: &'static str = "FloatValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.value = is.read_double()?;
                    },
                    17 => {
                        self.min = ::std::option::Option::Some(is.read_double()?);
                    },
                    25 => {
                        self.min_hint = ::std::option::Option::Some(is.read_double()?);
                    },
                    33 => {
                        self.max = ::std::option::Option::Some(is.read_double()?);
                    },
                    41 => {
                        self.max_hint = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.value != 0. {
                my_size += 1 + 8;
            }
            if let Some(v) = self.min {
                my_size += 1 + 8;
            }
            if let Some(v) = self.min_hint {
                my_size += 1 + 8;
            }
            if let Some(v) = self.max {
                my_size += 1 + 8;
            }
            if let Some(v) = self.max_hint {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.value != 0. {
                os.write_double(1, self.value)?;
            }
            if let Some(v) = self.min {
                os.write_double(2, v)?;
            }
            if let Some(v) = self.min_hint {
                os.write_double(3, v)?;
            }
            if let Some(v) = self.max {
                os.write_double(4, v)?;
            }
            if let Some(v) = self.max_hint {
                os.write_double(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FloatValue {
            FloatValue::new()
        }

        fn clear(&mut self) {
            self.value = 0.;
            self.min = ::std::option::Option::None;
            self.min_hint = ::std::option::Option::None;
            self.max = ::std::option::Option::None;
            self.max_hint = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FloatValue {
            static instance: FloatValue = FloatValue {
                value: 0.,
                min: ::std::option::Option::None,
                min_hint: ::std::option::Option::None,
                max: ::std::option::Option::None,
                max_hint: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FloatValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.FloatValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FloatValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FloatValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.IntValue)
    pub struct IntValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.IntValue.value)
        pub value: u32,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.IntValue.min)
        pub min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.IntValue.min_hint)
        pub min_hint: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.IntValue.max)
        pub max: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.IntValue.max_hint)
        pub max_hint: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.IntValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IntValue {
        fn default() -> &'a IntValue {
            <IntValue as ::protobuf::Message>::default_instance()
        }
    }

    impl IntValue {
        pub fn new() -> IntValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &IntValue| { &m.value },
                |m: &mut IntValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "min",
                |m: &IntValue| { &m.min },
                |m: &mut IntValue| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "min_hint",
                |m: &IntValue| { &m.min_hint },
                |m: &mut IntValue| { &mut m.min_hint },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max",
                |m: &IntValue| { &m.max },
                |m: &mut IntValue| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_hint",
                |m: &IntValue| { &m.max_hint },
                |m: &mut IntValue| { &mut m.max_hint },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IntValue>(
                "NodeSetting.IntValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for IntValue {
        const NAME: &'static str = "IntValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.value = is.read_uint32()?;
                    },
                    16 => {
                        self.min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.min_hint = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.max = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.max_hint = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.value != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.value);
            }
            if let Some(v) = self.min {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.min_hint {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.max {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.max_hint {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.value != 0 {
                os.write_uint32(1, self.value)?;
            }
            if let Some(v) = self.min {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.min_hint {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.max {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.max_hint {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IntValue {
            IntValue::new()
        }

        fn clear(&mut self) {
            self.value = 0;
            self.min = ::std::option::Option::None;
            self.min_hint = ::std::option::Option::None;
            self.max = ::std::option::Option::None;
            self.max_hint = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IntValue {
            static instance: IntValue = IntValue {
                value: 0,
                min: ::std::option::Option::None,
                min_hint: ::std::option::Option::None,
                max: ::std::option::Option::None,
                max_hint: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for IntValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.IntValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for IntValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for IntValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.BoolValue)
    pub struct BoolValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.BoolValue.value)
        pub value: bool,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.BoolValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BoolValue {
        fn default() -> &'a BoolValue {
            <BoolValue as ::protobuf::Message>::default_instance()
        }
    }

    impl BoolValue {
        pub fn new() -> BoolValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &BoolValue| { &m.value },
                |m: &mut BoolValue| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BoolValue>(
                "NodeSetting.BoolValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BoolValue {
        const NAME: &'static str = "BoolValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.value = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.value != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.value != false {
                os.write_bool(1, self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BoolValue {
            BoolValue::new()
        }

        fn clear(&mut self) {
            self.value = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BoolValue {
            static instance: BoolValue = BoolValue {
                value: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BoolValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.BoolValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BoolValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BoolValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.SelectValue)
    pub struct SelectValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SelectValue.value)
        pub value: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SelectValue.variants)
        pub variants: ::std::vec::Vec<SelectVariant>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.SelectValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SelectValue {
        fn default() -> &'a SelectValue {
            <SelectValue as ::protobuf::Message>::default_instance()
        }
    }

    impl SelectValue {
        pub fn new() -> SelectValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &SelectValue| { &m.value },
                |m: &mut SelectValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "variants",
                |m: &SelectValue| { &m.variants },
                |m: &mut SelectValue| { &mut m.variants },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectValue>(
                "NodeSetting.SelectValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SelectValue {
        const NAME: &'static str = "SelectValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.value = is.read_string()?;
                    },
                    18 => {
                        self.variants.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.value.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.value);
            }
            for value in &self.variants {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.value.is_empty() {
                os.write_string(1, &self.value)?;
            }
            for v in &self.variants {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SelectValue {
            SelectValue::new()
        }

        fn clear(&mut self) {
            self.value.clear();
            self.variants.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SelectValue {
            static instance: SelectValue = SelectValue {
                value: ::std::string::String::new(),
                variants: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SelectValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.SelectValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SelectValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SelectValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.SelectVariant)
    pub struct SelectVariant {
        // message oneof groups
        pub variant: ::std::option::Option<select_variant::Variant>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.SelectVariant.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SelectVariant {
        fn default() -> &'a SelectVariant {
            <SelectVariant as ::protobuf::Message>::default_instance()
        }
    }

    impl SelectVariant {
        pub fn new() -> SelectVariant {
            ::std::default::Default::default()
        }

        // .mizer.nodes.NodeSetting.SelectVariant.SelectGroup group = 1;

        pub fn group(&self) -> &select_variant::SelectGroup {
            match self.variant {
                ::std::option::Option::Some(select_variant::Variant::Group(ref v)) => v,
                _ => <select_variant::SelectGroup as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_group(&mut self) {
            self.variant = ::std::option::Option::None;
        }

        pub fn has_group(&self) -> bool {
            match self.variant {
                ::std::option::Option::Some(select_variant::Variant::Group(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_group(&mut self, v: select_variant::SelectGroup) {
            self.variant = ::std::option::Option::Some(select_variant::Variant::Group(v))
        }

        // Mutable pointer to the field.
        pub fn mut_group(&mut self) -> &mut select_variant::SelectGroup {
            if let ::std::option::Option::Some(select_variant::Variant::Group(_)) = self.variant {
            } else {
                self.variant = ::std::option::Option::Some(select_variant::Variant::Group(select_variant::SelectGroup::new()));
            }
            match self.variant {
                ::std::option::Option::Some(select_variant::Variant::Group(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_group(&mut self) -> select_variant::SelectGroup {
            if self.has_group() {
                match self.variant.take() {
                    ::std::option::Option::Some(select_variant::Variant::Group(v)) => v,
                    _ => panic!(),
                }
            } else {
                select_variant::SelectGroup::new()
            }
        }

        // .mizer.nodes.NodeSetting.SelectVariant.SelectItem item = 2;

        pub fn item(&self) -> &select_variant::SelectItem {
            match self.variant {
                ::std::option::Option::Some(select_variant::Variant::Item(ref v)) => v,
                _ => <select_variant::SelectItem as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_item(&mut self) {
            self.variant = ::std::option::Option::None;
        }

        pub fn has_item(&self) -> bool {
            match self.variant {
                ::std::option::Option::Some(select_variant::Variant::Item(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_item(&mut self, v: select_variant::SelectItem) {
            self.variant = ::std::option::Option::Some(select_variant::Variant::Item(v))
        }

        // Mutable pointer to the field.
        pub fn mut_item(&mut self) -> &mut select_variant::SelectItem {
            if let ::std::option::Option::Some(select_variant::Variant::Item(_)) = self.variant {
            } else {
                self.variant = ::std::option::Option::Some(select_variant::Variant::Item(select_variant::SelectItem::new()));
            }
            match self.variant {
                ::std::option::Option::Some(select_variant::Variant::Item(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_item(&mut self) -> select_variant::SelectItem {
            if self.has_item() {
                match self.variant.take() {
                    ::std::option::Option::Some(select_variant::Variant::Item(v)) => v,
                    _ => panic!(),
                }
            } else {
                select_variant::SelectItem::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, select_variant::SelectGroup>(
                "group",
                SelectVariant::has_group,
                SelectVariant::group,
                SelectVariant::mut_group,
                SelectVariant::set_group,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, select_variant::SelectItem>(
                "item",
                SelectVariant::has_item,
                SelectVariant::item,
                SelectVariant::mut_item,
                SelectVariant::set_item,
            ));
            oneofs.push(select_variant::Variant::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectVariant>(
                "NodeSetting.SelectVariant",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SelectVariant {
        const NAME: &'static str = "SelectVariant";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.variant = ::std::option::Option::Some(select_variant::Variant::Group(is.read_message()?));
                    },
                    18 => {
                        self.variant = ::std::option::Option::Some(select_variant::Variant::Item(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.variant {
                match v {
                    &select_variant::Variant::Group(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &select_variant::Variant::Item(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.variant {
                match v {
                    &select_variant::Variant::Group(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &select_variant::Variant::Item(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SelectVariant {
            SelectVariant::new()
        }

        fn clear(&mut self) {
            self.variant = ::std::option::Option::None;
            self.variant = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SelectVariant {
            static instance: SelectVariant = SelectVariant {
                variant: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SelectVariant {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.SelectVariant").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SelectVariant {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SelectVariant {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `SelectVariant`
    pub mod select_variant {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:mizer.nodes.NodeSetting.SelectVariant.variant)
        pub enum Variant {
            // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.SelectVariant.group)
            Group(SelectGroup),
            // @@protoc_insertion_point(oneof_field:mizer.nodes.NodeSetting.SelectVariant.item)
            Item(SelectItem),
        }

        impl ::protobuf::Oneof for Variant {
        }

        impl ::protobuf::OneofFull for Variant {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::SelectVariant as ::protobuf::MessageFull>::descriptor().oneof_by_name("variant").unwrap()).clone()
            }
        }

        impl Variant {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Variant>("variant")
            }
        }
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.SelectVariant.SelectGroup)
        pub struct SelectGroup {
            // message fields
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SelectVariant.SelectGroup.label)
            pub label: ::std::string::String,
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SelectVariant.SelectGroup.items)
            pub items: ::std::vec::Vec<super::SelectVariant>,
            // special fields
            // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.SelectVariant.SelectGroup.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SelectGroup {
            fn default() -> &'a SelectGroup {
                <SelectGroup as ::protobuf::Message>::default_instance()
            }
        }

        impl SelectGroup {
            pub fn new() -> SelectGroup {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "label",
                    |m: &SelectGroup| { &m.label },
                    |m: &mut SelectGroup| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "items",
                    |m: &SelectGroup| { &m.items },
                    |m: &mut SelectGroup| { &mut m.items },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectGroup>(
                    "NodeSetting.SelectVariant.SelectGroup",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SelectGroup {
            const NAME: &'static str = "SelectGroup";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.label = is.read_string()?;
                        },
                        18 => {
                            self.items.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.label.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.label);
                }
                for value in &self.items {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.label.is_empty() {
                    os.write_string(1, &self.label)?;
                }
                for v in &self.items {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SelectGroup {
                SelectGroup::new()
            }

            fn clear(&mut self) {
                self.label.clear();
                self.items.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SelectGroup {
                static instance: SelectGroup = SelectGroup {
                    label: ::std::string::String::new(),
                    items: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SelectGroup {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NodeSetting.SelectVariant.SelectGroup").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SelectGroup {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SelectGroup {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.SelectVariant.SelectItem)
        pub struct SelectItem {
            // message fields
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SelectVariant.SelectItem.value)
            pub value: ::std::string::String,
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SelectVariant.SelectItem.label)
            pub label: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.SelectVariant.SelectItem.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SelectItem {
            fn default() -> &'a SelectItem {
                <SelectItem as ::protobuf::Message>::default_instance()
            }
        }

        impl SelectItem {
            pub fn new() -> SelectItem {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "value",
                    |m: &SelectItem| { &m.value },
                    |m: &mut SelectItem| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "label",
                    |m: &SelectItem| { &m.label },
                    |m: &mut SelectItem| { &mut m.label },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectItem>(
                    "NodeSetting.SelectVariant.SelectItem",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SelectItem {
            const NAME: &'static str = "SelectItem";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.value = is.read_string()?;
                        },
                        18 => {
                            self.label = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.value.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.value);
                }
                if !self.label.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.label);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.value.is_empty() {
                    os.write_string(1, &self.value)?;
                }
                if !self.label.is_empty() {
                    os.write_string(2, &self.label)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SelectItem {
                SelectItem::new()
            }

            fn clear(&mut self) {
                self.value.clear();
                self.label.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SelectItem {
                static instance: SelectItem = SelectItem {
                    value: ::std::string::String::new(),
                    label: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SelectItem {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NodeSetting.SelectVariant.SelectItem").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SelectItem {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SelectItem {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.EnumValue)
    pub struct EnumValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.EnumValue.value)
        pub value: u32,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.EnumValue.variants)
        pub variants: ::std::vec::Vec<EnumVariant>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.EnumValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EnumValue {
        fn default() -> &'a EnumValue {
            <EnumValue as ::protobuf::Message>::default_instance()
        }
    }

    impl EnumValue {
        pub fn new() -> EnumValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &EnumValue| { &m.value },
                |m: &mut EnumValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "variants",
                |m: &EnumValue| { &m.variants },
                |m: &mut EnumValue| { &mut m.variants },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnumValue>(
                "NodeSetting.EnumValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EnumValue {
        const NAME: &'static str = "EnumValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.value = is.read_uint32()?;
                    },
                    18 => {
                        self.variants.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.value != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.value);
            }
            for value in &self.variants {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.value != 0 {
                os.write_uint32(1, self.value)?;
            }
            for v in &self.variants {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EnumValue {
            EnumValue::new()
        }

        fn clear(&mut self) {
            self.value = 0;
            self.variants.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EnumValue {
            static instance: EnumValue = EnumValue {
                value: 0,
                variants: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EnumValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.EnumValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EnumValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EnumValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.EnumVariant)
    pub struct EnumVariant {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.EnumVariant.value)
        pub value: u32,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.EnumVariant.label)
        pub label: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.EnumVariant.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EnumVariant {
        fn default() -> &'a EnumVariant {
            <EnumVariant as ::protobuf::Message>::default_instance()
        }
    }

    impl EnumVariant {
        pub fn new() -> EnumVariant {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &EnumVariant| { &m.value },
                |m: &mut EnumVariant| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "label",
                |m: &EnumVariant| { &m.label },
                |m: &mut EnumVariant| { &mut m.label },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnumVariant>(
                "NodeSetting.EnumVariant",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for EnumVariant {
        const NAME: &'static str = "EnumVariant";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.value = is.read_uint32()?;
                    },
                    18 => {
                        self.label = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.value != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.value);
            }
            if !self.label.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.label);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.value != 0 {
                os.write_uint32(1, self.value)?;
            }
            if !self.label.is_empty() {
                os.write_string(2, &self.label)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EnumVariant {
            EnumVariant::new()
        }

        fn clear(&mut self) {
            self.value = 0;
            self.label.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EnumVariant {
            static instance: EnumVariant = EnumVariant {
                value: 0,
                label: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for EnumVariant {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.EnumVariant").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EnumVariant {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for EnumVariant {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.IdValue)
    pub struct IdValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.IdValue.value)
        pub value: u32,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.IdValue.variants)
        pub variants: ::std::vec::Vec<IdVariant>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.IdValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IdValue {
        fn default() -> &'a IdValue {
            <IdValue as ::protobuf::Message>::default_instance()
        }
    }

    impl IdValue {
        pub fn new() -> IdValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &IdValue| { &m.value },
                |m: &mut IdValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "variants",
                |m: &IdValue| { &m.variants },
                |m: &mut IdValue| { &mut m.variants },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdValue>(
                "NodeSetting.IdValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for IdValue {
        const NAME: &'static str = "IdValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.value = is.read_uint32()?;
                    },
                    18 => {
                        self.variants.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.value != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.value);
            }
            for value in &self.variants {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.value != 0 {
                os.write_uint32(1, self.value)?;
            }
            for v in &self.variants {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IdValue {
            IdValue::new()
        }

        fn clear(&mut self) {
            self.value = 0;
            self.variants.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IdValue {
            static instance: IdValue = IdValue {
                value: 0,
                variants: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for IdValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.IdValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for IdValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for IdValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.IdVariant)
    pub struct IdVariant {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.IdVariant.value)
        pub value: u32,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.IdVariant.label)
        pub label: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.IdVariant.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IdVariant {
        fn default() -> &'a IdVariant {
            <IdVariant as ::protobuf::Message>::default_instance()
        }
    }

    impl IdVariant {
        pub fn new() -> IdVariant {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &IdVariant| { &m.value },
                |m: &mut IdVariant| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "label",
                |m: &IdVariant| { &m.label },
                |m: &mut IdVariant| { &mut m.label },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IdVariant>(
                "NodeSetting.IdVariant",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for IdVariant {
        const NAME: &'static str = "IdVariant";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.value = is.read_uint32()?;
                    },
                    18 => {
                        self.label = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.value != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.value);
            }
            if !self.label.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.label);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.value != 0 {
                os.write_uint32(1, self.value)?;
            }
            if !self.label.is_empty() {
                os.write_string(2, &self.label)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IdVariant {
            IdVariant::new()
        }

        fn clear(&mut self) {
            self.value = 0;
            self.label.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IdVariant {
            static instance: IdVariant = IdVariant {
                value: 0,
                label: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for IdVariant {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.IdVariant").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for IdVariant {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for IdVariant {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.SplineValue)
    pub struct SplineValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SplineValue.steps)
        pub steps: ::std::vec::Vec<spline_value::SplineStep>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.SplineValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SplineValue {
        fn default() -> &'a SplineValue {
            <SplineValue as ::protobuf::Message>::default_instance()
        }
    }

    impl SplineValue {
        pub fn new() -> SplineValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "steps",
                |m: &SplineValue| { &m.steps },
                |m: &mut SplineValue| { &mut m.steps },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SplineValue>(
                "NodeSetting.SplineValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SplineValue {
        const NAME: &'static str = "SplineValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.steps.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.steps {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.steps {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SplineValue {
            SplineValue::new()
        }

        fn clear(&mut self) {
            self.steps.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SplineValue {
            static instance: SplineValue = SplineValue {
                steps: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SplineValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.SplineValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SplineValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SplineValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `SplineValue`
    pub mod spline_value {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.SplineValue.SplineStep)
        pub struct SplineStep {
            // message fields
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SplineValue.SplineStep.x)
            pub x: f64,
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SplineValue.SplineStep.y)
            pub y: f64,
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SplineValue.SplineStep.c0a)
            pub c0a: f64,
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SplineValue.SplineStep.c0b)
            pub c0b: f64,
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SplineValue.SplineStep.c1a)
            pub c1a: f64,
            // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.SplineValue.SplineStep.c1b)
            pub c1b: f64,
            // special fields
            // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.SplineValue.SplineStep.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SplineStep {
            fn default() -> &'a SplineStep {
                <SplineStep as ::protobuf::Message>::default_instance()
            }
        }

        impl SplineStep {
            pub fn new() -> SplineStep {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "x",
                    |m: &SplineStep| { &m.x },
                    |m: &mut SplineStep| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "y",
                    |m: &SplineStep| { &m.y },
                    |m: &mut SplineStep| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "c0a",
                    |m: &SplineStep| { &m.c0a },
                    |m: &mut SplineStep| { &mut m.c0a },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "c0b",
                    |m: &SplineStep| { &m.c0b },
                    |m: &mut SplineStep| { &mut m.c0b },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "c1a",
                    |m: &SplineStep| { &m.c1a },
                    |m: &mut SplineStep| { &mut m.c1a },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "c1b",
                    |m: &SplineStep| { &m.c1b },
                    |m: &mut SplineStep| { &mut m.c1b },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SplineStep>(
                    "NodeSetting.SplineValue.SplineStep",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SplineStep {
            const NAME: &'static str = "SplineStep";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        9 => {
                            self.x = is.read_double()?;
                        },
                        17 => {
                            self.y = is.read_double()?;
                        },
                        25 => {
                            self.c0a = is.read_double()?;
                        },
                        33 => {
                            self.c0b = is.read_double()?;
                        },
                        41 => {
                            self.c1a = is.read_double()?;
                        },
                        49 => {
                            self.c1b = is.read_double()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.x != 0. {
                    my_size += 1 + 8;
                }
                if self.y != 0. {
                    my_size += 1 + 8;
                }
                if self.c0a != 0. {
                    my_size += 1 + 8;
                }
                if self.c0b != 0. {
                    my_size += 1 + 8;
                }
                if self.c1a != 0. {
                    my_size += 1 + 8;
                }
                if self.c1b != 0. {
                    my_size += 1 + 8;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.x != 0. {
                    os.write_double(1, self.x)?;
                }
                if self.y != 0. {
                    os.write_double(2, self.y)?;
                }
                if self.c0a != 0. {
                    os.write_double(3, self.c0a)?;
                }
                if self.c0b != 0. {
                    os.write_double(4, self.c0b)?;
                }
                if self.c1a != 0. {
                    os.write_double(5, self.c1a)?;
                }
                if self.c1b != 0. {
                    os.write_double(6, self.c1b)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SplineStep {
                SplineStep::new()
            }

            fn clear(&mut self) {
                self.x = 0.;
                self.y = 0.;
                self.c0a = 0.;
                self.c0b = 0.;
                self.c1a = 0.;
                self.c1b = 0.;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SplineStep {
                static instance: SplineStep = SplineStep {
                    x: 0.,
                    y: 0.,
                    c0a: 0.,
                    c0b: 0.,
                    c1a: 0.,
                    c1b: 0.,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SplineStep {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NodeSetting.SplineValue.SplineStep").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SplineStep {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SplineStep {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.NodeSetting.MediaValue)
    pub struct MediaValue {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.MediaValue.value)
        pub value: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.nodes.NodeSetting.MediaValue.allowed_types)
        pub allowed_types: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::super::media::MediaType>>,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.NodeSetting.MediaValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MediaValue {
        fn default() -> &'a MediaValue {
            <MediaValue as ::protobuf::Message>::default_instance()
        }
    }

    impl MediaValue {
        pub fn new() -> MediaValue {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &MediaValue| { &m.value },
                |m: &mut MediaValue| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "allowed_types",
                |m: &MediaValue| { &m.allowed_types },
                |m: &mut MediaValue| { &mut m.allowed_types },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaValue>(
                "NodeSetting.MediaValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MediaValue {
        const NAME: &'static str = "MediaValue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.value = is.read_string()?;
                    },
                    16 => {
                        self.allowed_types.push(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.allowed_types)?
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.value.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.value);
            }
            for value in &self.allowed_types {
                my_size += ::protobuf::rt::int32_size(2, value.value());
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.value.is_empty() {
                os.write_string(1, &self.value)?;
            }
            for v in &self.allowed_types {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MediaValue {
            MediaValue::new()
        }

        fn clear(&mut self) {
            self.value.clear();
            self.allowed_types.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MediaValue {
            static instance: MediaValue = MediaValue {
                value: ::std::string::String::new(),
                allowed_types: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MediaValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NodeSetting.MediaValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MediaValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MediaValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.MidiNodeConfig)
pub struct MidiNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.device)
    pub device: ::std::string::String,
    // message oneof groups
    pub binding: ::std::option::Option<midi_node_config::Binding>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.MidiNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MidiNodeConfig {
    fn default() -> &'a MidiNodeConfig {
        <MidiNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl MidiNodeConfig {
    pub fn new() -> MidiNodeConfig {
        ::std::default::Default::default()
    }

    // .mizer.nodes.MidiNodeConfig.NoteBinding note_binding = 2;

    pub fn note_binding(&self) -> &midi_node_config::NoteBinding {
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(ref v)) => v,
            _ => <midi_node_config::NoteBinding as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_note_binding(&mut self) {
        self.binding = ::std::option::Option::None;
    }

    pub fn has_note_binding(&self) -> bool {
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_note_binding(&mut self, v: midi_node_config::NoteBinding) {
        self.binding = ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_note_binding(&mut self) -> &mut midi_node_config::NoteBinding {
        if let ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(_)) = self.binding {
        } else {
            self.binding = ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(midi_node_config::NoteBinding::new()));
        }
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_note_binding(&mut self) -> midi_node_config::NoteBinding {
        if self.has_note_binding() {
            match self.binding.take() {
                ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(v)) => v,
                _ => panic!(),
            }
        } else {
            midi_node_config::NoteBinding::new()
        }
    }

    // .mizer.nodes.MidiNodeConfig.ControlBinding control_binding = 3;

    pub fn control_binding(&self) -> &midi_node_config::ControlBinding {
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(ref v)) => v,
            _ => <midi_node_config::ControlBinding as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_control_binding(&mut self) {
        self.binding = ::std::option::Option::None;
    }

    pub fn has_control_binding(&self) -> bool {
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_control_binding(&mut self, v: midi_node_config::ControlBinding) {
        self.binding = ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_control_binding(&mut self) -> &mut midi_node_config::ControlBinding {
        if let ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(_)) = self.binding {
        } else {
            self.binding = ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(midi_node_config::ControlBinding::new()));
        }
        match self.binding {
            ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_control_binding(&mut self) -> midi_node_config::ControlBinding {
        if self.has_control_binding() {
            match self.binding.take() {
                ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(v)) => v,
                _ => panic!(),
            }
        } else {
            midi_node_config::ControlBinding::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device",
            |m: &MidiNodeConfig| { &m.device },
            |m: &mut MidiNodeConfig| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, midi_node_config::NoteBinding>(
            "note_binding",
            MidiNodeConfig::has_note_binding,
            MidiNodeConfig::note_binding,
            MidiNodeConfig::mut_note_binding,
            MidiNodeConfig::set_note_binding,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, midi_node_config::ControlBinding>(
            "control_binding",
            MidiNodeConfig::has_control_binding,
            MidiNodeConfig::control_binding,
            MidiNodeConfig::mut_control_binding,
            MidiNodeConfig::set_control_binding,
        ));
        oneofs.push(midi_node_config::Binding::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MidiNodeConfig>(
            "MidiNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MidiNodeConfig {
    const NAME: &'static str = "MidiNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device = is.read_string()?;
                },
                18 => {
                    self.binding = ::std::option::Option::Some(midi_node_config::Binding::NoteBinding(is.read_message()?));
                },
                26 => {
                    self.binding = ::std::option::Option::Some(midi_node_config::Binding::ControlBinding(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device);
        }
        if let ::std::option::Option::Some(ref v) = self.binding {
            match v {
                &midi_node_config::Binding::NoteBinding(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &midi_node_config::Binding::ControlBinding(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.device.is_empty() {
            os.write_string(1, &self.device)?;
        }
        if let ::std::option::Option::Some(ref v) = self.binding {
            match v {
                &midi_node_config::Binding::NoteBinding(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &midi_node_config::Binding::ControlBinding(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MidiNodeConfig {
        MidiNodeConfig::new()
    }

    fn clear(&mut self) {
        self.device.clear();
        self.binding = ::std::option::Option::None;
        self.binding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MidiNodeConfig {
        static instance: MidiNodeConfig = MidiNodeConfig {
            device: ::std::string::String::new(),
            binding: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MidiNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MidiNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MidiNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MidiNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MidiNodeConfig`
pub mod midi_node_config {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mizer.nodes.MidiNodeConfig.binding)
    pub enum Binding {
        // @@protoc_insertion_point(oneof_field:mizer.nodes.MidiNodeConfig.note_binding)
        NoteBinding(NoteBinding),
        // @@protoc_insertion_point(oneof_field:mizer.nodes.MidiNodeConfig.control_binding)
        ControlBinding(ControlBinding),
    }

    impl ::protobuf::Oneof for Binding {
    }

    impl ::protobuf::OneofFull for Binding {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::MidiNodeConfig as ::protobuf::MessageFull>::descriptor().oneof_by_name("binding").unwrap()).clone()
        }
    }

    impl Binding {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Binding>("binding")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.MidiNodeConfig.NoteBinding)
    pub struct NoteBinding {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.channel)
        pub channel: u32,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.type)
        pub type_: ::protobuf::EnumOrUnknown<note_binding::MidiType>,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.port)
        pub port: u32,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.range_from)
        pub range_from: u32,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.NoteBinding.range_to)
        pub range_to: u32,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.MidiNodeConfig.NoteBinding.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NoteBinding {
        fn default() -> &'a NoteBinding {
            <NoteBinding as ::protobuf::Message>::default_instance()
        }
    }

    impl NoteBinding {
        pub fn new() -> NoteBinding {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "channel",
                |m: &NoteBinding| { &m.channel },
                |m: &mut NoteBinding| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type",
                |m: &NoteBinding| { &m.type_ },
                |m: &mut NoteBinding| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "port",
                |m: &NoteBinding| { &m.port },
                |m: &mut NoteBinding| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "range_from",
                |m: &NoteBinding| { &m.range_from },
                |m: &mut NoteBinding| { &mut m.range_from },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "range_to",
                |m: &NoteBinding| { &m.range_to },
                |m: &mut NoteBinding| { &mut m.range_to },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoteBinding>(
                "MidiNodeConfig.NoteBinding",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NoteBinding {
        const NAME: &'static str = "NoteBinding";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.channel = is.read_uint32()?;
                    },
                    16 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    24 => {
                        self.port = is.read_uint32()?;
                    },
                    32 => {
                        self.range_from = is.read_uint32()?;
                    },
                    40 => {
                        self.range_to = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.channel != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.channel);
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(note_binding::MidiType::CC) {
                my_size += ::protobuf::rt::int32_size(2, self.type_.value());
            }
            if self.port != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.port);
            }
            if self.range_from != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.range_from);
            }
            if self.range_to != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.range_to);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.channel != 0 {
                os.write_uint32(1, self.channel)?;
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(note_binding::MidiType::CC) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            if self.port != 0 {
                os.write_uint32(3, self.port)?;
            }
            if self.range_from != 0 {
                os.write_uint32(4, self.range_from)?;
            }
            if self.range_to != 0 {
                os.write_uint32(5, self.range_to)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NoteBinding {
            NoteBinding::new()
        }

        fn clear(&mut self) {
            self.channel = 0;
            self.type_ = ::protobuf::EnumOrUnknown::new(note_binding::MidiType::CC);
            self.port = 0;
            self.range_from = 0;
            self.range_to = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NoteBinding {
            static instance: NoteBinding = NoteBinding {
                channel: 0,
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                port: 0,
                range_from: 0,
                range_to: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NoteBinding {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MidiNodeConfig.NoteBinding").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NoteBinding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NoteBinding {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `NoteBinding`
    pub mod note_binding {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:mizer.nodes.MidiNodeConfig.NoteBinding.MidiType)
        pub enum MidiType {
            // @@protoc_insertion_point(enum_value:mizer.nodes.MidiNodeConfig.NoteBinding.MidiType.CC)
            CC = 0,
            // @@protoc_insertion_point(enum_value:mizer.nodes.MidiNodeConfig.NoteBinding.MidiType.NOTE)
            NOTE = 1,
        }

        impl ::protobuf::Enum for MidiType {
            const NAME: &'static str = "MidiType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<MidiType> {
                match value {
                    0 => ::std::option::Option::Some(MidiType::CC),
                    1 => ::std::option::Option::Some(MidiType::NOTE),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [MidiType] = &[
                MidiType::CC,
                MidiType::NOTE,
            ];
        }

        impl ::protobuf::EnumFull for MidiType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("MidiNodeConfig.NoteBinding.MidiType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for MidiType {
            fn default() -> Self {
                MidiType::CC
            }
        }

        impl MidiType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MidiType>("MidiNodeConfig.NoteBinding.MidiType")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:mizer.nodes.MidiNodeConfig.ControlBinding)
    pub struct ControlBinding {
        // message fields
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.ControlBinding.page)
        pub page: ::std::string::String,
        // @@protoc_insertion_point(field:mizer.nodes.MidiNodeConfig.ControlBinding.control)
        pub control: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:mizer.nodes.MidiNodeConfig.ControlBinding.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControlBinding {
        fn default() -> &'a ControlBinding {
            <ControlBinding as ::protobuf::Message>::default_instance()
        }
    }

    impl ControlBinding {
        pub fn new() -> ControlBinding {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "page",
                |m: &ControlBinding| { &m.page },
                |m: &mut ControlBinding| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "control",
                |m: &ControlBinding| { &m.control },
                |m: &mut ControlBinding| { &mut m.control },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControlBinding>(
                "MidiNodeConfig.ControlBinding",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ControlBinding {
        const NAME: &'static str = "ControlBinding";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.page = is.read_string()?;
                    },
                    18 => {
                        self.control = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.page.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.page);
            }
            if !self.control.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.control);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.page.is_empty() {
                os.write_string(1, &self.page)?;
            }
            if !self.control.is_empty() {
                os.write_string(2, &self.control)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControlBinding {
            ControlBinding::new()
        }

        fn clear(&mut self) {
            self.page.clear();
            self.control.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControlBinding {
            static instance: ControlBinding = ControlBinding {
                page: ::std::string::String::new(),
                control: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ControlBinding {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MidiNodeConfig.ControlBinding").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ControlBinding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ControlBinding {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.ContainerNodeConfig)
pub struct ContainerNodeConfig {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.ContainerNodeConfig.nodes)
    pub nodes: ::std::vec::Vec<Node>,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.ContainerNodeConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainerNodeConfig {
    fn default() -> &'a ContainerNodeConfig {
        <ContainerNodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl ContainerNodeConfig {
    pub fn new() -> ContainerNodeConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &ContainerNodeConfig| { &m.nodes },
            |m: &mut ContainerNodeConfig| { &mut m.nodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainerNodeConfig>(
            "ContainerNodeConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainerNodeConfig {
    const NAME: &'static str = "ContainerNodeConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nodes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainerNodeConfig {
        ContainerNodeConfig::new()
    }

    fn clear(&mut self) {
        self.nodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainerNodeConfig {
        static instance: ContainerNodeConfig = ContainerNodeConfig {
            nodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainerNodeConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainerNodeConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainerNodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerNodeConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodePosition)
pub struct NodePosition {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.NodePosition.x)
    pub x: f64,
    // @@protoc_insertion_point(field:mizer.nodes.NodePosition.y)
    pub y: f64,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodePosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodePosition {
    fn default() -> &'a NodePosition {
        <NodePosition as ::protobuf::Message>::default_instance()
    }
}

impl NodePosition {
    pub fn new() -> NodePosition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &NodePosition| { &m.x },
            |m: &mut NodePosition| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &NodePosition| { &m.y },
            |m: &mut NodePosition| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodePosition>(
            "NodePosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodePosition {
    const NAME: &'static str = "NodePosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = is.read_double()?;
                },
                17 => {
                    self.y = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 1 + 8;
        }
        if self.y != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0. {
            os.write_double(1, self.x)?;
        }
        if self.y != 0. {
            os.write_double(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodePosition {
        NodePosition::new()
    }

    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodePosition {
        static instance: NodePosition = NodePosition {
            x: 0.,
            y: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodePosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodePosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodePosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.NodeDesigner)
pub struct NodeDesigner {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.NodeDesigner.position)
    pub position: ::protobuf::MessageField<NodePosition>,
    // @@protoc_insertion_point(field:mizer.nodes.NodeDesigner.scale)
    pub scale: f64,
    // @@protoc_insertion_point(field:mizer.nodes.NodeDesigner.hidden)
    pub hidden: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.NodeDesigner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeDesigner {
    fn default() -> &'a NodeDesigner {
        <NodeDesigner as ::protobuf::Message>::default_instance()
    }
}

impl NodeDesigner {
    pub fn new() -> NodeDesigner {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NodePosition>(
            "position",
            |m: &NodeDesigner| { &m.position },
            |m: &mut NodeDesigner| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scale",
            |m: &NodeDesigner| { &m.scale },
            |m: &mut NodeDesigner| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hidden",
            |m: &NodeDesigner| { &m.hidden },
            |m: &mut NodeDesigner| { &mut m.hidden },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NodeDesigner>(
            "NodeDesigner",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NodeDesigner {
    const NAME: &'static str = "NodeDesigner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                17 => {
                    self.scale = is.read_double()?;
                },
                24 => {
                    self.hidden = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.scale != 0. {
            my_size += 1 + 8;
        }
        if self.hidden != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.scale != 0. {
            os.write_double(2, self.scale)?;
        }
        if self.hidden != false {
            os.write_bool(3, self.hidden)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeDesigner {
        NodeDesigner::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.scale = 0.;
        self.hidden = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeDesigner {
        static instance: NodeDesigner = NodeDesigner {
            position: ::protobuf::MessageField::none(),
            scale: 0.,
            hidden: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NodeDesigner {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NodeDesigner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NodeDesigner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeDesigner {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:mizer.nodes.Port)
pub struct Port {
    // message fields
    // @@protoc_insertion_point(field:mizer.nodes.Port.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:mizer.nodes.Port.protocol)
    pub protocol: ::protobuf::EnumOrUnknown<ChannelProtocol>,
    // @@protoc_insertion_point(field:mizer.nodes.Port.multiple)
    pub multiple: bool,
    // special fields
    // @@protoc_insertion_point(special_field:mizer.nodes.Port.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Port {
    fn default() -> &'a Port {
        <Port as ::protobuf::Message>::default_instance()
    }
}

impl Port {
    pub fn new() -> Port {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Port| { &m.name },
            |m: &mut Port| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol",
            |m: &Port| { &m.protocol },
            |m: &mut Port| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "multiple",
            |m: &Port| { &m.multiple },
            |m: &mut Port| { &mut m.multiple },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Port>(
            "Port",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Port {
    const NAME: &'static str = "Port";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.protocol = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.multiple = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE) {
            my_size += ::protobuf::rt::int32_size(2, self.protocol.value());
        }
        if self.multiple != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.protocol))?;
        }
        if self.multiple != false {
            os.write_bool(3, self.multiple)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Port {
        Port::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.protocol = ::protobuf::EnumOrUnknown::new(ChannelProtocol::SINGLE);
        self.multiple = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Port {
        static instance: Port = Port {
            name: ::std::string::String::new(),
            protocol: ::protobuf::EnumOrUnknown::from_i32(0),
            multiple: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Port {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Port").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Port {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Port {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:mizer.nodes.NodeCategory)
pub enum NodeCategory {
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_NONE)
    NODE_CATEGORY_NONE = 0,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_STANDARD)
    NODE_CATEGORY_STANDARD = 1,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_CONNECTIONS)
    NODE_CATEGORY_CONNECTIONS = 2,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_CONVERSIONS)
    NODE_CATEGORY_CONVERSIONS = 3,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_CONTROLS)
    NODE_CATEGORY_CONTROLS = 4,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_DATA)
    NODE_CATEGORY_DATA = 5,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_COLOR)
    NODE_CATEGORY_COLOR = 6,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_AUDIO)
    NODE_CATEGORY_AUDIO = 7,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_VIDEO)
    NODE_CATEGORY_VIDEO = 8,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_LASER)
    NODE_CATEGORY_LASER = 9,
    // @@protoc_insertion_point(enum_value:mizer.nodes.NodeCategory.NODE_CATEGORY_PIXEL)
    NODE_CATEGORY_PIXEL = 10,
}

impl ::protobuf::Enum for NodeCategory {
    const NAME: &'static str = "NodeCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodeCategory> {
        match value {
            0 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_NONE),
            1 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_STANDARD),
            2 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_CONNECTIONS),
            3 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_CONVERSIONS),
            4 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_CONTROLS),
            5 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_DATA),
            6 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_COLOR),
            7 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_AUDIO),
            8 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_VIDEO),
            9 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_LASER),
            10 => ::std::option::Option::Some(NodeCategory::NODE_CATEGORY_PIXEL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NodeCategory] = &[
        NodeCategory::NODE_CATEGORY_NONE,
        NodeCategory::NODE_CATEGORY_STANDARD,
        NodeCategory::NODE_CATEGORY_CONNECTIONS,
        NodeCategory::NODE_CATEGORY_CONVERSIONS,
        NodeCategory::NODE_CATEGORY_CONTROLS,
        NodeCategory::NODE_CATEGORY_DATA,
        NodeCategory::NODE_CATEGORY_COLOR,
        NodeCategory::NODE_CATEGORY_AUDIO,
        NodeCategory::NODE_CATEGORY_VIDEO,
        NodeCategory::NODE_CATEGORY_LASER,
        NodeCategory::NODE_CATEGORY_PIXEL,
    ];
}

impl ::protobuf::EnumFull for NodeCategory {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NodeCategory").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NodeCategory {
    fn default() -> Self {
        NodeCategory::NODE_CATEGORY_NONE
    }
}

impl NodeCategory {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NodeCategory>("NodeCategory")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:mizer.nodes.ChannelProtocol)
pub enum ChannelProtocol {
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.SINGLE)
    SINGLE = 0,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.MULTI)
    MULTI = 1,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.TEXTURE)
    TEXTURE = 2,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.VECTOR)
    VECTOR = 3,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.LASER)
    LASER = 4,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.POLY)
    POLY = 5,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.DATA)
    DATA = 6,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.MATERIAL)
    MATERIAL = 7,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.COLOR)
    COLOR = 9,
    // @@protoc_insertion_point(enum_value:mizer.nodes.ChannelProtocol.CLOCK)
    CLOCK = 10,
}

impl ::protobuf::Enum for ChannelProtocol {
    const NAME: &'static str = "ChannelProtocol";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelProtocol> {
        match value {
            0 => ::std::option::Option::Some(ChannelProtocol::SINGLE),
            1 => ::std::option::Option::Some(ChannelProtocol::MULTI),
            2 => ::std::option::Option::Some(ChannelProtocol::TEXTURE),
            3 => ::std::option::Option::Some(ChannelProtocol::VECTOR),
            4 => ::std::option::Option::Some(ChannelProtocol::LASER),
            5 => ::std::option::Option::Some(ChannelProtocol::POLY),
            6 => ::std::option::Option::Some(ChannelProtocol::DATA),
            7 => ::std::option::Option::Some(ChannelProtocol::MATERIAL),
            9 => ::std::option::Option::Some(ChannelProtocol::COLOR),
            10 => ::std::option::Option::Some(ChannelProtocol::CLOCK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ChannelProtocol] = &[
        ChannelProtocol::SINGLE,
        ChannelProtocol::MULTI,
        ChannelProtocol::TEXTURE,
        ChannelProtocol::VECTOR,
        ChannelProtocol::LASER,
        ChannelProtocol::POLY,
        ChannelProtocol::DATA,
        ChannelProtocol::MATERIAL,
        ChannelProtocol::COLOR,
        ChannelProtocol::CLOCK,
    ];
}

impl ::protobuf::EnumFull for ChannelProtocol {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ChannelProtocol").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ChannelProtocol::SINGLE => 0,
            ChannelProtocol::MULTI => 1,
            ChannelProtocol::TEXTURE => 2,
            ChannelProtocol::VECTOR => 3,
            ChannelProtocol::LASER => 4,
            ChannelProtocol::POLY => 5,
            ChannelProtocol::DATA => 6,
            ChannelProtocol::MATERIAL => 7,
            ChannelProtocol::COLOR => 8,
            ChannelProtocol::CLOCK => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ChannelProtocol {
    fn default() -> Self {
        ChannelProtocol::SINGLE
    }
}

impl ChannelProtocol {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ChannelProtocol>("ChannelProtocol")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bnodes.proto\x12\x0bmizer.nodes\x1a\x0bmedia.proto\"\x9f\x01\n\x0eA\
    ddNodeRequest\x12.\n\x04type\x18\x01\x20\x01(\x0e2\x1a.mizer.nodes.Node.\
    NodeTypeR\x04type\x125\n\x08position\x18\x02\x20\x01(\x0b2\x19.mizer.nod\
    es.NodePositionR\x08position\x12\x1b\n\x06parent\x18\x03\x20\x01(\tH\0R\
    \x06parent\x88\x01\x01B\t\n\x07_parent\"R\n\x14DuplicateNodeRequest\x12\
    \x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x1b\n\x06parent\x18\x02\
    \x20\x01(\tH\0R\x06parent\x88\x01\x01B\t\n\x07_parent\"\x0e\n\x0cNodesRe\
    quest\"L\n\x0cWriteControl\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\
    \x12\x12\n\x04port\x18\x02\x20\x01(\tR\x04port\x12\x14\n\x05value\x18\
    \x03\x20\x01(\x01R\x05value\"\x0f\n\rWriteResponse\"b\n\x18UpdateNodeSet\
    tingRequest\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x122\n\x07sett\
    ing\x18\x02\x20\x01(\x0b2\x18.mizer.nodes.NodeSettingR\x07setting\"\\\n\
    \x0fMoveNodeRequest\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x125\n\
    \x08position\x18\x02\x20\x01(\x0b2\x19.mizer.nodes.NodePositionR\x08posi\
    tion\"\x12\n\x10MoveNodeResponse\"\x84\x01\n\x0fShowNodeRequest\x12\x12\
    \n\x04path\x18\x01\x20\x01(\tR\x04path\x125\n\x08position\x18\x02\x20\
    \x01(\x0b2\x19.mizer.nodes.NodePositionR\x08position\x12\x1b\n\x06parent\
    \x18\x03\x20\x01(\tH\0R\x06parent\x88\x01\x01B\t\n\x07_parent\"\x12\n\
    \x10ShowNodeResponse\"B\n\x11RenameNodeRequest\x12\x12\n\x04path\x18\x01\
    \x20\x01(\tR\x04path\x12\x19\n\x08new_name\x18\x02\x20\x01(\tR\x07newNam\
    e\"\x14\n\x12RenameNodeResponse\"Q\n\x11GroupNodesRequest\x12\x14\n\x05n\
    odes\x18\x01\x20\x03(\tR\x05nodes\x12\x1b\n\x06parent\x18\x02\x20\x01(\t\
    H\0R\x06parent\x88\x01\x01B\t\n\x07_parent\"\x14\n\x12GroupNodesResponse\
    \"'\n\x11DeleteNodeRequest\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\
    \"\x14\n\x12DeleteNodeResponse\"%\n\x0fHideNodeRequest\x12\x12\n\x04path\
    \x18\x01\x20\x01(\tR\x04path\"\x12\n\x10HideNodeResponse\"\x99\x01\n\x05\
    Nodes\x12'\n\x05nodes\x18\x01\x20\x03(\x0b2\x11.mizer.nodes.NodeR\x05nod\
    es\x127\n\x08channels\x18\x02\x20\x03(\x0b2\x1b.mizer.nodes.NodeConnecti\
    onR\x08channels\x12.\n\tall_nodes\x18\x03\x20\x03(\x0b2\x11.mizer.nodes.\
    NodeR\x08allNodes\"B\n\x0eAvailableNodes\x120\n\x05nodes\x18\x01\x20\x03\
    (\x0b2\x1a.mizer.nodes.AvailableNodeR\x05nodes\"\x8a\x01\n\rAvailableNod\
    e\x12.\n\x04type\x18\x01\x20\x01(\x0e2\x1a.mizer.nodes.Node.NodeTypeR\
    \x04type\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x125\n\x08categor\
    y\x18\x03\x20\x01(\x0e2\x19.mizer.nodes.NodeCategoryR\x08category\"\xf4\
    \x01\n\x0eNodeConnection\x12\x1f\n\x0btarget_node\x18\x01\x20\x01(\tR\nt\
    argetNode\x122\n\x0btarget_port\x18\x02\x20\x01(\x0b2\x11.mizer.nodes.Po\
    rtR\ntargetPort\x12\x1f\n\x0bsource_node\x18\x03\x20\x01(\tR\nsourceNode\
    \x122\n\x0bsource_port\x18\x04\x20\x01(\x0b2\x11.mizer.nodes.PortR\nsour\
    cePort\x128\n\x08protocol\x18\x05\x20\x01(\x0e2\x1c.mizer.nodes.ChannelP\
    rotocolR\x08protocol\"\xa3\x0c\n\x04Node\x12.\n\x04type\x18\x01\x20\x01(\
    \x0e2\x1a.mizer.nodes.Node.NodeTypeR\x04type\x12\x12\n\x04path\x18\x02\
    \x20\x01(\tR\x04path\x12)\n\x06inputs\x18\x03\x20\x03(\x0b2\x11.mizer.no\
    des.PortR\x06inputs\x12+\n\x07outputs\x18\x04\x20\x03(\x0b2\x11.mizer.no\
    des.PortR\x07outputs\x125\n\x08designer\x18\x05\x20\x01(\x0b2\x19.mizer.\
    nodes.NodeDesignerR\x08designer\x12;\n\x07preview\x18\x06\x20\x01(\x0e2!\
    .mizer.nodes.Node.NodePreviewTypeR\x07preview\x12/\n\x06config\x18\x07\
    \x20\x01(\x0b2\x17.mizer.nodes.NodeConfigR\x06config\x124\n\x08settings\
    \x18\x08\x20\x03(\x0b2\x18.mizer.nodes.NodeSettingR\x08settings\x122\n\
    \x07details\x18\t\x20\x01(\x0b2\x18.mizer.nodes.NodeDetailsR\x07details\
    \"\xf9\x07\n\x08NodeType\x12\t\n\x05FADER\x10\0\x12\n\n\x06BUTTON\x10\
    \x01\x12\x0e\n\nOSCILLATOR\x10\x02\x12\t\n\x05CLOCK\x10\x03\x12\n\n\x06S\
    CRIPT\x10\x04\x12\x0c\n\x08ENVELOPE\x10\x05\x12\x0c\n\x08SEQUENCE\x10\
    \x06\x12\n\n\x06SELECT\x10\x07\x12\t\n\x05MERGE\x10\x08\x12\r\n\tTHRESHO\
    LD\x10\t\x12\x0e\n\nDMX_OUTPUT\x10\n\x12\r\n\tOSC_INPUT\x10\x0b\x12\x0e\
    \n\nOSC_OUTPUT\x10\x0c\x12\x0e\n\nMIDI_INPUT\x10\r\x12\x0f\n\x0bMIDI_OUT\
    PUT\x10\x0e\x12\r\n\tSEQUENCER\x10\x0f\x12\x0b\n\x07FIXTURE\x10\x10\x12\
    \x0e\n\nPROGRAMMER\x10\x11\x12\t\n\x05GROUP\x10\x12\x12\n\n\x06PRESET\
    \x10\x13\x12\x0e\n\nVIDEO_FILE\x10\x14\x12\x10\n\x0cVIDEO_OUTPUT\x10\x15\
    \x12\x17\n\x13VIDEO_COLOR_BALANCE\x10\x17\x12\x13\n\x0fVIDEO_TRANSFORM\
    \x10\x18\x12\x0f\n\x0bVIDEO_MIXER\x10\x19\x12\r\n\tVIDEO_RGB\x10\x1a\x12\
    \x13\n\x0fVIDEO_RGB_SPLIT\x10\x1b\x12\x10\n\x0cPIXEL_TO_DMX\x10\x1e\x12\
    \x11\n\rPIXEL_PATTERN\x10\x1f\x12\x0e\n\nOPC_OUTPUT\x10\x20\x12\t\n\x05L\
    ASER\x10(\x12\r\n\tILDA_FILE\x10)\x12\x0b\n\x07GAMEPAD\x10-\x12\r\n\tCOL\
    OR_RGB\x102\x12\r\n\tCOLOR_HSV\x103\x12\x12\n\x0eCOLOR_CONSTANT\x104\x12\
    \x14\n\x10COLOR_BRIGHTNESS\x105\x12\x0b\n\x07ENCODER\x107\x12\x08\n\x04M\
    ATH\x108\x12\x12\n\x0eDATA_TO_NUMBER\x109\x12\x12\n\x0eNUMBER_TO_DATA\
    \x10:\x12\t\n\x05VALUE\x10;\x12\x0b\n\x07EXTRACT\x10<\x12\x0e\n\nMQTT_IN\
    PUT\x10=\x12\x0f\n\x0bMQTT_OUTPUT\x10>\x12\x0f\n\x0bPLAN_SCREEN\x10?\x12\
    \t\n\x05DELAY\x10@\x12\x08\n\x04RAMP\x10A\x12\t\n\x05NOISE\x10B\x12\t\n\
    \x05LABEL\x10C\x12\r\n\tTRANSPORT\x10D\x12\x0c\n\x08G13INPUT\x10E\x12\r\
    \n\tG13OUTPUT\x10F\x12\x13\n\x0fCONSTANT_NUMBER\x10G\x12\x0f\n\x0bCONDIT\
    IONAL\x10H\x12\x14\n\x10TIMECODE_CONTROL\x10I\x12\x13\n\x0fTIMECODE_OUTP\
    UT\x10J\x12\x0e\n\nAUDIO_FILE\x10K\x12\x10\n\x0cAUDIO_OUTPUT\x10L\x12\
    \x10\n\x0cAUDIO_VOLUME\x10M\x12\x0f\n\x0bAUDIO_INPUT\x10N\x12\r\n\tAUDIO\
    _MIX\x10O\x12\x0f\n\x0bAUDIO_METER\x10P\x12\x0c\n\x08TEMPLATE\x10Q\x12\r\
    \n\tCONTAINER\x10d\"t\n\x0fNodePreviewType\x12\x08\n\x04NONE\x10\0\x12\
    \x0b\n\x07HISTORY\x10\x01\x12\x0c\n\x08WAVEFORM\x10\x02\x12\x0c\n\x08MUL\
    TIPLE\x10\x03\x12\x0b\n\x07TEXTURE\x10\x04\x12\x0c\n\x08TIMECODE\x10\x05\
    \x12\x08\n\x04DATA\x10\x06\x12\t\n\x05COLOR\x10\x07\"X\n\x0bNodeDetails\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x125\n\x08category\x18\
    \x02\x20\x01(\x0e2\x19.mizer.nodes.NodeCategoryR\x08category\"c\n\nNodeC\
    onfig\x12M\n\x10container_config\x18-\x20\x01(\x0b2\x20.mizer.nodes.Cont\
    ainerNodeConfigH\0R\x0fcontainerConfigB\x06\n\x04type\"\xf5\x10\n\x0bNod\
    eSetting\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\x12\x20\n\x0bde\
    scription\x18\x02\x20\x01(\tR\x0bdescription\x12\x1a\n\x08disabled\x18\
    \x03\x20\x01(\x08R\x08disabled\x128\n\x04text\x18\x04\x20\x01(\x0b2\".mi\
    zer.nodes.NodeSetting.TextValueH\0R\x04text\x12;\n\x05float\x18\x05\x20\
    \x01(\x0b2#.mizer.nodes.NodeSetting.FloatValueH\0R\x05float\x125\n\x03in\
    t\x18\x06\x20\x01(\x0b2!.mizer.nodes.NodeSetting.IntValueH\0R\x03int\x12\
    8\n\x04bool\x18\x07\x20\x01(\x0b2\".mizer.nodes.NodeSetting.BoolValueH\0\
    R\x04bool\x12>\n\x06select\x18\x08\x20\x01(\x0b2$.mizer.nodes.NodeSettin\
    g.SelectValueH\0R\x06select\x128\n\x04enum\x18\t\x20\x01(\x0b2\".mizer.n\
    odes.NodeSetting.EnumValueH\0R\x04enum\x122\n\x02id\x18\n\x20\x01(\x0b2\
    \x20.mizer.nodes.NodeSetting.IdValueH\0R\x02id\x12>\n\x06spline\x18\x0b\
    \x20\x01(\x0b2$.mizer.nodes.NodeSetting.SplineValueH\0R\x06spline\x12;\n\
    \x05media\x18\x0c\x20\x01(\x0b2#.mizer.nodes.NodeSetting.MediaValueH\0R\
    \x05media\x1a?\n\tTextValue\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05va\
    lue\x12\x1c\n\tmultiline\x18\x02\x20\x01(\x08R\tmultiline\x1a\xba\x01\n\
    \nFloatValue\x12\x14\n\x05value\x18\x01\x20\x01(\x01R\x05value\x12\x15\n\
    \x03min\x18\x02\x20\x01(\x01H\0R\x03min\x88\x01\x01\x12\x1e\n\x08min_hin\
    t\x18\x03\x20\x01(\x01H\x01R\x07minHint\x88\x01\x01\x12\x15\n\x03max\x18\
    \x04\x20\x01(\x01H\x02R\x03max\x88\x01\x01\x12\x1e\n\x08max_hint\x18\x05\
    \x20\x01(\x01H\x03R\x07maxHint\x88\x01\x01B\x06\n\x04_minB\x0b\n\t_min_h\
    intB\x06\n\x04_maxB\x0b\n\t_max_hint\x1a\xb8\x01\n\x08IntValue\x12\x14\n\
    \x05value\x18\x01\x20\x01(\rR\x05value\x12\x15\n\x03min\x18\x02\x20\x01(\
    \rH\0R\x03min\x88\x01\x01\x12\x1e\n\x08min_hint\x18\x03\x20\x01(\rH\x01R\
    \x07minHint\x88\x01\x01\x12\x15\n\x03max\x18\x04\x20\x01(\rH\x02R\x03max\
    \x88\x01\x01\x12\x1e\n\x08max_hint\x18\x05\x20\x01(\rH\x03R\x07maxHint\
    \x88\x01\x01B\x06\n\x04_minB\x0b\n\t_min_hintB\x06\n\x04_maxB\x0b\n\t_ma\
    x_hint\x1a!\n\tBoolValue\x12\x14\n\x05value\x18\x01\x20\x01(\x08R\x05val\
    ue\x1ag\n\x0bSelectValue\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\
    \x12B\n\x08variants\x18\x02\x20\x03(\x0b2&.mizer.nodes.NodeSetting.Selec\
    tVariantR\x08variants\x1a\xcc\x02\n\rSelectVariant\x12J\n\x05group\x18\
    \x01\x20\x01(\x0b22.mizer.nodes.NodeSetting.SelectVariant.SelectGroupH\0\
    R\x05group\x12G\n\x04item\x18\x02\x20\x01(\x0b21.mizer.nodes.NodeSetting\
    .SelectVariant.SelectItemH\0R\x04item\x1aa\n\x0bSelectGroup\x12\x14\n\
    \x05label\x18\x01\x20\x01(\tR\x05label\x12<\n\x05items\x18\x02\x20\x03(\
    \x0b2&.mizer.nodes.NodeSetting.SelectVariantR\x05items\x1a8\n\nSelectIte\
    m\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\x12\x14\n\x05label\x18\
    \x02\x20\x01(\tR\x05labelB\t\n\x07variant\x1ac\n\tEnumValue\x12\x14\n\
    \x05value\x18\x01\x20\x01(\rR\x05value\x12@\n\x08variants\x18\x02\x20\
    \x03(\x0b2$.mizer.nodes.NodeSetting.EnumVariantR\x08variants\x1a9\n\x0bE\
    numVariant\x12\x14\n\x05value\x18\x01\x20\x01(\rR\x05value\x12\x14\n\x05\
    label\x18\x02\x20\x01(\tR\x05label\x1a_\n\x07IdValue\x12\x14\n\x05value\
    \x18\x01\x20\x01(\rR\x05value\x12>\n\x08variants\x18\x02\x20\x03(\x0b2\"\
    .mizer.nodes.NodeSetting.IdVariantR\x08variants\x1a7\n\tIdVariant\x12\
    \x14\n\x05value\x18\x01\x20\x01(\rR\x05value\x12\x14\n\x05label\x18\x02\
    \x20\x01(\tR\x05label\x1a\xc6\x01\n\x0bSplineValue\x12E\n\x05steps\x18\
    \x01\x20\x03(\x0b2/.mizer.nodes.NodeSetting.SplineValue.SplineStepR\x05s\
    teps\x1ap\n\nSplineStep\x12\x0c\n\x01x\x18\x01\x20\x01(\x01R\x01x\x12\
    \x0c\n\x01y\x18\x02\x20\x01(\x01R\x01y\x12\x10\n\x03c0a\x18\x03\x20\x01(\
    \x01R\x03c0a\x12\x10\n\x03c0b\x18\x04\x20\x01(\x01R\x03c0b\x12\x10\n\x03\
    c1a\x18\x05\x20\x01(\x01R\x03c1a\x12\x10\n\x03c1b\x18\x06\x20\x01(\x01R\
    \x03c1b\x1a_\n\nMediaValue\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05val\
    ue\x12;\n\rallowed_types\x18\x02\x20\x03(\x0e2\x16.mizer.media.MediaType\
    R\x0callowedTypesB\x07\n\x05value\"\xf4\x03\n\x0eMidiNodeConfig\x12\x16\
    \n\x06device\x18\x01\x20\x01(\tR\x06device\x12L\n\x0cnote_binding\x18\
    \x02\x20\x01(\x0b2'.mizer.nodes.MidiNodeConfig.NoteBindingH\0R\x0bnoteBi\
    nding\x12U\n\x0fcontrol_binding\x18\x03\x20\x01(\x0b2*.mizer.nodes.MidiN\
    odeConfig.ControlBindingH\0R\x0econtrolBinding\x1a\xd9\x01\n\x0bNoteBind\
    ing\x12\x18\n\x07channel\x18\x01\x20\x01(\rR\x07channel\x12D\n\x04type\
    \x18\x02\x20\x01(\x0e20.mizer.nodes.MidiNodeConfig.NoteBinding.MidiTypeR\
    \x04type\x12\x12\n\x04port\x18\x03\x20\x01(\rR\x04port\x12\x1d\n\nrange_\
    from\x18\x04\x20\x01(\rR\trangeFrom\x12\x19\n\x08range_to\x18\x05\x20\
    \x01(\rR\x07rangeTo\"\x1c\n\x08MidiType\x12\x06\n\x02CC\x10\0\x12\x08\n\
    \x04NOTE\x10\x01\x1a>\n\x0eControlBinding\x12\x12\n\x04page\x18\x01\x20\
    \x01(\tR\x04page\x12\x18\n\x07control\x18\x02\x20\x01(\tR\x07controlB\t\
    \n\x07binding\">\n\x13ContainerNodeConfig\x12'\n\x05nodes\x18\x01\x20\
    \x03(\x0b2\x11.mizer.nodes.NodeR\x05nodes\"*\n\x0cNodePosition\x12\x0c\n\
    \x01x\x18\x01\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x01R\
    \x01y\"s\n\x0cNodeDesigner\x125\n\x08position\x18\x01\x20\x01(\x0b2\x19.\
    mizer.nodes.NodePositionR\x08position\x12\x14\n\x05scale\x18\x02\x20\x01\
    (\x01R\x05scale\x12\x16\n\x06hidden\x18\x03\x20\x01(\x08R\x06hidden\"p\n\
    \x04Port\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x128\n\x08protoco\
    l\x18\x02\x20\x01(\x0e2\x1c.mizer.nodes.ChannelProtocolR\x08protocol\x12\
    \x1a\n\x08multiple\x18\x03\x20\x01(\x08R\x08multiple*\xb1\x02\n\x0cNodeC\
    ategory\x12\x16\n\x12NODE_CATEGORY_NONE\x10\0\x12\x1a\n\x16NODE_CATEGORY\
    _STANDARD\x10\x01\x12\x1d\n\x19NODE_CATEGORY_CONNECTIONS\x10\x02\x12\x1d\
    \n\x19NODE_CATEGORY_CONVERSIONS\x10\x03\x12\x1a\n\x16NODE_CATEGORY_CONTR\
    OLS\x10\x04\x12\x16\n\x12NODE_CATEGORY_DATA\x10\x05\x12\x17\n\x13NODE_CA\
    TEGORY_COLOR\x10\x06\x12\x17\n\x13NODE_CATEGORY_AUDIO\x10\x07\x12\x17\n\
    \x13NODE_CATEGORY_VIDEO\x10\x08\x12\x17\n\x13NODE_CATEGORY_LASER\x10\t\
    \x12\x17\n\x13NODE_CATEGORY_PIXEL\x10\n*\x84\x01\n\x0fChannelProtocol\
    \x12\n\n\x06SINGLE\x10\0\x12\t\n\x05MULTI\x10\x01\x12\x0b\n\x07TEXTURE\
    \x10\x02\x12\n\n\x06VECTOR\x10\x03\x12\t\n\x05LASER\x10\x04\x12\x08\n\
    \x04POLY\x10\x05\x12\x08\n\x04DATA\x10\x06\x12\x0c\n\x08MATERIAL\x10\x07\
    \x12\t\n\x05COLOR\x10\t\x12\t\n\x05CLOCK\x10\n2\xbc\x07\n\x08NodesApi\
    \x12K\n\x11GetAvailableNodes\x12\x19.mizer.nodes.NodesRequest\x1a\x1b.mi\
    zer.nodes.AvailableNodes\x129\n\x08GetNodes\x12\x19.mizer.nodes.NodesReq\
    uest\x1a\x12.mizer.nodes.Nodes\x129\n\x07AddNode\x12\x1b.mizer.nodes.Add\
    NodeRequest\x1a\x11.mizer.nodes.Node\x12C\n\x07AddLink\x12\x1b.mizer.nod\
    es.NodeConnection\x1a\x1b.mizer.nodes.NodeConnection\x12J\n\x11WriteCont\
    rolValue\x12\x19.mizer.nodes.WriteControl\x1a\x1a.mizer.nodes.WriteRespo\
    nse\x12M\n\x11UpdateNodeSetting\x12%.mizer.nodes.UpdateNodeSettingReques\
    t\x1a\x11.mizer.nodes.Node\x12G\n\x08MoveNode\x12\x1c.mizer.nodes.MoveNo\
    deRequest\x1a\x1d.mizer.nodes.MoveNodeResponse\x12M\n\nDeleteNode\x12\
    \x1e.mizer.nodes.DeleteNodeRequest\x1a\x1f.mizer.nodes.DeleteNodeRespons\
    e\x12G\n\x08HideNode\x12\x1c.mizer.nodes.HideNodeRequest\x1a\x1d.mizer.n\
    odes.HideNodeResponse\x12G\n\x08ShowNode\x12\x1c.mizer.nodes.ShowNodeReq\
    uest\x1a\x1d.mizer.nodes.ShowNodeResponse\x12E\n\rDuplicateNode\x12!.miz\
    er.nodes.DuplicateNodeRequest\x1a\x11.mizer.nodes.Node\x12M\n\nRenameNod\
    e\x12\x1e.mizer.nodes.RenameNodeRequest\x1a\x1f.mizer.nodes.RenameNodeRe\
    sponse\x12M\n\nGroupNodes\x12\x1e.mizer.nodes.GroupNodesRequest\x1a\x1f.\
    mizer.nodes.GroupNodesResponseb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::media::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(48);
            messages.push(AddNodeRequest::generated_message_descriptor_data());
            messages.push(DuplicateNodeRequest::generated_message_descriptor_data());
            messages.push(NodesRequest::generated_message_descriptor_data());
            messages.push(WriteControl::generated_message_descriptor_data());
            messages.push(WriteResponse::generated_message_descriptor_data());
            messages.push(UpdateNodeSettingRequest::generated_message_descriptor_data());
            messages.push(MoveNodeRequest::generated_message_descriptor_data());
            messages.push(MoveNodeResponse::generated_message_descriptor_data());
            messages.push(ShowNodeRequest::generated_message_descriptor_data());
            messages.push(ShowNodeResponse::generated_message_descriptor_data());
            messages.push(RenameNodeRequest::generated_message_descriptor_data());
            messages.push(RenameNodeResponse::generated_message_descriptor_data());
            messages.push(GroupNodesRequest::generated_message_descriptor_data());
            messages.push(GroupNodesResponse::generated_message_descriptor_data());
            messages.push(DeleteNodeRequest::generated_message_descriptor_data());
            messages.push(DeleteNodeResponse::generated_message_descriptor_data());
            messages.push(HideNodeRequest::generated_message_descriptor_data());
            messages.push(HideNodeResponse::generated_message_descriptor_data());
            messages.push(Nodes::generated_message_descriptor_data());
            messages.push(AvailableNodes::generated_message_descriptor_data());
            messages.push(AvailableNode::generated_message_descriptor_data());
            messages.push(NodeConnection::generated_message_descriptor_data());
            messages.push(Node::generated_message_descriptor_data());
            messages.push(NodeDetails::generated_message_descriptor_data());
            messages.push(NodeConfig::generated_message_descriptor_data());
            messages.push(NodeSetting::generated_message_descriptor_data());
            messages.push(MidiNodeConfig::generated_message_descriptor_data());
            messages.push(ContainerNodeConfig::generated_message_descriptor_data());
            messages.push(NodePosition::generated_message_descriptor_data());
            messages.push(NodeDesigner::generated_message_descriptor_data());
            messages.push(Port::generated_message_descriptor_data());
            messages.push(node_setting::TextValue::generated_message_descriptor_data());
            messages.push(node_setting::FloatValue::generated_message_descriptor_data());
            messages.push(node_setting::IntValue::generated_message_descriptor_data());
            messages.push(node_setting::BoolValue::generated_message_descriptor_data());
            messages.push(node_setting::SelectValue::generated_message_descriptor_data());
            messages.push(node_setting::SelectVariant::generated_message_descriptor_data());
            messages.push(node_setting::EnumValue::generated_message_descriptor_data());
            messages.push(node_setting::EnumVariant::generated_message_descriptor_data());
            messages.push(node_setting::IdValue::generated_message_descriptor_data());
            messages.push(node_setting::IdVariant::generated_message_descriptor_data());
            messages.push(node_setting::SplineValue::generated_message_descriptor_data());
            messages.push(node_setting::MediaValue::generated_message_descriptor_data());
            messages.push(node_setting::select_variant::SelectGroup::generated_message_descriptor_data());
            messages.push(node_setting::select_variant::SelectItem::generated_message_descriptor_data());
            messages.push(node_setting::spline_value::SplineStep::generated_message_descriptor_data());
            messages.push(midi_node_config::NoteBinding::generated_message_descriptor_data());
            messages.push(midi_node_config::ControlBinding::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(NodeCategory::generated_enum_descriptor_data());
            enums.push(ChannelProtocol::generated_enum_descriptor_data());
            enums.push(node::NodeType::generated_enum_descriptor_data());
            enums.push(node::NodePreviewType::generated_enum_descriptor_data());
            enums.push(midi_node_config::note_binding::MidiType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
